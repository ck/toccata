
;; state-maybe monad with lazy comp*

(defn reduce-args [args s]
  (cond
   (list-empty? args) (list empty-list s)
   (let [[arg & args] args
         result-s (arg s)]
     (cond
      (list-empty? result-s) empty-list
      (let [[result new-s] result-s
            results-s (reduce-args args new-s)]
        (cond
         (list-empty? results-s) empty-list
         (let [[results final-s] results-s]
           (list (cons result results) final-s))))))))

(defn -comp* [mv mvs s]
  (let [x (mv s)]
    (cond
     (list-empty? mvs) x
     (list-empty? x) (let [[mv & mvs] mvs]
                       (-comp* mv mvs s))
     x)))

;; TODO: deftypes don't get added to the importing ns correctly
(deftype new-sm [invoke-fn]
  Stringable
  (string-list [_] (list "<new-sm >"))

  Function
  (invoke [ev s]
    (invoke-fn s))

  Applicative
  (wrap [_ v]
    (new-sm (fn [s]
                (list v s))))
  (apply* [fv args]
    (new-sm (fn [s]
              (let [reduce-state (reduce-args args s)]
                (cond
                 (list-empty? reduce-state) empty-list
                 (let [[results s] reduce-state
                       [f s] (fv s)]
                   (list (apply f results) s)))))))

  Monad
  (flat-map [ev f]
    (new-sm (fn [s]
              (let [v-ss (invoke-fn s)]
                (cond
                 (list-empty? v-ss) v-ss
                 (let [[v ss] v-ss]
                   ((f v) ss)))))))

  Monoid
  (zero [_]
    (new-sm (fn [s]
                empty-list)))
  (comp* [mv mvs]
    (new-sm (partial -comp* mv mvs))))

(def state-maybe
  (reify
    Function
    (invoke [_ v]
      (new-sm (fn [s]
                (list v s))))

    Monoid
    (zero [_]
      (new-sm (fn [s] empty-list)))))

(defn update-state [f]
  (new-sm (fn [s]
              (list s (f s)))))

(defn get-val
  ([k]
     (new-sm (fn [s]
                 (let [v (get s k not-found)]
                   (cond
                    (= not-found v) empty-list
                    (list v s))))))
  ([k nf]
     (new-sm (fn [s]
                 (list (get s k nf) s)))))

(defn set-val [k v]
  (new-sm (fn [s]
              (list (get s k nothing) (assoc s k v)))))

(defn get-in-val
  ([path]
     (new-sm (fn [s]
                 (let [v (get-in s path not-found)]
                   (cond
                    (= not-found v) empty-list
                    (list v s))))))
  ([path nf]
     (new-sm (fn [s]
                 (list (get-in s path nf) s)))))

(defn assoc-in-val [path v]
  (new-sm (fn [s]
              (list v (assoc-in s path v)))))

(defn update-in-val [path f]
  (new-sm (fn [s]
              (list (get-in s path :not-found) (update-in s path f)))))

(defn recur-fn [f as s]
  (let [v-ss (f s)]
    (cond
     (list-empty? v-ss) (list as s)
     (let [[v ss] v-ss]
       (recur-fn f (cons v as) ss)))))

(defn recur [mv]
  (new-sm (fn [s]
            (let [v-ss (mv s)]
              (cond
               (list-empty? v-ss) empty-list
               (let [[v ss] v-ss
                     x (recur-fn (.invoke-fn mv) (list v) ss)]
                 (cond
                  (list-empty? x) x
                  (cons (reverse (car x)) (cdr x)))))))))
