
;; state-maybe monad with lazy comp*
(deftype sm-info-val [v-s]
  Monoid
  (comp* [mv _] mv)

  Applicative
  (wrap [_ new-vs]
    (sm-info-val new-vs))

  Monad
  (flat-map [mv mf] (mf v-s)))

(defn sm-info [& v-s]
  (sm-info-val v-s))

(defn reduce-args [[arg & args] s]
  (match args
         |List _|
         (for [[result new-s] (arg s)
               [results final-s] (reduce-args args new-s)]
           (list (cons result results) final-s))

         (for [[result new-s] (arg s)]
           (list (list result) new-s))))

;; TODO:
;; You would think it wouldn't be that hard to eliminate these 'cond's
;; but it is.
(defn -comp* [mv mvs s]
  (let [x (mv s)]
    (cond
     (= nothing x) (cond
                    (list-empty? mvs) nothing
                    (let [[mv & mvs] mvs]
                      (-comp* mv mvs s)))
     x)))

;; TODO: deftypes don't get added to the importing ns correctly
(deftype new-sm [invoke-fn]
  Stringable
  (string-list [_] (list "<new-sm >"))

  Function
  (invoke [ev s]
    (invoke-fn s))

  Applicative
  (wrap [_ v]
    (new-sm (fn [s]
                (sm-info v s))))
  (apply* [fv args]
    (new-sm (fn [s]
              (for [[results s] (reduce-args args s)
                    [f s] (fv s)]
                (list (apply f results) s)))))

  Monad
  (flat-map [ev f]
    (new-sm (fn [s]
              (flat-map (invoke-fn s)
                        (fn [[v ss]]
                          ((f v) ss))))))

  Monoid
  (zero [_] nothing)
  (comp* [mv mvs]
    (new-sm (partial -comp* mv mvs))))

(def state-maybe
  (reify
    Function
    (invoke [_ v]
      (new-sm (fn [s]
                (sm-info v s))))

    Monoid
    (zero [_] nothing)))

(defn update-state [f]
  (new-sm (fn [s]
              (sm-info s (f s)))))

(defn lift-maybe [mv]
  (new-sm (fn [s]
            (match mv
                   |maybe v|
                   (sm-info v s)))))

(defn get-val [k]
  (new-sm (fn [s]
            (match (m-get s k)
                   |maybe v|
                   (sm-info v s)))))

(defn set-val [k v]
  (new-sm (fn [s]
            (sm-info nothing (assoc s k v)))))

(defn get-in-val
  ([path]
     (new-sm (fn [s]
               (match (get-in s path)
                      |maybe v|
                      (sm-info v s)))))
  ([path nf]
     (new-sm (fn [s]
               (match (get-in s path)
                      |maybe v| (sm-info v s)
                      (sm-info nf s))))))

(defn assoc-in-val [path v]
  (new-sm (fn [s]
              (sm-info v (assoc-in s path v)))))

(defn update-in-val [path f]
  (new-sm (fn [s]
            (match (get-in s path)
                   |maybe v|
                   (sm-info v (update-in s path f))))))

(defn recur-fn [f as s]
  (comp (flat-map (f s)
                  (fn [[v ss]]
                    (recur-fn f (cons v as) ss)))
        (sm-info as s)))

(defn recur [mv]
  (new-sm (fn [s]
            (for [[v ss] (mv s)
                  [v s] (recur-fn (.invoke-fn mv) (list v) ss)]
              (list (reverse v) s)))))
