
(add-ns ast (module "core/ast.toc"))
(add-ns sm (module "core/state-maybe.toc"))
;; (add-ns fio (module "core/file-io.toc"))

(defn set-expr [expr]
  (sm/set-val :expr expr))

(defn is-expr [pred]
  (for [expr (sm/get-val :expr)
        :when (= 1 (pred expr))]
    expr))

(def analyze-expr)

(defn analyze-inline-text []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'inline-text type text|
                      (sm/state-maybe (ast/inline-text text type))

                      |List 'inline-text text|
                      (sm/state-maybe (ast/inline-text text :no-type))

                      (zero sm/state-maybe))]
    result))

(defn analyze-symbol []
  (for [sym (is-expr (partial instance? Symbol))]
    (ast/sym sym)))

(defn analyze-keyword []
  (for [kw (is-expr (partial instance? Keyword))]
    (ast/kw kw)))

(defn make-static-number [num]
  (for [num-idx (sm/get-val :num-count)
        _ (sm/set-val :num-count (inc num-idx))
        _ (sm/assoc-in-val (list :new-numbers num)
                           (str "_num_" num-idx))]
    ""))

(defn analyze-number []
  (for [num (is-expr (partial instance? Number))]
    (ast/number num)))

(defn analyze-string []
  (for [str-val (is-expr string?)]
    (ast/strng str-val)))

(defn analyze-call []
  (for [expr (sm/get-val :expr)
        [target & args] (traverse expr analyze-expr)]
    (ast/call-expr target args)))

(defn analyze-let-binding [binding-pair]
  (match binding-pair
         |List binding expr|
         (for [curr-expr (sm/get-val :expr)
               ast (analyze-expr expr)
               _ (sm/set-val :expr curr-expr)]
           (ast/binding binding ast))

         (zero sm/state-maybe)))

(defn analyze-let []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'let bindings & exprs|
                      (for [bindings (traverse bindings analyze-let-binding)
                            body (traverse exprs analyze-expr)]
                        (ast/let-expr bindings body))
                      (zero sm/state-maybe))]
    result))

(defn analyze-fn-arity []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'fn-arity args exprs|
                      (for [body (traverse exprs analyze-expr)]
                        (match (filter args (partial = "&"))
                               |List _|
                               (ast/variadic-arity (remove args (partial = "&")) body)

                               (ast/fixed-arity args body)))
                      (zero sm/state-maybe))]
    result))

;; TODO: let anonymous function closures reference themselves by name
(defn analyze-fn []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'fn name arities|
                      (for [arities (traverse arities analyze-expr)]
                        (ast/fn-expr (ast/sym name) arities))
                      (zero sm/state-maybe))]
    result))

(defn analyze-proto-arity [[fn-name params & body]]
  (match (filter params (partial = "&"))
         |List _|
         (zero sm/state-maybe)

         (match body
                |List _|
                (for [ast (analyze-expr (list 'fn-arity (rest params) body))]
                  {fn-name {(dec (count params)) {:default ast}}})

                (sm/state-maybe {fn-name {(dec (count params)) {}}}))))

(defn analyze-protocol []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'defprotocol name & defs|
                      (for [proto-fns (traverse defs analyze-proto-arity)]
                        (ast/proto name (apply merge-with comp proto-fns)))
                      (zero sm/state-maybe))]
    result))

(defn make-quoted [quoted-form]
  (match quoted-form
         |Symbol|
         (sm/state-maybe (ast/quoted quoted-form))

         |String|
         (analyze-expr quoted-form)

         |Keyword|
         (analyze-expr quoted-form)

         |Number|
         (analyze-expr quoted-form)

         |List 'quote|
         (make-quoted (car (cdr quoted-form)))

         |List 'hash-map|
         (for [contents (traverse (cdr quoted-form) make-quoted)]
           (ast/call-expr (ast/sym 'hash-map) contents))

         |List 'vector|
         (for [contents (traverse (cdr quoted-form) make-quoted)]
           (ast/call-expr (ast/sym 'vector) contents))

         |List|
         (for [qs (traverse quoted-form make-quoted)]
           (ast/call-expr (ast/sym 'list) qs))

         (sm/state-maybe "")))

(defn analyze-quoted []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'quote quoted| (make-quoted quoted)
                      (zero sm/state-maybe))]
    result))

(defn analyze-def []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'def name value|
                      (for [val-ast (analyze-expr value)]
                        (ast/def-expr name val-ast))

                      |List 'def name|
                      (sm/state-maybe (ast/declare name))
                      (zero sm/state-maybe))]
    result))

(defn analyze-cond []
  (for [expr (sm/get-val :expr)
        clause-pairs (match expr
                            |List 'cond & clause-pairs| (traverse clause-pairs analyze-expr)
                            (zero sm/state-maybe))]
    (let [clauses (partition-all clause-pairs 2)]
      (match (last clauses empty-list)
             |List default| (ast/cond-expr (butlast clauses) default)
             (let [_ (print-err "'cond' must have a default clause")]
               (abort))))))

(defn analyze-match []
  (for [expr (sm/get-val :expr)
        match-ast (match expr
                         |List 'match value clauses default|
                         (apply-to ast/match-expr
                                   (analyze-expr value)
                                   (comp
                                    (traverse clauses
                                              (fn [[pattern result]]
                                                (apply-to list
                                                          (for [_ (analyze-expr pattern)]
                                                            pattern)
                                                          (analyze-expr result))))
                                    (sm/state-maybe empty-list))
                                   (analyze-expr default))
                         (zero sm/state-maybe))]
    match-ast))

(defn analyze-proto-fn []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List frm & frms|
                      (match frm
                             |List name args & exprs|
                             (for [body (traverse exprs analyze-expr)
                                   _ (sm/set-val :expr frms)]
                               {name (list (ast/fixed-arity (rest args) body))})
                             (zero sm/state-maybe))
                      (zero sm/state-maybe))]
    result))

(defn analyze-proto-impl []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List name & frms|
                      (for [_ (sm/set-val :expr frms)
                            :when (= 1 (instance? Symbol name))
                            fn-impls (sm/recur (analyze-proto-fn))]
                        {name (apply merge-with comp fn-impls)})
                      (zero sm/state-maybe))]
    result))

(defn analyze-extensions [exts]
  (for [curr-expr (sm/get-val :expr)
        _ (sm/set-val :expr exts)
        proto-impls (sm/recur (analyze-proto-impl))
        _ (sm/set-val :expr curr-expr)]
    (apply merge-with comp proto-impls)))

(defn analyze-extend-type []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'extend-type name & defs|
                      (for [proto-specs (analyze-extensions defs)]
                        (ast/type-extension name proto-specs))

                      (zero sm/state-maybe))]
    result))

(defn analyze-add-ns []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'add-ns ns-name defs|
                      (for [asts (analyze-expr defs)]
                        (ast/ns-add ns-name asts))

                      (zero sm/state-maybe))]
    result))

(defn analyze-reify []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'reify & defs|
                      (for [proto-specs (analyze-extensions defs)]
                        (ast/reified proto-specs))

                      (zero sm/state-maybe))]
    result))

(defn analyze-deftype []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'deftype name fields & defs| (sm/state-maybe (ast/type-expr name fields defs))
                      (zero sm/state-maybe))]
    result))

(defn analyze-module []
  (for [expr (sm/get-val :expr)
        module-ast (match expr
                          |List 'module module-name|
                          (comp
                           (for [_ (sm/get-in-val (list :modules module-name))]
                             (list (ast/strng module-name)))
                           (for [text (sm/get-val :text)
                                 _ (sm/set-val :text (slurp module-name))
                                 file-name (sm/get-val :file-name)
                                 _ (sm/set-val :file-name module-name)
                                 parser (sm/get-val :parser)
                                 asts (sm/recur (for [expr parser
                                                      ast (analyze-expr expr)]
                                                  ast))
                                 ;; :let [_ (fio/close-stream module-stream)]
                                 _ (sm/set-val :file-name file-name)
                                 _ (sm/set-val :text text)]
                             (cons (ast/strng module-name)
                                   asts)))
                          (zero sm/state-maybe))]
    module-ast))

(defn analyze-main []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'main args & exprs|
                      (for [body (traverse exprs analyze-expr)]
                        (ast/main-fn args body))
                      (zero sm/state-maybe))]
    result))

(defn expr-to-ast []
  (comp (analyze-symbol)
        (analyze-keyword)
        (analyze-number)
        (analyze-string)
        (analyze-fn)
        (analyze-deftype)
        (analyze-protocol)
        (analyze-main)
        (analyze-def)
        (analyze-cond)
        (analyze-match)
        (analyze-extend-type)
        (analyze-reify)
        (analyze-module)
        (analyze-add-ns)
        (analyze-inline-text)
        (analyze-fn-arity)
        (analyze-let)
        (analyze-quoted)
        (analyze-call)
        (flat-map (sm/get-val :expr)
                  (fn [e]
                    (print-err "could not analyze" e)
                    empty-list))))

(defn analyze-expr [expr]
  (for [curr-expr (sm/get-val :expr)
        _ (set-expr expr)
        ast (expr-to-ast)
        _ (set-expr curr-expr)]
    ast))

