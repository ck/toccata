
(add-ns ast (module "core/ast.toc"))
(add-ns sm (module "core/state-maybe.toc"))
;; (add-ns fio (module "core/file-io.toc"))

(defn set-expr [expr]
  (sm/set-val :expr expr))

(defn is-expr [pred]
  (for [expr (sm/get-val :expr)
        :when (pred expr)]
    expr))

(def analyze-expr)

(defn analyze-inline-text []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'inline-text type text|
                      (sm/state-maybe (ast/inline-text text type))

                      |List 'inline-text text|
                      (sm/state-maybe (ast/inline-text text :no-type))

                      (zero sm/state-maybe))]
    result))

(defn analyze-symbol []
  (for [sym (is-expr (partial instance? Symbol))]
    (ast/sym sym)))

(defn keyword-already-defined? [kw]
  (sm/get-in-val (list :keywords kw)))

(defn keyword-recently-defined? [kw]
  (sm/get-in-val (list :new-keywords kw)))

(defn keyword-defined-in-core [kw]
  (for [ext-kw (sm/get-in-val (list :core-keywords kw))
        _ (sm/assoc-in-val (list :keywords kw) ext-kw)
        _ (sm/update-in-val (list :new-externs)
                            (fn [externs]
                              (cons (str "SubString " ext-kw) externs)))]
    ext-kw))

(defn make-static-keyword [kw]
  (for [kw-idx (sm/get-val :kw-count 0)
        _ (sm/set-val :kw-count (inc kw-idx))
        _ (sm/assoc-in-val (list :new-keywords kw)
                           (str "_kw_" kw-idx))]
    ""))

(defn analyze-keyword []
  (for [kw (is-expr (partial instance? Keyword))
        _ (comp (keyword-already-defined? kw)
                (keyword-recently-defined? kw)
                (keyword-defined-in-core kw)
                (make-static-keyword kw))]
    (ast/kw kw)))

(defn number-already-defined? [num]
  (sm/get-in-val (list :numbers num)))

(defn number-recently-defined? [num]
  (sm/get-in-val (list :new-numbers num)))

(defn number-defined-in-core [num]
  (for [ext-num (sm/get-in-val (list :core-numbers num))
        _ (sm/assoc-in-val (list :numbers num) ext-num)
        _ (sm/update-in-val (list :new-externs)
                            (fn [externs]
                              (cons (str "Number " ext-num) externs)))]
    ext-num))

(defn make-static-number [num]
  (for [num-idx (sm/get-val :num-count 0)
        _ (sm/set-val :num-count (inc num-idx))
        _ (sm/assoc-in-val (list :new-numbers num)
                           (str "_num_" num-idx))]
    ""))

(defn analyze-number []
  (for [num (is-expr (partial instance? Number))
        _ (comp (number-already-defined? num)
                (number-recently-defined? num)
                (number-defined-in-core num)
                (make-static-number num))]
    (ast/number num)))

(defn string-already-defined? [str-val]
  (sm/get-in-val (list :strings str-val)))

(defn string-recently-defined? [str-val]
  (sm/get-in-val (list :new-strings str-val)))

(defn string-defined-in-core [str-val]
  (for [ext-str (sm/get-in-val (list :core-strings str-val))
        _ (sm/assoc-in-val (list :strings str-val) ext-str)
        _ (sm/update-in-val (list :new-externs)
                            (fn [externs]
                              (cons (str "String " ext-str) externs)))]
    ext-str))

(defn make-static-string [str-val]
  (for [str-idx (sm/get-val :str-count 0)
        _ (sm/set-val :str-count (inc str-idx))
        _ (sm/assoc-in-val (list :new-strings str-val)
                           (str "_str_" str-idx))]
    ""))

(defn analyze-string []
  (for [str-val (is-expr string?)
        _ (comp (string-already-defined? str-val)
                (string-recently-defined? str-val)
                (string-defined-in-core str-val)
                (make-static-string str-val))]
    (ast/strng str-val)))

(defn analyze-call []
  (for [expr (sm/get-val :expr)
        [target & args] (traverse expr analyze-expr)]
    (ast/call-expr target args)))

(defn analyze-let-binding [binding-pair]
  (match binding-pair
         |List binding expr|
         (for [curr-expr (sm/get-val :expr)
               ast (analyze-expr expr)
               _ (sm/set-val :expr curr-expr)]
           (ast/binding binding ast))

         empty-list))

(defn analyze-let []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'let bindings & exprs|
                      (for [bindings (traverse bindings analyze-let-binding)
                            body (traverse exprs analyze-expr)]
                        (ast/let-expr bindings body))

                      (zero sm/state-maybe))]
    result))

(defn analyze-fn-arity []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'fn-arity args exprs|
                      (for [body (traverse exprs analyze-expr)]
                        (match (filter args (partial = "&"))
                               |List _|
                               (ast/variadic-arity (remove args (partial = "&")) body)

                               (ast/fixed-arity args body)))
                      (zero sm/state-maybe))]
    result))

;; TODO: let anonymous function closures reference themselves by name
(defn analyze-fn []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'fn name arities|
                      (for [arities (traverse arities analyze-expr)]
                        (ast/fn-expr (ast/sym name) arities))

                      (zero sm/state-maybe))]
    result))

(defn analyze-proto-arity [args]
  (match args
         |List fn-name params first-body & body|
         (let [params (rest params)
               default-fn-expr (list 'fn-arity params (cons first-body body))]
           (for [ast (analyze-expr default-fn-expr)]
             {fn-name {(count params) {:default ast}}}))

         |List fn-name params|
         (sm/state-maybe {fn-name {(dec (count params)) {}}})

         (zero sm/state-maybe)))

(defn sym-already-defined? [sym]
  (sm/get-in-val (list :symbols sym)))

(defn sym-recently-defined? [sym]
  (sm/get-in-val (list :new-symbols sym)))

(defn sym-defined-in-core [sym]
  (for [ext-sym (sm/get-in-val (list :core-symbols sym))
        _ (sm/assoc-in-val (list :symbols sym) ext-sym)
        _ (sm/update-in-val (list :new-externs)
                            (fn [externs]
                              (cons (str "SubString " ext-sym) externs)))]
    ext-sym))

(defn make-static-symbol [sym]
  (for [sym-idx (sm/get-val :sym-count 0)
        _ (sm/set-val :sym-count (inc sym-idx))
        _ (sm/assoc-in-val (list :new-symbols sym)
                           (str "_sym_" sym-idx))]
    sym))

(defn make-quoted [quoted-form]
  (cond
   (instance? Symbol quoted-form)
   (for [_ (comp (sym-already-defined? quoted-form)
                 (sym-recently-defined? quoted-form)
                 (sym-defined-in-core quoted-form)
                 (make-static-symbol quoted-form))]
     (ast/quoted quoted-form))

   (match quoted-form
          |String|
          (analyze-expr quoted-form)

          |Keyword|
          (analyze-expr quoted-form)

          |Number|
          (analyze-expr quoted-form)

          |List 'quote|
          (make-quoted (car (cdr quoted-form)))

          |List 'hash-map|
          (for [contents (traverse (cdr quoted-form) make-quoted)]
            (ast/call-expr (ast/sym 'hash-map) contents))

          |List 'vector|
          (for [contents (traverse (cdr quoted-form) make-quoted)]
            (ast/call-expr (ast/sym 'vector) contents))

          |List|
          (for [qs (traverse quoted-form make-quoted)]
            (ast/call-expr (ast/sym 'list) qs))

          (sm/state-maybe ""))))

(defn analyze-quoted []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'quote quoted|
                      (make-quoted quoted)

                      (zero sm/state-maybe))]
    result))

(defn analyze-def []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'def name value|
                      (for [val-ast (analyze-expr value)]
                        (ast/def-expr name val-ast))

                      |List 'def name|
                      (sm/state-maybe (ast/def-expr name :no-value))

                      (zero sm/state-maybe))]
    result))

(defn analyze-cond []
  (for [expr (sm/get-val :expr)
        clause-pairs (match expr
                            |List 'cond & clause-pairs|
                            (traverse clause-pairs analyze-expr)

                            (zero sm/state-maybe))]
    (let [clauses (partition-all clause-pairs 2)
          default (last clauses empty-list)]
      (cond
       (= 1 (count default)) (ast/cond-expr (butlast clauses)
                                            (first default))
       (let [_ (print-err "'cond' must have a default clause")]
         (abort))))))

(defn analyze-match []
  (for [expr (sm/get-val :expr)
        match-ast (match expr
                         |List 'match value & clause-pairs|
                         (let [clauses (partition-all clause-pairs 2)
                               default (last clauses empty-list)
                               clauses (butlast clauses)]
                           (apply-to ast/match-expr
                                     (analyze-expr value)
                                     (cond
                                      (empty? clauses) (sm/state-maybe empty-list)
                                      (traverse clauses
                                                (fn [[pattern result]]
                                                  (apply-to list
                                                            (for [_ (analyze-expr pattern)]
                                                              pattern)
                                                            (analyze-expr result)))))
                                     (cond
                                      (empty? default) (let [_ (print-err "'match' must have a default clause")]
                                                         (abort))
                                      (analyze-expr (car default)))))

                         (zero sm/state-maybe))]
    match-ast))

(defn analyze-proto-fn []
  (for [[[name [_ & args] & exprs] & frms] (is-expr (fn [x]
                                                      (cond
                                                       (not (seq? x)) false
                                                       (empty? x) false
                                                       (not (seq? (car x))) false
                                                       (< 2 (count (car x))))))
        _ (sm/set-val :expr frms)
        body (traverse exprs analyze-expr)]
    (list name
          (ast/fn-expr (ast/sym (symbol (str name "_impl")))
                       (list (ast/fixed-arity args body))))))

(defn analyze-proto-impl []
  (for [[name & frms] (is-expr (fn [x]
                                 (cond
                                  (not (seq? x)) false
                                  (empty? x) false
                                  (instance? Symbol (car x)))))
        _ (sm/set-val :expr frms)
        fn-impls (sm/recur (analyze-proto-fn))]
    (list name fn-impls)))

(defn analyze-extensions [exts]
  (for [curr-expr (sm/get-val :expr empty-list)
        _ (sm/set-val :expr exts)
        proto-impls (sm/recur (analyze-proto-impl))
        _ (sm/set-val :expr curr-expr)]
    (reduce proto-impls {} (fn [m [k v]]
                             (let [old-v (get m k empty-list)
                                   new-v (comp old-v v)]
                               (assoc m k new-v))))))


(defn analyze-extend-type []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'extend-type name & defs|
                      (for [proto-specs (analyze-extensions defs)]
                        (ast/type-extension name proto-specs))

                      (zero sm/state-maybe))]
    result))

(defn analyze-module []
  (for [expr (sm/get-val :expr)
        module-ast (match expr
                          |List 'module module-name|
                          (comp
                           (for [_ (sm/get-in-val (list :modules module-name :syms))]
                             (list (ast/strng module-name)))
                           (for [text (sm/get-val :text)
                                 :let [module-stream (slurp module-name)]
                                 _ (sm/set-val :text module-stream)
                                 file-name (sm/get-val :file-name)
                                 _ (sm/set-val :file-name module-name)
                                 parser (sm/get-val :parser)
                                 asts (sm/recur (for [expr parser
                                                      ast (analyze-expr expr)]
                                                  ast))
                                 ;; :let [_ (fio/close-stream module-stream)]
                                 _ (sm/set-val :file-name file-name)
                                 _ (sm/set-val :text text)]
                             (cons (ast/strng module-name)
                                   asts))
                           (sm/state-maybe (list (ast/strng module-name))))

                          (zero sm/state-maybe))]
    module-ast))

(defn analyze-add-ns []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'add-ns ns-name defs|
                      (for [asts (analyze-expr defs)]
                        (ast/ns-add ns-name asts))

                      (zero sm/state-maybe))]
    result))

;; TODO: handle multi-arity reified fns
(defn analyze-reify []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'reify & defs|
                      (for [proto-specs (analyze-extensions defs)]
                        (ast/reified proto-specs))

                      (zero sm/state-maybe))]
    result))

(defn analyze-protocol []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'defprotocol name & defs|
                      (for [;; TODO: make this only accept fixed arities
                            arities (traverse defs analyze-proto-arity)]
                        (ast/proto name (apply merge-with comp arities)))

                      (zero sm/state-maybe))]
    result))

(defn analyze-deftype []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'deftype name fields & defs|
                      (sm/state-maybe (ast/type-expr name fields defs))

                      (zero sm/state-maybe))]
    result))

(defn analyze-main []
  (for [expr (sm/get-val :expr)
        result (match expr
                      |List 'main args & exprs|
                      (for [body (traverse exprs analyze-expr)]
                        (ast/main-fn args body))

                      (zero sm/state-maybe))]
    result))

(defn expr-to-ast []
  (comp (analyze-symbol)
        (analyze-keyword)
        (analyze-number)
        (analyze-string)
        (analyze-fn)
        (analyze-deftype)
        (analyze-protocol)
        (analyze-main)
        (analyze-def)
        (analyze-cond)
        (analyze-match)
        (analyze-extend-type)
        (analyze-reify)
        (analyze-module)
        (analyze-add-ns)
        (analyze-inline-text)
        (analyze-fn-arity)
        (analyze-let)
        (analyze-quoted)
        (analyze-call)
        (flat-map (sm/get-val :expr :expr-nil)
                  (fn [e]
                    (print-err "could not analyze" e)
                    empty-list))))

(defn analyze-expr [expr]
  (for [curr-expr (sm/get-val :expr :no-expr)
        _ (set-expr expr)
        ast (expr-to-ast)
        _ (set-expr curr-expr)]
    ast))

