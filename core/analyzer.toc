
(add-ns ast (module "core/ast.toc"))
(add-ns sm (module "core/state-maybe.toc"))
;; (add-ns fio (module "core/file-io.toc"))

(defn set-expr [expr]
  (sm/set-val :expr expr))

(defn is-expr [pred]
  (for [expr (sm/get-val :expr)
        :when (pred expr)]
    expr))

(def analyze-expr)

(defn analyze-inline-text []
  (for [expr (is-expr (fn [x]
                        (cond
                         (not (seq? x)) false
                         (empty? x) false
                         (= (first x) 'inline-text))))]
    (cond
     (= 3 (count expr)) (ast/inline-text (nth expr 2 "") (nth expr 1 :no-type))
     (ast/inline-text (nth expr 1 "") :no-type))))

(defn analyze-symbol []
  (for [sym (is-expr symbol?)]
    (ast/sym sym)))

(defn keyword-already-defined? [kw]
  (sm/get-in-val (list :keywords kw)))

(defn keyword-recently-defined? [kw]
  (sm/get-in-val (list :new-keywords kw)))

(defn keyword-defined-in-core [kw]
  (for [ext-kw (sm/get-in-val (list :core-keywords kw))
        _ (sm/assoc-in-val (list :keywords kw) ext-kw)
        _ (sm/update-in-val (list :new-externs)
                            (fn [externs]
                              (cons (str "SubString " ext-kw) externs)))]
    ext-kw))

(defn make-static-keyword [kw]
  (for [kw-idx (sm/get-val :kw-count 0)
        _ (sm/set-val :kw-count (inc kw-idx))
        _ (sm/assoc-in-val (list :new-keywords kw)
                           (str "_kw_" kw-idx))]
    ""))

(defn analyze-keyword []
  (for [kw (is-expr keyword?)
        _ (comp (keyword-already-defined? kw)
                (keyword-recently-defined? kw)
                (keyword-defined-in-core kw)
                (make-static-keyword kw))]
    (ast/kw kw)))

(defn number-already-defined? [num]
  (sm/get-in-val (list :numbers num)))

(defn number-recently-defined? [num]
  (sm/get-in-val (list :new-numbers num)))

(defn number-defined-in-core [num]
  (for [ext-num (sm/get-in-val (list :core-numbers num))
        _ (sm/assoc-in-val (list :numbers num) ext-num)
        _ (sm/update-in-val (list :new-externs)
                            (fn [externs]
                              (cons (str "Number " ext-num) externs)))]
    ext-num))

(defn make-static-number [num]
  (for [num-idx (sm/get-val :num-count 0)
        _ (sm/set-val :num-count (inc num-idx))
        _ (sm/assoc-in-val (list :new-numbers num)
                           (str "_num_" num-idx))]
    ""))

(defn analyze-number []
  (for [num (is-expr number?)
        _ (comp (number-already-defined? num)
                (number-recently-defined? num)
                (number-defined-in-core num)
                (make-static-number num))]
    (ast/number num)))

(defn string-already-defined? [str-val]
  (sm/get-in-val (list :strings str-val)))

(defn string-recently-defined? [str-val]
  (sm/get-in-val (list :new-strings str-val)))

(defn string-defined-in-core [str-val]
  (for [ext-str (sm/get-in-val (list :core-strings str-val))
        _ (sm/assoc-in-val (list :strings str-val) ext-str)
        _ (sm/update-in-val (list :new-externs)
                            (fn [externs]
                              (cons (str "String " ext-str) externs)))]
    ext-str))

(defn make-static-string [str-val]
  (for [str-idx (sm/get-val :str-count 0)
        _ (sm/set-val :str-count (inc str-idx))
        _ (sm/assoc-in-val (list :new-strings str-val)
                           (str "_str_" str-idx))]
    ""))

(defn analyze-string []
  (for [str-val (is-expr string?)
        _ (comp (string-already-defined? str-val)
                (string-recently-defined? str-val)
                (string-defined-in-core str-val)
                (make-static-string str-val))]
    (ast/strng str-val)))

(defn analyze-call []
  (for [expr (is-expr not-empty?)
        [target & args] (traverse expr analyze-expr)]
    (ast/call-expr target args)))

(defn analyze-let-binding [binding-pair]
  (cond
   (not (= 2 (count binding-pair))) empty-list
   (let [[binding expr] binding-pair]
     (for [curr-expr (sm/get-val :expr)
           _ (set-expr binding)
           ast (analyze-expr expr)
           _ (sm/set-val :expr curr-expr)]
       (ast/binding binding ast)))))

(defn analyze-let []
  (for [[_ bindings & exprs] (is-expr (fn [x]
                                        (cond
                                         (not (seq? x)) false
                                         (not (< 2 (count x))) false
                                         (= (first x) 'let))))
        bindings (traverse bindings analyze-let-binding)
        body (traverse exprs analyze-expr)]
    (ast/let-expr bindings body)))

(defn variadic? [[_ args]]
  (any? (partial = "&") args))

(defn analyze-variadic []
  (for [[_ args exprs] (is-expr (fn [x]
                                    (cond
                                     (< (count x) 2) false
                                     (not (= (first x) 'fn-arity)) false
                                     (variadic? x))))
        body (traverse exprs analyze-expr)]
    (ast/variadic-arity (remove args (partial = "&")) body)))

(defn analyze-fn-arity []
  (for [[_ args exprs] (is-expr (fn [x]
                                  (cond
                                   (< (count x) 2) false
                                   (not (= (first x) 'fn-arity)) false
                                   (not (variadic? x)))))
        file-name (sm/get-val :file-name "")
        body (traverse exprs analyze-expr)]
    (ast/fixed-arity args body)))

;; TODO: let anonymous function closures reference themselves by name
(defn analyze-fn []
  (for [[_ name arities] (is-expr (fn [x]
                                    (cond
                                     (not (seq? x)) false
                                     (< (count x) 2) false
                                     (= (first x) 'fn))))
        arities (traverse arities analyze-expr)]
    (ast/fn-expr (ast/sym name) arities)))

(defn analyze-proto-arity [args]
  (cond
   (< (count args) 2) empty-list
   (let [[fn-name params & body] args
         params (rest params)
         default-fn-expr (list 'fn-arity params body)]
     (cond
      (< 0 (count body)) (sm/new-sm
                          (fn [s]
                            (let [v-ss ((analyze-expr default-fn-expr) s)]
                              (cond
                               (list-empty? v-ss) v-ss
                               (cons {fn-name {(count params) {:default (car v-ss)}}}
                                     (cdr v-ss))))))
      (sm/state-maybe {fn-name {(count params) {}}})))))

(defn sym-already-defined? [sym]
  (sm/get-in-val (list :symbols sym)))

(defn sym-recently-defined? [sym]
  (sm/get-in-val (list :new-symbols sym)))

(defn sym-defined-in-core [sym]
  (for [ext-sym (sm/get-in-val (list :core-symbols sym))
        _ (sm/assoc-in-val (list :symbols sym) ext-sym)
        _ (sm/update-in-val (list :new-externs)
                            (fn [externs]
                              (cons (str "SubString " ext-sym) externs)))]
    ext-sym))

(defn make-static-symbol [sym]
  (for [sym-idx (sm/get-val :sym-count 0)
        _ (sm/set-val :sym-count (inc sym-idx))
        _ (sm/assoc-in-val (list :new-symbols sym)
                           (str "_sym_" sym-idx))]
    sym))

(defn make-quoted [quoted-form]
  (cond
   (symbol? quoted-form)
   (for [_ (comp (sym-already-defined? quoted-form)
                 (sym-recently-defined? quoted-form)
                 (sym-defined-in-core quoted-form)
                 (make-static-symbol quoted-form))]
     (ast/quoted quoted-form))

   (or (number? quoted-form)
       (keyword? quoted-form)
       (string? quoted-form))
   (analyze-expr quoted-form)

   (seq? quoted-form)
   (cond
    (= 'quote (car quoted-form))
    (make-quoted (car (cdr quoted-form)))

    (= 'hash-map (car quoted-form))
    (for [contents (traverse (cdr quoted-form) make-quoted)]
      (ast/call-expr (ast/sym 'hash-map) contents))

    (= 'vector (car quoted-form))
    (for [contents (traverse (cdr quoted-form) make-quoted)]
      (ast/call-expr (ast/sym 'vector) contents))

    (for [qs (traverse quoted-form make-quoted)]
      (ast/call-expr (ast/sym 'list) qs)))

   (sm/state-maybe "")))

(defn analyze-quoted []
  (for [[_ quoted] (is-expr (fn [x]
                              (cond
                               (not (= 2 (count x))) false
                               (= (first x) 'quote))))
        result (make-quoted quoted)]
    result))

(defn analyze-def []
  (for [curr-expr (sm/get-val :expr :no-expr)
        expr (is-expr (fn [x]
                        (cond
                         (not (seq? x)) false
                         (< (count x) 2) false
                         (= (first x) 'def))))
        :let [name (nth expr 1 'no-name)
              value (nth expr 2 :no-value)]
        val-ast (cond
                 (= value :no-value) (sm/state-maybe :no-value)
                 (analyze-expr value))]
    (ast/def-expr name val-ast)))

(defn analyze-cond []
  (for [[_ & clause-pairs] (is-expr (fn [x]
                                      (cond
                                       (not (seq? x)) false
                                       (empty? x) false
                                       (= (first x) 'cond))))
        clause-pairs (traverse clause-pairs analyze-expr)]
    (let [clauses (partition-all clause-pairs 2)
          default (last clauses empty-list)]
      (cond
       (= 1 (count default)) (ast/cond-expr (butlast clauses)
                                            (first default))
       (print-err "cond must have a default clause")))))

(defn is-form? [pred]
  (for [[frm & frms] (is-expr (fn [x]
                                (cond
                                 (empty? x) false
                                 (pred (car x)))))
        _ (sm/set-val :expr frms)]
    frm))

(defn analyze-proto-fn []
  (for [[name [_ & args] & exprs] (is-form? (fn [x]
                                              (cond
                                               (not (seq? x)) false
                                               (< 2 (count x)))))
        body (traverse exprs analyze-expr)]
    (list name
          (ast/fn-expr (ast/sym (symbol (str name "_impl")))
                       (list (ast/fixed-arity args body))))))

(defn analyze-proto-impl []
  (for [name (is-form? symbol?)
        fn-impls (sm/recur (analyze-proto-fn))]
    (list name fn-impls)))

(defn analyze-extensions [exts]
  (for [curr-expr (sm/get-val :expr empty-list)
        _ (sm/set-val :expr exts)
        proto-impls (sm/recur (analyze-proto-impl))
        _ (sm/set-val :expr curr-expr)]
    (reduce proto-impls {} (fn [m [k v]]
                             (let [old-v (get m k empty-list)
                                   new-v (comp old-v v)]
                               (assoc m k new-v))))))


(defn analyze-extend-type []
  (for [[_ name & defs] (is-expr (fn [x]
                                   (cond
                                    (not (seq? x)) false
                                    (not (< 1 (count x))) false
                                    (= 'extend-type (first x)))))
        proto-specs (analyze-extensions defs)]
    (ast/type-extension name proto-specs)))

(defn analyze-module []
  (for [[_ module-name] (is-expr (fn [x]
                                   (cond
                                    (not (seq? x)) false
                                    (not (= 2 (count x))) false
                                    (= 'module (first x)))))
        module-ast (comp
                    (for [_ (sm/get-in-val (list :modules module-name :syms))]
                      (list (ast/strng module-name)))
                    (for [text (sm/get-val :text)
                          :let [module-stream (slurp module-name)]
                          _ (sm/set-val :text module-stream)
                          file-name (sm/get-val :file-name)
                          _ (sm/set-val :file-name module-name)
                          parser (sm/get-val :parser)
                          asts (sm/recur (for [expr parser
                                               ast (analyze-expr expr)]
                                           ast))
                          ;; :let [_ (fio/close-stream module-stream)]
                          _ (sm/set-val :file-name file-name)
                          _ (sm/set-val :text text)]
                      (cons (ast/strng module-name)
                            asts))
                    (sm/state-maybe (list (ast/strng module-name))))]
    module-ast))

(defn analyze-add-ns []
  (for [[_ ns-name defs] (is-expr (fn [x]
                                    (cond
                                     (not (seq? x)) false
                                     (not (= 3 (count x))) false
                                     (and (= 'add-ns (first x))
                                          (symbol? (second x))))))
        asts (analyze-expr defs)]
    (ast/ns-add ns-name asts)))

;; TODO: handle multi-arity reified fns
(defn analyze-reify []
  (for [[_ & defs] (is-expr (fn [x]
                        (cond
                         (not (seq? x)) false
                         (= 'reify (nth x 0 :not-reify)))))
        proto-specs (analyze-extensions defs)]
    (ast/reified proto-specs)))

(defn analyze-protocol []
  (for [expr (is-expr (fn [x]
                        (cond
                         (not (seq? x)) false
                         (not (< 2 (count x))) false
                         (= 'defprotocol (first x)))))
        ;; TODO: make this only accept fixed arities
        arities (traverse (drop expr 2) analyze-proto-arity)]
    (ast/proto (second expr) (apply merge-with comp arities))))

(defn analyze-deftype []
  (for [[_ name fields & defs] (is-expr (fn [x]
                                          (cond
                                           (not (seq? x)) false
                                           (< (count x) 3) false
                                           (= 'deftype (first x)))))]
    (ast/type-expr name fields defs)))

(defn analyze-main []
  (for [[_ args & exprs] (is-expr (fn [x]
                                    (cond
                                     (not (seq? x)) false
                                     (not (< 2 (count x))) false
                                     (= 'main (first x)))))
        body (traverse exprs analyze-expr)]
    (ast/main-fn args body)))

(defn expr-to-ast []
  (comp (analyze-symbol)
        (analyze-keyword)
        (analyze-number)
        (analyze-string)
        (analyze-fn)
        (analyze-deftype)
        (analyze-protocol)
        (analyze-main)
        (analyze-def)
        (analyze-cond)
        (analyze-extend-type)
        (analyze-reify)
        (analyze-module)
        (analyze-add-ns)
        (analyze-inline-text)
        (analyze-fn-arity)
        (analyze-variadic)
        (analyze-let)
        (analyze-quoted)
        (analyze-call)
        (flat-map (sm/get-val :expr :expr-nil)
                  (fn [e]
                    (print-err "could not analyze" e)
                    empty-list))))

(defn analyze-expr [expr]
  (for [curr-expr (sm/get-val :expr :no-expr)
        _ (set-expr expr)
        ast (expr-to-ast)
        _ (set-expr curr-expr)]
    ast))

