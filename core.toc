
(def print-err)

(def VoidT "void")
(def Int8 "char")
(def Int8* "char *")
(def Int32 "int")
(def Int64 "int64_t")
(def ValueType Int64)  ;; type of boxed values
(def Value "typedef struct {int64_t type; int32_t refs;} Value;\n")
(def Value* "Value *")
(def NumberVal "typedef struct {int64_t type; int32_t refs; int64_t numVal;} Number;\n")
(def StringVal "typedef struct {int64_t type; int32_t refs; int64_t len; char buffer[0];} String;\n")
(def SubStringVal "typedef struct {int64_t type; int32_t refs; int64_t len; Number *hash; Value *source; char *buffer;} SubString;\n")
(def ListVal "typedef struct List {int64_t type; int32_t refs; int64_t len; Value* head; struct List *tail;} List;\n")
(def FnArityVal "typedef struct {int64_t type; int32_t refs; int count; List *closures; int variadic; void *fn;} FnArity;\n")
(def FunctionVal "typedef struct {int64_t type; int32_t refs; char *name; int64_t arityCount; FnArity *arities[];} Function;\n")
(def ProtoImpl "typedef struct {int64_t type; Value *implFn;} ProtoImpl;\n")
(def ProtoImpls "typedef struct {int64_t implCount; Value *defaultImpl; ProtoImpl impls[];} ProtoImpls;\n")
(def ReifiedVal "typedef struct {int64_t type; int32_t refs; int implCount; Value* impls[];} ReifiedVal;\n")
(def OpaqueVal "typedef struct {int64_t type; int32_t refs; void *ptr;} Opaque;\n")
(def BitmapIndexedVal "typedef struct {int64_t type; int32_t refs; int32_t bitmap; Value *array[];} BitmapIndexedNode;\n")
(def ArrayNodeVal "typedef struct {int64_t type; int32_t refs; Value *array[32];} ArrayNode;\n")
(def HashCollisionVal "typedef struct {int64_t type; int32_t refs; int16_t count; Value *array[];} HashCollisionNode;\n")

(def true (inline-text "(Value *)&trueVal;"))
(def false (inline-text "(Value *)&falseVal;"))

;; SHA1 implementation courtesy of: Steve Reid <sreid@sea-to-sky.net>
;; and others.
;; from http://waterjuice.org/c-source-code-for-sha1/
(inline-text "
#include <stdint.h>
#include <memory.h>
#include <pthread.h>

typedef struct
{
    uint32_t        State[5];
    uint32_t        Count[2];
    uint8_t         Buffer[64];
} Sha1Context;

#define SHA1_HASH_SIZE           ( 64 / 8 )

typedef struct
{
    uint8_t      bytes [SHA1_HASH_SIZE];
} SHA1_HASH;

typedef union
{
    uint8_t     c [64];
    uint32_t    l [16];
} CHAR64LONG16;

#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))
#define blk0(i) (block->l[i] = (rol(block->l[i],24)&0xFF00FF00) |(rol(block->l[i],8)&0x00FF00FF))
#define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] ^block->l[(i+2)&15]^block->l[i&15],1))

#define R0(v,w,x,y,z,i)  z += ((w&(x^y))^y)     + blk0(i)+ 0x5A827999 + rol(v,5); w=rol(w,30);
#define R1(v,w,x,y,z,i)  z += ((w&(x^y))^y)     + blk(i) + 0x5A827999 + rol(v,5); w=rol(w,30);
#define R2(v,w,x,y,z,i)  z += (w^x^y)           + blk(i) + 0x6ED9EBA1 + rol(v,5); w=rol(w,30);
#define R3(v,w,x,y,z,i)  z += (((w|x)&y)|(w&x)) + blk(i) + 0x8F1BBCDC + rol(v,5); w=rol(w,30);
#define R4(v,w,x,y,z,i)  z += (w^x^y)           + blk(i) + 0xCA62C1D6 + rol(v,5); w=rol(w,30);


static void TransformFunction(uint32_t state[5], const uint8_t buffer[64]) {
    uint32_t            a;
    uint32_t            b;
    uint32_t            c;
    uint32_t            d;
    uint32_t            e;
    uint8_t             workspace[64];
    CHAR64LONG16*       block = (CHAR64LONG16*) workspace;

    memcpy( block, buffer, 64 );

    // Copy context->state[] to working vars
    a = state[0];
    b = state[1];
    c = state[2];
    d = state[3];
    e = state[4];

    // 4 rounds of 20 operations each. Loop unrolled.
    R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
    R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
    R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
    R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
    R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
    R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
    R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
    R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
    R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
    R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);
    R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
    R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
    R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
    R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
    R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
    R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
    R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
    R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
    R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
    R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);

    // Add the working vars back into context.state[]
    state[0] += a;
    state[1] += b;
    state[2] += c;
    state[3] += d;
    state[4] += e;
}

void Sha1Initialise (Sha1Context* Context) {
    // SHA1 initialization constants
    Context->State[0] = 0x67452301;
    Context->State[1] = 0xEFCDAB89;
    Context->State[2] = 0x98BADCFE;
    Context->State[3] = 0x10325476;
    Context->State[4] = 0xC3D2E1F0;
    Context->Count[0] = 0;
    Context->Count[1] = 0;
}

void Sha1Update (Sha1Context* Context, void* Buffer, int64_t BufferSize) {
    uint32_t    i;
    uint32_t    j;

    j = (Context->Count[0] >> 3) & 63;
    if( (Context->Count[0] += BufferSize << 3) < (BufferSize << 3) )
    {
        Context->Count[1]++;
    }

    Context->Count[1] += (BufferSize >> 29);
    if( (j + BufferSize) > 63 )
    {
        i = 64 - j;
        memcpy( &Context->Buffer[j], Buffer, i );
        TransformFunction(Context->State, Context->Buffer);
        for( ; i + 63 < BufferSize; i += 64 )
        {
            TransformFunction(Context->State, (uint8_t*)Buffer + i);
        }
        j = 0;
    }
    else
    {
        i = 0;
    }

    memcpy( &Context->Buffer[j], &((uint8_t*)Buffer)[i], BufferSize - i );
}

void Sha1Finalise (Sha1Context* Context, SHA1_HASH* Digest) {
    uint32_t    i;
    uint8_t     finalcount[8];

    for( i=0; i<8; i++ )
    {
        finalcount[i] = (unsigned char)((Context->Count[(i >= 4 ? 0 : 1)]
         >> ((3-(i & 3)) * 8) ) & 255);  // Endian independent
    }
    Sha1Update( Context, (uint8_t*)\"\\x80\", 1 );
    while( (Context->Count[0] & 504) != 448 )
    {
        Sha1Update( Context, (uint8_t*)\"\\0\", 1 );
    }

    Sha1Update( Context, finalcount, 8 );  // Should cause a Sha1TransformFunction()
    for( i=0; i<SHA1_HASH_SIZE; i++ )
    {
        Digest->bytes[i] = (uint8_t)((Context->State[i>>2] >> ((3-(i & 3)) * 8) ) & 255);
    }
}
")

(inline-text "
Value *valsEqual(List *, Value *, Value *);

int64_t equal(Value *v1, Value *v2) {
  return (isTrue(valsEqual((List *)0, v1, v2)));
}
")

(inline-text "
Value *assoc(Value *, Value *, Value *, Value *, Value *);
Value *get(Value *, Value *, Value *, Value *, Value *);
")

(inline-text "
Value *sha1(Value *);
")

(inline-text "
Value *hashSeq(Value* n, Value *s);
")

(inline-text "
Value *count(Value* n);
")

(defn output-to-file [file-path]
  (inline-text Number
   "String *arg0Str = (String *)my_malloc(sizeof(String) + ((String *)arg0)->len + 5);
    arg0Str->type = StringType;
    if (arg0->type == StringType)
      snprintf(arg0Str->buffer, ((String *)arg0)->len + 1, \"%s\", ((String *)arg0)->buffer);
    else if (arg0->type == SubStringType)
      snprintf(arg0Str->buffer, ((String *)arg0)->len + 1, \"%s\", ((SubString *)arg0)->buffer);
    else {
      fprintf(stderr, \"\\ninvalid type for 'output-to-file'\\n\");
      abort();
    }

    outStream = fopen(arg0Str->buffer, \"w\");
    dec_and_free((Value *)arg0Str);
    return((Value *)&trueVal);\n"))

(defn standard-output []
  (inline-text Number
   "outStream = stdout;
    return((Value *)&trueVal);\n"))

(defn symkey-name [v]
  (inline-text String
   "return(stringValue(((SubString *)arg0)->buffer));\n"))

(defn char-code [c]
  (inline-text Number
   "if (arg0->type == StringType) {
        String *s = (String *)arg0;
        return(numberValue((int)s->buffer[0]));
      } else if (arg0->type == SubStringType) {
        SubString *s = (SubString *)arg0;
        return(numberValue((int)s->buffer[0]));
      } else
        abort();\n "))

(defn symbol [sym-str]
  (inline-text Symbol
   "if (arg0->type == StringType) {
        String *s = (String *)arg0;
        SubString *subStr = malloc_substring();
        subStr->type = SymbolType;
        subStr->len = s->len;
        subStr->source = arg0;
        subStr->hash = (Number *)0;
        incRef(arg0);
        subStr->buffer = s->buffer;
        return((Value *)subStr);
      } else if (arg0->type == SubStringType) {
        SubString *s = (SubString *)arg0;
        SubString *subStr = malloc_substring();
        subStr->type = SymbolType;
        subStr->len = s->len;
        subStr->source = arg0;
        subStr->hash = (Number *)0;
        incRef(arg0);
        subStr->buffer = s->buffer;
        return((Value *)subStr);
      } else if (arg0->type == SymbolType) {
        return(arg0);
      }
        abort();\n"))

(defn new-keyword [kw-str]
  (inline-text Keyword
   "if (arg0->type == StringType) {
        String *s = (String *)arg0;
        SubString *subStr = malloc_substring();
        subStr->type = KeywordType;
        subStr->len = s->len;
        subStr->source = arg0;
        subStr->hash = (Number *)0;
        incRef(arg0);
        subStr->buffer = s->buffer;
        return((Value *)subStr);
      } else if (arg0->type == SubStringType) {
        SubString *s = (SubString *)arg0;
        SubString *subStr = malloc_substring();
        subStr->type = KeywordType;
        subStr->len = s->len;
        subStr->source = arg0;
        subStr->hash = (Number *)0;
        incRef(arg0);
        subStr->buffer = s->buffer;
        return((Value *)subStr);
      } else
        abort();\n"))

(defn abort []
  (inline-text Number
   "abort();
    return(true);\n"))

(defn get-type [value]
  (inline-text Number
   "return(numberValue(arg0->type));"))

(defn type= [x y]
  (inline-text Number
   "if (arg0->type == arg1->type)
      return(true);
    else
      return(false);\n"))

(defn subs
  ([src index]
     (inline-text SubString
      "int64_t idx = ((Number *)arg1)->numVal;
        if (arg0->type == StringType) {
          String *s = (String *)arg0;
          SubString *subStr = malloc_substring();
          subStr->type = SubStringType;
          if (idx < s->len) {
            subStr->len = s->len - idx;
            subStr->source = arg0;
            incRef(arg0);
            subStr->buffer = s->buffer + idx;
          }
          else {
            subStr->len = 0;
            subStr->source = (Value *)0;
            subStr->buffer = (char *)0;
          }
          return((Value *)subStr);
        } else if (arg0->type == SubStringType) {
          SubString *s = (SubString *)arg0;
          SubString *subStr = malloc_substring();
          subStr->type = SubStringType;
          if (idx < s->len) {
            subStr->len = s->len - idx;
            subStr->source = arg0;
            incRef(arg0);
            subStr->buffer = s->buffer + idx;
          }
          else {
            subStr->len = 0;
            subStr->source = (Value *)0;
            subStr->buffer = (char *)0;
          }
          return((Value *)subStr);
        } else
          abort();\n"))
  ([src index length]
     (inline-text SubString
      "int64_t idx = ((Number *)arg1)->numVal;
        int64_t len = ((Number *)arg2)->numVal;
        if (arg0->type == StringType) {
          String *s = (String *)arg0;
          SubString *subStr = malloc_substring();
          subStr->type = SubStringType;
          if (idx + len <= s->len) {
            subStr->len = len;
            subStr->source = arg0;
            incRef(arg0);
            subStr->buffer = s->buffer + idx;
          }
          else {
            subStr->len = 0;
            subStr->source = (Value *)0;
            subStr->buffer = (char *)0;
          }
          return((Value *)subStr);
        } else if (arg0->type == SubStringType) {
          SubString *s = (SubString *)arg0;
          SubString *subStr = malloc_substring();
          subStr->type = SubStringType;
          if (idx + len <= s->len) {
            subStr->len = len;
            subStr->source = arg0;
            incRef(arg0);
            subStr->buffer = s->buffer + idx;
          }
          else {
            subStr->len = 0;
            subStr->source = (Value *)0;
            subStr->buffer = (char *)0;
          }
          return((Value *)subStr);
        } else
          abort();\n")))

;; this function assumes the type of 'n' has already been checked
(defn number-str [n]
  (inline-text String
   "String *numStr = (String *)my_malloc(sizeof(String) + 10);
    snprintf(numStr->buffer, 9, \"%lld\", ((Number *)arg0)->numVal);
    numStr->type = StringType;
    numStr->len = strlen(numStr->buffer);
    return((Value *)numStr);\n"))

(defn number= [x y]
  (inline-text Number
   "if (arg0->type != arg1->type) {
      return(false);
   } else if (((Number *)arg0)->numVal != ((Number *)arg1)->numVal)
      return(false);
   else
      return(true);\n"))

;; this function assumes the type of 'x' has already been checked
(defn number-less-than [x y]
  (inline-text Number
   "if (arg0->type != arg1->type) {
      fprintf(stderr, \"\\ninvalid types for 'number-less-than'\\n\");
      abort();
   } else if (((Number *)arg0)->numVal < ((Number *)arg1)->numVal)
      return(true);
   else
      return(false);\n"))

;; this function assumes the type of 'x' has already been checked
(defn add-numbers [x y]
  (inline-text Number
   "if (arg0->type != arg1->type) {
      fprintf(stderr, \"\\ninvalid types for 'add-numbers'\\n\");
      abort();
    } else
      return(numberValue(((Number *)arg0)->numVal + ((Number *)arg1)->numVal));\n"))

;; this function assumes the type of 'x' has already been checked
(defn subtract-numbers [x y]
  (inline-text Number
   "if (arg0->type != arg1->type) {
      fprintf(stderr, \"\\ninvalid types for 'subtract-numbers'\\n\");
      abort();
    } else
      return(numberValue(((Number *)arg0)->numVal - ((Number *)arg1)->numVal));\n"))

;; this function assumes the type of 'x' has already been checked
(defn mult-numbers [x y]
  (inline-text Number
   "if (arg0->type != arg1->type) {
      fprintf(stderr, \"\\n*** invalid types for 'mult-numbers'\\n\");
      abort();
    } else
      return(numberValue(((Number *)arg0)->numVal * ((Number *)arg1)->numVal));\n"))

(defn rem [x y]
  (inline-text Number
   "if (arg0->type != NumberType ||
        arg1->type != NumberType) {
      fprintf(stderr, \"\\ninvalid types for 'rem'\\n\");
      abort();
    } else
      return(numberValue(((Number *)arg0)->numVal %
                         ((Number *)arg1)->numVal));\n"))

(def empty-list
  (inline-text List "(Value *)&(List){4,-1,0,0,0};"))

(defn cons
  ([x]
     (inline-text List
      "incRef(arg0);\nreturn((Value *)listCons(arg0, empty_list));\n"))
  ([x l]
     (inline-text List
      "incRef(arg0);\nincRef(arg1);\nreturn((Value *)listCons(arg0, (List *)arg1));\n")))

(defn list-count [l]
  (inline-text Number
   "if (arg0->type != ListType)
      abort();
    else
      return(numberValue(((List *)arg0)->len));"))

(defn list-empty? [coll]
(inline-text Number
             "
if (arg0->type != ListType)
{
  fprintf(stderr, \"*** 'list-empty?' given wrong type of value\\n\");
  abort();
}
else if (((List *)arg0)->len == 0)
  return((Value *)&trueVal);
else
  return((Value *)&falseVal);
")
)

(defn car [l]
  (inline-text
   "List *lst = (List *)arg0;
    if (arg0->type != ListType) {
      fprintf(stderr, \"\\n*** 'car' requires a list\\n\");
      abort();
    } else if (lst->len == 0) {
       fprintf(stderr, \"\\n*** Cannot get head of empty list!!\\n\");
       abort();
    } else {
       incRef(lst->head);
       return(lst->head);
    }\n"))

(defn cdr [l]
  (inline-text List
   "List *lst = (List *)arg0;
    if (arg0->type != ListType) {
      fprintf(stderr, \"\\n*** 'cdr' requires a list\\n\");
      abort();
    } else if (lst->len == 0) {
       return((Value *)empty_list);
    } else {
       List *tail = ((List *)arg0)->tail;
       tail->len = lst->len - 1;
       incRef((Value *)tail);
       return((Value *)tail);
    }\n"))

(defn fn-name [f]
  (inline-text String
   "if (arg0->type != FunctionType) {
      fprintf(stderr, \"\\n*** invalid type for 'fn-name'\\n\");
      abort();
    } else
      return(stringValue(((Function *)arg0)->name));\n"))

(defn char [n]
  (inline-text String
   "if (arg0->type != NumberType) {
      fprintf(stderr, \"\\ninvalid type for 'char'\\n\");
      abort();
    }
    String *strVal = (String *)my_malloc(sizeof(String) + 2);
    strVal->type = StringType;
    strVal->len = 1;
    strVal->buffer[0] = ((Number *)arg0)->numVal;
    strVal->buffer[1] = 0;
    return((Value *)strVal);\n"))

(defn str-count [str]
  (inline-text Number
   "if (arg0->type != StringType && arg0->type != SubStringType ) {
      fprintf(stderr, \"\\ninvalid type for 'str-count'\\n\");
      abort();
    }
   return(numberValue(((String *)arg0)->len));\n"))

(defn str= [str1 str2]
  (inline-text Number
   "if (arg0->type == StringType && arg1->type == StringType) {
      String *s1 = (String *)arg0;
      String *s2 = (String *)arg1;
      if (s1->len == s2->len && strncmp(s1->buffer,s2->buffer,s1->len) == 0)
        return(true);
      else
        return(false);
    } else if (arg0->type == SubStringType && arg1->type == SubStringType) {
      SubString *s1 = (SubString *)arg0;
      SubString *s2 = (SubString *)arg1;
      if (s1->len == s2->len && strncmp(s1->buffer,s2->buffer,s1->len) == 0)
        return(true);
      else
        return(false);
    } else if (arg0->type == StringType &&
               arg1->type == SubStringType) {
      String *s1 = (String *)arg0;
      SubString *s2 = (SubString *)arg1;
      if (s1->len == s2->len && strncmp(s1->buffer,s2->buffer,s1->len) == 0)
        return(true);
      else
        return(false);
    } else if (arg0->type == SubStringType &&
               arg1->type == StringType) {
      SubString *s1 = (SubString *)arg0;
      String *s2 = (String *)arg1;
      if (s1->len == s2->len && strncmp(s1->buffer,s2->buffer,s1->len) == 0)
        return(true);
      else
        return(false);
    } else
       return(false);\n"))

(defn symkey= [v1 v2]
  (inline-text Number
   "if (arg0->type != arg1->type)
      return(false);
    else {
      SubString *s1 = (SubString *)arg0;
      SubString *s2 = (SubString *)arg1;
      if (s1->type == s2->type &&
          s1->len == s2->len &&
          strncmp(s1->buffer, s2->buffer, s1->len) == 0) {
        return(true);
      } else
        return(false);
    }\n"))

(defn str-malloc [len]
  (inline-text String
   "String *strVal = (String *)my_malloc(sizeof(String) + ((Number *)arg0)->numVal + 5);
    strVal->type = StringType;
    strVal->len = 0;
    strVal->buffer[0] = 0;
    return((Value *)strVal);\n"))

(defn str-append [dest src]
  (inline-text String
   " if (arg0->type != StringType) {
      fprintf(stderr, \"\\ninvalid type for 'str-append'\\n\");
      abort();
    }

    String *s1 = (String *)arg0;
    if (arg1->type == StringType) {
      String *s2 = (String *)arg1;
      strncat(s1->buffer, s2->buffer, s2->len);
      s1->len += s2->len;
    } else if (arg1->type == SubStringType) {
      SubString *s2 = (SubString *)arg1;
      strncat(s1->buffer, s2->buffer, s2->len);
      s1->len += s2->len;
    }
    incRef(arg0);
    return(arg0);\n"))

(defn pr-err* [str]
  (inline-text Number
   "if (arg0->type == StringType)
      fprintf(stderr, \"%-.*s\", (int)((String *)arg0)->len, ((String *)arg0)->buffer);
    else if (arg0->type == SubStringType)
      fprintf(stderr, \"%-.*s\", (int)((SubString *)arg0)->len, ((SubString *)arg0)->buffer);
    else {
      fprintf(stderr, \"\\ninvalid type for 'pr-err*'\\n\");
      abort();
    }
    return(true);\n"))

(defn slurp [fileName]
  (inline-text String
   "String *arg0Str = (String *)my_malloc(sizeof(String) + ((String *)arg0)->len + 5);
    arg0Str->type = StringType;
    if (arg0->type == StringType)
      snprintf(arg0Str->buffer, ((String *)arg0)->len + 1, \"%s\", ((String *)arg0)->buffer);
    else if (arg0->type == SubStringType)
      snprintf(arg0Str->buffer, ((String *)arg0)->len + 1, \"%s\", ((SubString *)arg0)->buffer);
    else {
      fprintf(stderr, \"\\ninvalid type for 'slurp'\\n\");
      abort();
    }

    FILE *file = fopen(arg0Str->buffer, \"r\");
    fseek(file, 0, SEEK_END);
    int64_t buffSize = ftell(file);
    fseek(file, 0, SEEK_SET);
    String *strVal = (String *)my_malloc(sizeof(String) + buffSize + 10);
    strVal->type = StringType;
    strVal->len = buffSize;
    fread(strVal->buffer, 1, buffSize, file);
    fclose(file);
    dec_and_free((Value *)arg0Str);
    return((Value *)strVal);\n"))

(defn fn-apply [x args]
  (inline-text "List *argList = (List *)arg1;
                     FnArity *_arity = findFnArity(arg0, argList->len);

                     if (_arity == (FnArity *)0) {
                       fprintf(stderr, \"\\n*** no arity found to apply\\n\");
                       abort();
                     } else if(_arity->variadic) {
                       FnType1 *_fn = (FnType1 *)_arity->fn;
                       return(_fn(_arity->closures, arg1));
                   ")
  (inline-text "} else if (argList->len == 1) {
                       FnType1 *_fn = (FnType1 *)_arity->fn;
                       Value *appArg0 = argList->head;
                       return(_fn(_arity->closures, appArg0));
                   ")
  (inline-text "} else if (argList->len == 2) {
                       FnType2 *_fn = (FnType2 *)_arity->fn;
                       Value *appArg0 = argList->head;
                       argList = argList->tail;
                       Value *appArg1 = argList->head;
                       return(_fn(_arity->closures, appArg0, appArg1));
                   ")
  (inline-text "} else if (argList->len == 3) {
                       FnType3 *_fn = (FnType3 *)_arity->fn;
                       Value *appArg0 = argList->head;
                       argList = argList->tail;
                       Value *appArg1 = argList->head;
                       argList = argList->tail;
                       Value *appArg2 = argList->head;
                       return(_fn(_arity->closures, appArg0, appArg1, appArg2));
                   ")
  (inline-text "} else if (argList->len == 4) {
                       FnType4 *_fn = (FnType4 *)_arity->fn;
                       Value *appArg0 = argList->head;
                       argList = argList->tail;
                       Value *appArg1 = argList->head;
                       argList = argList->tail;
                       Value *appArg2 = argList->head;
                       argList = argList->tail;
                       Value *appArg3 = argList->head;
                       return(_fn(_arity->closures, appArg0, appArg1, appArg2, appArg3));
                   ")
  (inline-text "} else if (argList->len == 5) {
                       FnType5 *_fn = (FnType5 *)_arity->fn;
                       Value *appArg0 = argList->head;
                       argList = argList->tail;
                       Value *appArg1 = argList->head;
                       argList = argList->tail;
                       Value *appArg2 = argList->head;
                       argList = argList->tail;
                       Value *appArg3 = argList->head;
                       argList = argList->tail;
                       Value *appArg4 = argList->head;
                       return(_fn(_arity->closures, appArg0, appArg1, appArg2, appArg3,
                                                    appArg4));
                   ")
  (inline-text "} else if (argList->len == 6) {
                       FnType6 *_fn = (FnType6 *)_arity->fn;
                       Value *appArg0 = argList->head;
                       argList = argList->tail;
                       Value *appArg1 = argList->head;
                       argList = argList->tail;
                       Value *appArg2 = argList->head;
                       argList = argList->tail;
                       Value *appArg3 = argList->head;
                       argList = argList->tail;
                       Value *appArg4 = argList->head;
                       argList = argList->tail;
                       Value *appArg5 = argList->head;
                       return(_fn(_arity->closures, appArg0, appArg1, appArg2, appArg3,
                                                    appArg4, appArg5));
                   ")
  (inline-text "} else if (argList->len == 7) {
                       FnType7 *_fn = (FnType7 *)_arity->fn;
                       Value *appArg0 = argList->head;
                       argList = argList->tail;
                       Value *appArg1 = argList->head;
                       argList = argList->tail;
                       Value *appArg2 = argList->head;
                       argList = argList->tail;
                       Value *appArg3 = argList->head;
                       argList = argList->tail;
                       Value *appArg4 = argList->head;
                       argList = argList->tail;
                       Value *appArg5 = argList->head;
                       argList = argList->tail;
                       Value *appArg6 = argList->head;
                       return(_fn(_arity->closures, appArg0, appArg1, appArg2, appArg3,
                                                    appArg4, appArg5, appArg6));
                   ")
  (inline-text "} else if (argList->len == 8) {
                       FnType8 *_fn = (FnType8 *)_arity->fn;
                       Value *appArg0 = argList->head;
                       argList = argList->tail;
                       Value *appArg1 = argList->head;
                       argList = argList->tail;
                       Value *appArg2 = argList->head;
                       argList = argList->tail;
                       Value *appArg3 = argList->head;
                       argList = argList->tail;
                       Value *appArg4 = argList->head;
                       argList = argList->tail;
                       Value *appArg5 = argList->head;
                       argList = argList->tail;
                       Value *appArg6 = argList->head;
                       argList = argList->tail;
                       Value *appArg7 = argList->head;
                       return(_fn(_arity->closures, appArg0, appArg1, appArg2, appArg3,
                                                    appArg4, appArg5, appArg6, appArg7));
                   ")
  (inline-text "} else if (argList->len == 9) {
                       FnType9 *_fn = (FnType9 *)_arity->fn;
                       Value *appArg0 = argList->head;
                       argList = argList->tail;
                       Value *appArg1 = argList->head;
                       argList = argList->tail;
                       Value *appArg2 = argList->head;
                       argList = argList->tail;
                       Value *appArg3 = argList->head;
                       argList = argList->tail;
                       Value *appArg4 = argList->head;
                       argList = argList->tail;
                       Value *appArg5 = argList->head;
                       argList = argList->tail;
                       Value *appArg6 = argList->head;
                       argList = argList->tail;
                       Value *appArg7 = argList->head;
                       argList = argList->tail;
                       Value *appArg8 = argList->head;
                       return(_fn(_arity->closures, appArg0, appArg1, appArg2, appArg3,
                                                    appArg4, appArg5, appArg6, appArg7,
                                                    appArg8));
                     } else {
                       fprintf(outStream, \"error in 'fn-apply'\\n\");
                       abort();
                     }
                   "))

(defn escape-chars [c]
  ;; does not allocate a Value
  (inline-text String
   "if (arg0->type == StringType) {
        String *s = (String *)arg0;
        String *result = (String *)my_malloc(sizeof(String) + s->len * 2 + 5);
        char *resultBuffer = result->buffer;
        int resultIndex = 0;
        for(int i = 0; i < s->len; i++) {
          if (s->buffer[i] == 10) {
            resultBuffer[resultIndex++] = 92;
            resultBuffer[resultIndex++] = 110;
          } else if (s->buffer[i] == 34) {
            resultBuffer[resultIndex++] = 92;
            resultBuffer[resultIndex++] = 34;
          } else if (s->buffer[i] == 13) {
            resultBuffer[resultIndex++] = 92;
            resultBuffer[resultIndex++] = 114;
          } else if (s->buffer[i] == 12) {
            resultBuffer[resultIndex++] = 92;
            resultBuffer[resultIndex++] = 102;
          } else if (s->buffer[i] == 8) {
            resultBuffer[resultIndex++] = 92;
            resultBuffer[resultIndex++] = 98;
          } else if (s->buffer[i] == 9) {
            resultBuffer[resultIndex++] = 92;
            resultBuffer[resultIndex++] = 116;
          } else if (s->buffer[i] == 92) {
            resultBuffer[resultIndex++] = 92;
            resultBuffer[resultIndex++] = 92;
          } else
            resultBuffer[resultIndex++] = s->buffer[i];
        }
        resultBuffer[resultIndex] = 0;
        result->type = StringType;
        result->len = resultIndex;
        return((Value *)result);
      } else if (arg0->type == SubStringType) {
        SubString *s = (SubString *)arg0;
        String *result = (String *)my_malloc(sizeof(String) + s->len * 2 + 5);
        char *resultBuffer = result->buffer;
        int resultIndex = 0;
        for(int i = 0; i < s->len; i++) {
          if (s->buffer[i] == 10) {
            resultBuffer[resultIndex++] = 92;
            resultBuffer[resultIndex++] = 110;
          } else if (s->buffer[i] == 34) {
            resultBuffer[resultIndex++] = 92;
            resultBuffer[resultIndex++] = 34;
          } else if (s->buffer[i] == 13) {
            resultBuffer[resultIndex++] = 92;
            resultBuffer[resultIndex++] = 114;
          } else if (s->buffer[i] == 12) {
            resultBuffer[resultIndex++] = 92;
            resultBuffer[resultIndex++] = 102;
          } else if (s->buffer[i] == 8) {
            resultBuffer[resultIndex++] = 92;
            resultBuffer[resultIndex++] = 98;
          } else if (s->buffer[i] == 9) {
            resultBuffer[resultIndex++] = 92;
            resultBuffer[resultIndex++] = 116;
          } else if (s->buffer[i] == 92) {
            resultBuffer[resultIndex++] = 92;
            resultBuffer[resultIndex++] = 92;
          } else
            resultBuffer[resultIndex++] = s->buffer[i];
        }
        resultBuffer[resultIndex] = 0;
        result->type = StringType;
        result->len = resultIndex;
        return((Value *)result);
      } else
        abort();\n "))

(defn pr* [str]
  (inline-text Number
   "if (arg0->type == StringType)
      fprintf(outStream, \"%-.*s\", (int)((String *)arg0)->len, ((String *)arg0)->buffer);
    else if (arg0->type == SubStringType)
      fprintf(outStream, \"%-.*s\", (int)((SubString *)arg0)->len, ((SubString *)arg0)->buffer);
    else {
      fprintf(outStream, \"\\ninvalid type for 'pr*'\\n\");
      abort();
    }
    return(true);\n"))

;; @jneen_
(defprotocol Variant ;; is CoProduct or Tagged Union
  (bippity [_])
  (match* [_]
    (pr* ":match*-one-arg"))
  (match* [_ match-targets]
    (pr* ":match*-two-args")))

(defn alert [flag msg]
  (cond
   flag true
   (let [_ (print-err msg)]
     (abort))))

(defprotocol Type
  (instance? [type val]
    (cond
     (number= Number (get-type type)) (number= type (get-type val))
     (let [_ (pr* "*** call to 'instance?' with unknown type parameter.")]
       (abort)))))

(defprotocol Monad
  (flat-map [mval func]
    (print-err "'flat-map' not implemented: " (type-name mval))
    (abort))
  (flatten [mval]
    (flat-map mval (fn [x] x))))

(defprotocol Comonad
  (extract [wv])
  (extend [wv f])
  (duplicate [wv]
    (print-err "'duplicate' not implemented: " (type-name wv))))

(def comprehend)

(defprotocol Applicative
  (wrap [x v]
    (print-err "*** 'wrap' not implemented"))
  (apply* [fv args]
    (cond
     (list-empty? args) (flat-map fv (fn [f] (wrap fv (f))))
     (flat-map fv (fn [f] (comprehend f args))))))

(defn list [& l]
  l)

(defprotocol Functor
  (map [v f]
    (flat-map v (fn [x] (wrap v (f x))))))

(defprotocol Named
  (name [value]
    (print-err "'name' not implemented for type " (type-name value))
    (abort)))

(defprotocol Stringable
  (string-list [value]
    (print-err "'string-list' not implemented for type" (type-name value))
    (abort)))

(defprotocol Serializable
  (serialize [value]
    (print-err "'serialize' not implemented for type" (type-name value))
    (abort)))

(defprotocol Eq
  (=* [x y]
    (cond
     (type= x y)
     (=* (type-args x) (type-args y))

     0)))

(defprotocol Ord
  (<* [value values]
    (print-err "'<*' not implemented:" value)
    (abort)))

(defprotocol Collection
  (empty? [coll])
  (empty [coll])
  (destruct [coll target])
  (count [coll])
  (conj [coll value])
  (reduce [l result f]))

(defn not-empty? [coll]
  (cond
   (empty? coll) false
   true))

(defprotocol Seqable
  (seq? [coll] false)
  (seq [coll])
  (first [coll])
  (m-first [coll])
  (rest [coll]))

(defn second [coll]
  (first (rest coll)))

(defprotocol Traversable
  (traverse [coll f]))

(defprotocol Crushable
  (crush [coll f]))

(defprotocol Monoid
  (zero [_])
  (comp* [mval mvals]))

(defn apply [fv & args]
  (apply* fv args))

(defn apply-to
  ([f]
     (f))
  ([f & args]
     (apply* (wrap (car args) f) args)))

(defn comp [coll & colls]
  (cond
   (list-empty? colls) coll
   (comp* coll colls)))

(defprotocol HashMapNode
  (hash-seq [n s])
  (get* [n k v hash shift])
  (assoc* [n k v hash shift]))

(defprotocol Associative
  (assoc [m k v])
  (get [m k not-found]
    (print-err "'get' not implemented for" (type-name m) ": " :m m :k k)
    (abort))
  (keys [m])
  (vals [m])
  (dissoc [m k]))

(defprotocol Hash
  (sha1 [_]))

(defn not [b-val]
  (cond
   b-val 0
   1))

(defn and [& b-vals]
  (cond
   (list-empty? b-vals) 1
   (car b-vals) (apply and (cdr b-vals))
   0))

(defn or [& b-vals]
  (cond
   (list-empty? b-vals) 0
   (car b-vals) 1
   (apply or (cdr b-vals))))

(defn =
  ([v] 1)
  ([x y] (=* x y))
  ([v & vs]
     (cond
      (=* v (car vs)) (apply = vs)
      0)))

(defn partial [f & args]
  (fn [& more-args]
    (apply f (comp args more-args))))

(def maybe-val)

(def nothing
  (reify
    Stringable
    (string-list [_] (list "<nothing>"))

    Eq
    (=* [nv x] (type= nv x))

    Monoid
    (zero [nv] nv)
    (comp* [nv mvs]
      (cond
       (list-empty? mvs) nv
       (comp* (first mvs) (rest mvs))))

    Functor
    (map [nv f] nv)

    Applicative
    (wrap [_ x] (maybe-val x))
    (apply* [nv _] nv)

    Monad
    (flatten [nv] nv)
    (flat-map [nv _] nv)))

(defn any? [pred coll]
  (cond
   (empty? coll) 0
   (pred (first coll)) 1
   (any? pred (rest coll))))

(deftype maybe-val [v]
  Stringable
  (string-list [mv]
    (comp (list "<maybe ")
          (string-list (.v mv))
          (list ">")))

  Monoid
  (zero [_] nothing)
  (comp* [mv _] mv)

  Functor
  (map [_ f]
    (maybe-val (f v)))

  Applicative
  (wrap [_ v] (maybe-val v))
  (apply* [fv args]
    (cond
     (any? args (partial = nothing)) nothing
     (maybe-val (apply (.v fv) (map args .v)))))

  Monad
  (flatten [_] v)
  (flat-map [_ f]
    (f v)))

(def maybe
  (reify
    Function
    (invoke [_ v] (maybe-val v))

    Type
    (instance? [_ mv] (instance? maybe-val mv))

    Monoid
    (zero [_] nothing)
    ))

(defn m=
  ([v] (maybe v))
  ([x y]
     (cond
      (=* x y) (maybe x)
      nothing))
  ([v & vs]
     (cond
      (=* v (car vs)) (apply m= vs)
      nothing)))

(defn some [coll f]
  (cond
   (empty? coll) nothing
   (f (first coll)) (maybe (first coll))
   (some (rest coll) f)))

(defn <
  ([x y] (<* x y))
  ([v & vs]
     (cond
      (list-empty? vs) 1
      (not (<* v (car vs))) 0
      (number= 1 (list-count vs)) 1
      (apply < vs))))

(defn list** [arg args]
  (cond
   (list-empty? args) arg
   (cons arg (list** (car args) (cdr args)))))

(defn list* [arg & args]
  (list** arg args))

(defn filter [l f]
  (inline-text List
     "List *l = (List *)arg0;
      if (arg0->type != ListType) {
         fprintf(stderr, \"'filter' is only defined for 'List' values\\n\");
         abort();
      }

      if (l->len == 0)
        return((Value *)empty_list);
      else {
        List *head = empty_list;
        List *tail = empty_list;
        for(Value *x = l->head; x != (Value *)0; l = l->tail, x = l->head) {
          Value *y;
          if(arg1->type != 3) {
            y = protoFnImpl_11(empty_list, arg1, x);
          } else {
            FnArity *arity2 = findFnArity(arg1, 1);
            if(arity2 != (FnArity *)0 && !arity2->variadic) {
              FnType1 *fn4 = (FnType1 *)arity2->fn;
              y = fn4(arity2->closures, x);
            } else if(arity2 != (FnArity *)0 && arity2->variadic) {
              FnType1 *fn4 = (FnType1 *)arity2->fn;
              List *varArgs3 = empty_list;
              incRef(x);
              varArgs3 = (List *)listCons(x, varArgs3);
              y = fn4(arity2->closures, (Value *)varArgs3);
              incRef(y);
              dec_and_free((Value *)varArgs3);
              decRef(y);
            } else {
              fprintf(stderr, \"\\n*** no arity found for '%s'.\\n\", ((Function *)arg1)->name);
              abort();
            }
          }

          // 'y' is the filter boolean value

          if (isTrue(y)) {
            if (head == empty_list) {
              // if we haven't started the new list yet
              head = malloc_list();
              head->type = ListType;
              head->len = 1;
              head->head = x;
              incRef(x);
              head->tail = empty_list;
              tail = head;
            } else {
              // otherwise, append to tail of list
              List *new_tail = malloc_list();
              new_tail->type = ListType;
              new_tail->len = 1;
              new_tail->head = x;
              incRef(x);
              new_tail->tail = empty_list;
              tail->tail = new_tail;
              tail = new_tail;
              head->len++;
            }
          }
        }
        return((Value *)head);
      }\n"))

(defn remove [l f]
  (filter l (fn [v] (not (f v)))))

(defn reverse [l]
  (reduce l (empty l) conj))

(defn identity [x]
  x)

(extend-type Function
  Stringable
  (string-list [f] (list "<Fn: " (fn-name f) ">"))

  Monoid
  (zero [_] identity)
  (comp* [f fs]
    (fn [& args]
      (reduce fs (apply f args)
              (fn [x f]
                (f x)))))

  Applicative
  (apply* [f args]
    (cond
     (list-empty? args) (f)
     ;; Remember, the last element of 'args' must be a list
     ;; everything up to that must be prepended to it
     (fn-apply f (list** (first args) (rest args))))))

(extend-type Number
  Eq
  (=* [x y]
    (number= x y))

  Ord
  (<* [x y] (number-less-than x y))

  Stringable
  (string-list [v] (list (number-str v)))

  Hash
  (sha1 [_]
    (inline-text Number
     "
int64_t shaVal;
Sha1Context context;
Number *numVal = (Number *)arg0;

Sha1Initialise(&context);
Sha1Update(&context, (void *)&numVal->type, 8);
Sha1Update(&context, (void *)&numVal->numVal, 8);
Sha1Finalise(&context, (SHA1_HASH *)&shaVal);
return((Value *)numberValue(shaVal));
")))

;; (deftype ZipList [v]
;;   Applicative
;;   (apply* [zv arg-lists]
;;     (cond
;;      (any? empty? arg-lists) empty-list
;;      (let [cars (map arg-lists (fn [l] (cond
;;                                         (empty? l) :nil
;;                                         (first l))))
;;            cdrs (map arg-lists rest)]
;;        (cons (apply v cars)
;;              (apply* zv cdrs))))))

(defn comprehend
  ([f]
     (f))
  ([f [mv & mvs]]
     (let [rest-steps (reduce (reverse mvs)
                              (fn [acc x]
                                (wrap mv (apply f (reverse (cons x acc)))))
                              (fn [steps new-mv]
                                (fn [acc x]
                                  (flat-map new-mv (partial steps (cons x acc))))))]
       (cond
        (number= 1 (list-count mvs)) (flat-map mv (fn [x]
                                                    (wrap mv (f x))))
        (flat-map mv (partial rest-steps empty-list))))))

(defn list-concat [l1]
  (inline-text List
   " List *ls = (List *)arg0;

  if (ls->len == 0) {
    return((Value *)empty_list);
  }
  else if (ls->len == 1) {
    incRef(ls->head);
    return(ls->head);
  }
  else {
    List *head = empty_list;
    List *tail = empty_list;
    for (; ls != (List *)0; ls = ls->tail) {
      List *l = (List *)ls->head;
      Value *x;
      for(; l != (List *)0 && l->head != (Value *)0; l = l->tail) {
        x = l->head;
        if (head == empty_list) {
          // if we haven't started the new list yet
          head = malloc_list();
          head->type = ListType;
          head->len = 1;
          head->head = x;
          incRef(x);
          head->tail = empty_list;
          tail = head;
        } else {
          // otherwise, append to tail of list
          List *new_tail = malloc_list();
          new_tail->type = ListType;
          new_tail->len = 1;
          new_tail->head = x;
          incRef(x);
          new_tail->tail = empty_list;
          tail->tail = new_tail;
          tail = new_tail;
          head->len++;
        }
      }
    }
    return((Value *)head);
    }\n"))

(defn list=* [ls]
  (cond
   (list-empty? ls) 1
   (list-empty? (car ls)) 1
   (not (apply = (map ls (fn [l] (car l))))) 0
   (list=* (map ls rest))))

(extend-type List
  Getter
  (type-args [l] l)

  Seqable
  (seq? [l]
    true)
  (seq [l] l)
  (m-first [l] (cond
              (list-empty? l) nothing
              (maybe (car l))))
  (first [l] (car l))
  (rest [l] (cdr l))

  Collection
  (empty? [coll]
    (list-empty? coll))
  (empty [coll] empty-list)
  (conj [l v] (cons v l))
  (count [l] (list-count l))
  (reduce [l result f]
    (cond
     (list-empty? l) result
     (let [head (car l)
           tail (cdr l)
           mapped-val (f result head)]
       (cond
        (list-empty? tail) mapped-val
        (reduce tail mapped-val f)))))

  Crushable
  (crush [l f]
    (reduce (cdr l) (f (car l))
            (fn [x y] (comp x (f y)))))

  Traversable
  (traverse [l f]
    (let [vs (map l f)]
      (apply* (wrap (car vs) list) vs)))

  Eq
  (=* [x y]
    (cond
     (not (number= (get-type x) (get-type y))) 0
     (not (number= (count x) (count y))) 0
     (list=* (list x y))))

  Monoid
  (zero [_] empty-list)
  (comp* [l ls]
    (list-concat (cons l ls)))

  Functor
  (map [l f]
    (inline-text List
     "List *l = (List *)arg0;
      if (l->len == 0)
        return((Value *)empty_list);
      else {
        List *head = empty_list;
        List *tail = empty_list;
        for(Value *x = l->head; x != (Value *)0; l = l->tail, x = l->head) {
          Value *y;
          if(arg1->type != 3) {
            y = protoFnImpl_11(empty_list, arg1, x);
          } else {
            FnArity *arity2 = findFnArity(arg1, 1);
            if(arity2 != (FnArity *)0 && !arity2->variadic) {
              FnType1 *fn4 = (FnType1 *)arity2->fn;
              y = fn4(arity2->closures, x);
            } else if(arity2 != (FnArity *)0 && arity2->variadic) {
              FnType1 *fn4 = (FnType1 *)arity2->fn;
              incRef(x);
              List *varArgs3 = (List *)listCons(x, empty_list);
              y = fn4(arity2->closures, (Value *)varArgs3);
              dec_and_free((Value *)varArgs3);
            } else {
              fprintf(stderr, \"\\n*** no arity found for '%s'.\\n\", ((Function *)arg1)->name);
              abort();
            }
          }

          // 'y' is the value for the new list

          if (head == empty_list) {
            // if we haven't started the new list yet
            head = malloc_list();
            head->type = ListType;
            head->len = 1;
            head->head = y;
            head->tail = empty_list;
            tail = head;
          } else {
            // otherwise, append to tail of list
            List *new_tail = malloc_list();
            new_tail->type = ListType;
            new_tail->len = 1;
            new_tail->head = y;
            new_tail->tail = empty_list;
            tail->tail = new_tail;
            tail = new_tail;
            head->len++;
          }
        }
        return((Value *)head);
      }\n"))

  Applicative
  (wrap [x v] (list v))

  Monad
  (flat-map [mv mf]
    (let [l (map mv mf)]
      (cond
       (list-empty? l) empty-list
       (comp* (car l) (cdr l))))))

(defn interpose [coll sep]
  (cond
   (list-empty? coll) empty-list
   (cons (car coll)
         (flat-map (cdr coll)
                   (fn [x]
                     (list sep x))))))

(extend-type List
  Stringable
  (string-list [l]
    (list-concat (list (list "(")
                       (flat-map (interpose l ", ") string-list)
                       (list ")")))))

(defn prn [& vs]
  (map (interpose (flat-map vs serialize) " ")
       pr*)
  (pr* "\n"))

(defn print [& vs]
  (map (flat-map (interpose vs " ") string-list)
       pr*))

(defn println [& vs]
  (map (flat-map (interpose vs " ") string-list) pr*)
  (pr* "\n"))

(defn print-err [& vs]
  (pr-err* "\n*** ")
  (map (flat-map (interpose vs " ") string-list) pr-err*)
  (pr-err* "\n"))

(defn inc [x]
  (add-numbers x 1))

(defn + [& xs]
  (cond
   (list-empty? xs) 0
   (reduce xs 0 add-numbers)))

(defn * [& xs]
  (cond
   (list-empty? xs) 1
   (reduce xs 1 mult-numbers)))

(defn dec [x]
  (subtract-numbers x 1))

(defn -
  ([]
     0)
  ([x & xs]
     (cond
      (list-empty? xs) x
      (reduce xs x subtract-numbers))))

(extend-type String
  Eq
  (=* [x y] (str= x y))

  Collection
  (empty? [s]
    (= 0 (str-count s)))
  (empty [s]
    "")
  (count [s]
    (str-count s))
  (conj [s value]
    (let [strs (flat-map (list s value) string-list)]
      (comp* (car strs) (cdr strs))))
  (reduce [s result f]
    (reduce (seq s) result f))

  Seqable
  (seq [s]
    (cond
     (= s "") empty-list
     (cons (subs s 0 1) (seq (subs s 1)))))
  (m-first [s]
    (cond
     (= s "") nothing
     (maybe (subs s 0 1))))
  (first [s]
    (cond
     (= s "") nothing
     (maybe (subs s 0 1))))
  (rest [s]
    (subs s 1))

  Stringable
  (string-list [v] (list v))

  Monoid
  (comp* [s ss]
    (cond
     (list-empty? ss) s
     (let [ss-list (flat-map (cons s ss) string-list)
           new-len (reduce ss-list 0
                           (fn [len s]
                             (add-numbers len (str-count s))))
           new-str (str-malloc new-len)]
       (map ss-list (fn [s]
                      (str-append new-str s)
                      0))
       new-str)))

  Hash
  (sha1 [_]
    (inline-text Number
     "
int64_t shaVal;
Sha1Context context;
String *strVal = (String *)arg0;

Sha1Initialise(&context);
Sha1Update(&context, (void *)strVal->buffer, strVal->len);
Sha1Finalise(&context, (SHA1_HASH *)&shaVal);
return((Value *)numberValue(shaVal));
")))

(extend-type SubStr
  Stringable
  (string-list [v] (list v))

  Eq
  (=* [x y] (str= x y))

  Collection
  (empty? [s]
    (= 0 (str-count s)))
  (empty [s]
    "")
  (count [s]
    (str-count s))
  (conj [s value]
    (let [strs (flat-map (list s value) string-list)]
      (comp* (car strs) (cdr strs))))
  (reduce [s result f]
    (reduce (seq s) result f))

  Seqable
  (seq [s]
    (cond
     (= s "") empty-list
     (cons (subs s 0 1) (seq (subs s 1)))))
  (m-first [s]
    (cond
     (= s "") nothing
     (maybe (subs s 0 1))))
  (first [s]
    (cond
     (= s "") nothing
     (maybe (subs s 0 1))))
  (rest [s]
    (subs s 1))

  Monoid
  (comp* [s ss]
    (cond
     (list-empty? ss) s
     (let [ss-list (flat-map (cons s ss) string-list)
           new-len (reduce ss-list 0
                           (fn [len s]
                             (add-numbers len (str-count s))))
           new-str (str-malloc new-len)]
       (map ss-list (fn [s]
                      (str-append new-str s)
                      0))
       new-str)))

  Hash
  (sha1 [_]
    (inline-text Number
     "
int64_t shaVal;
Sha1Context context;
SubString *subStrVal = (SubString *)arg0;

Sha1Initialise(&context);
Sha1Update(&context, (void *)subStrVal->buffer, subStrVal->len);
Sha1Finalise(&context, (SHA1_HASH *)&shaVal);
return((Value *)numberValue(shaVal));
")))

(defn str [& vs]
  (cond
   (list-empty? vs) ""
   (let [ss-list (flat-map vs string-list)
         new-len (reduce ss-list 0
                         (fn [len s]
                           (add-numbers len (str-count s))))
         new-str (str-malloc new-len)]
     (map ss-list (fn [s]
                    (str-append new-str s)
                    0))
     new-str)))

(defn take [l n]
  (cond
   (empty? l) l
   (= 0 n) empty-list
   (let [[head & tail] l]
     (cons head (take tail (dec n))))))

(defn drop [coll n]
  (cond
   (< n 1) coll
   (drop (rest coll) (dec n))))

(defn split
  ([l n prefix]
     (cond
      (or (empty? l) (< n 1)) (list (reverse prefix) l)
      (split (rest l) (dec n) (cons (first l) prefix))))
  ([l n]
     (split l n empty-list)))

(defn replace-at-nth [l n v]
  (cond
   (empty? l) l
   (< (dec (count l)) n) l
   (let [[prefix suffix] (split l n)]
     (comp prefix
           (list v)
           (rest suffix)))))

(defn remove-nth [l n]
  (cond
   (empty? l) l
   (< (dec (count l)) n) l
   (let [[prefix suffix] (split l n)]
     (comp prefix
           (rest suffix)))))

(defn partition [coll n]
  (cond
   (< (count coll) n) empty-list
   (cons (take coll n)
         (partition (drop coll n) n))))

(defn partition-all [coll n]
  (cond
   (< (count coll) n) (list coll)
   (cons (take coll n)
         (partition-all (drop coll n) n))))

(defn nth
  ([coll n]
     (cond
      (empty? coll) (let [_ (print-err "'nth' from empty seq")]
                      (abort))
      (= n 0) (first (seq coll))
      (nth (rest (seq coll)) (dec n))))
  ([coll n not-found]
     (cond
      (empty? coll) not-found
      (= n 0) (first (seq coll))
      (nth (rest (seq coll)) (dec n) not-found))))

(defn last [coll last-val]
  (nth coll (dec (count coll))))

(defn butlast [coll]
  (cond
   (empty? coll) coll
   (car (split coll (dec (count coll))))))

(inline-text "
BitmapIndexedNode emptyBMI = {BitmapIndexedType, -1, 0, 0};

BitmapIndexedNode *clone_BitmapIndexedNode(BitmapIndexedNode *node, int idx,
                                           Value *key, Value* val)
{
  int itemCount = __builtin_popcount(node->bitmap);
  BitmapIndexedNode *newNode = malloc_bmiNode(itemCount);
  newNode->type = BitmapIndexedType;
  newNode->refs = 1;
  newNode->bitmap = node->bitmap;
  for (int i = 0; i < itemCount; i++) {
    if (i == idx) {
      newNode->array[i * 2] = key;
      newNode->array[i * 2 + 1] = val;
    } else {
      if (node->array[i * 2] != (Value *)0)
        incRef(node->array[i * 2]);
      if (node->array[i * 2 + 1] != (Value *)0)
        incRef(node->array[i * 2 + 1]);
      newNode->array[i * 2] = node->array[i * 2];
      newNode->array[i * 2 + 1] = node->array[i * 2 + 1];
    }
  }
  return(newNode);
}

Value *createNode(int shift,
                  int64_t key1hash, Value *key1, Value *val1,
                  int64_t key2hash, Value *key2, Value *val2)
{
  if (shift > 60) {
    fprintf(stderr, \"Ran out of shift!!!!!!\");
    abort();
  }
  BitmapIndexedNode *newNode = malloc_bmiNode(2);
  newNode->type = BitmapIndexedType;
  newNode->refs = 1;
  int key1bit = bitpos(key1hash, shift);
  int key2bit = bitpos(key2hash, shift);
  newNode->bitmap = key1bit | key2bit;
  int key1idx = __builtin_popcount(newNode->bitmap & (key1bit - 1));
  int key2idx = __builtin_popcount(newNode->bitmap & (key2bit - 1));
  if (key1bit == key2bit) {
    newNode->array[0] = (Value *)0;
    newNode->array [1] = createNode(shift + 5, key1hash, key1, val1,
                                               key2hash, key2, val2);
  } else {
    incRef(key1);
    incRef(val1);
    incRef(key2);
    incRef(val2);
    newNode->array[key1idx * 2] = key1;
    newNode->array[key1idx * 2 + 1] = val1;
    newNode->array[key2idx * 2] = key2;
    newNode->array[key2idx * 2 + 1] = val2;
  }
  return((Value *)newNode);
}
")

(def emptyBMI
  (inline-text "(Value *)&emptyBMI"))

(extend-type BitmapIndexedNode
  Collection
  (count [x]
    (inline-text Number
     "
int cnt = __builtin_popcount(((BitmapIndexedNode *)arg0)->bitmap);
int accum = 0;
for(int i = 0; i < cnt; i++) {
  if (((BitmapIndexedNode *)arg0)->array[i * 2] == (Value *)0) {
    Number *subCnt = (Number *)count(((BitmapIndexedNode *)arg0)->array[i * 2 + 1]);
    accum += subCnt->numVal;
    dec_and_free((Value *)subCnt);
  } else {
    accum++;
  }
}
return(numberValue(accum));
"))
  (empty? [m]
    (inline-text Number
     "
if (((BitmapIndexedNode *)arg0)->bitmap == 0)
   return(true);
else
   return(false);
"))

  Monoid
  (zero [_] emptyBMI)
  (comp* [mval mvals]
    (reduce mvals
            mval
            (fn [acc mval]
              (reduce (seq mval)
                      acc
                      (fn [acc pair]
                        (apply assoc acc pair))))))

  Seqable
  (seq [n]
    (hash-seq n empty-list))

  Stringable
  (string-list [n]
    (let [a-list (seq n)]
      (cond
       (list-empty? a-list) (list "{}")
       (let [kv-strs (map a-list
                          (fn [kv]
                            (let [strs (interpose (map kv string-list)
                                                  (list " "))]
                              (comp* (car strs) (cdr strs)))))
             body-list (let [strs (interpose kv-strs (list ", "))]
                         (comp* (car strs) (cdr strs)))]
         (comp (list "{")
               body-list
               (list "}"))))))

  HashMapNode
  (hash-seq [n s]
    (inline-text List
     "
BitmapIndexedNode *node = (BitmapIndexedNode *)arg0;
int cnt = __builtin_popcount(node->bitmap);
List *seq = (List *)arg1;
for (int i = 0; i < cnt; i++) {
   if (node->array[2 * i] == (Value *)0) {
     seq = (List *)hashSeq(node->array[2 * i + 1], (Value *)seq);
   } else {
     List *pair = listCons(node->array[2 * i], listCons(node->array[2 * i + 1], empty_list));
     incRef(node->array[2 * i]);
     incRef(node->array[2 * i + 1]);
     seq = listCons((Value *)pair, seq);
   }
}
return((Value *)seq);
"))
  (assoc* [node k v hash shift]
    (inline-text "
BitmapIndexedNode *node = (BitmapIndexedNode *)arg0;
Value *key = arg1;
Value *val = arg2;
int64_t hash = ((Number *)arg3)->numVal;
int shift = (int)((Number *)arg4)->numVal;

int bit = bitpos(hash, shift);
int idx = __builtin_popcount(node->bitmap & (bit - 1));
if (node->bitmap & bit) {
  // if the hash position is already filled
  Value *keyOrNull = node->array[2 * idx];
  Value *valOrNode = node->array[2 * idx + 1];
  if (keyOrNull == (Value *)0) {
    // There is no key in the position, so valOrNode is
    // pointer to a node.
    Value *newShift = (Value *)numberValue(shift + 5);
    Value *n = assoc(valOrNode, key, val, arg3, newShift);
    dec_and_free(newShift);
    if (n == valOrNode) {
      // the key was already associated with the value
      // so do nothing
      dec_and_free(n);
      incRef(arg0);
      return(arg0);
    } else {
      // clone node and add n to it
      BitmapIndexedNode *newNode = clone_BitmapIndexedNode(node, idx, (Value *)0, n);
      return((Value *)newNode);
    }
  } else if (equal(key, keyOrNull)) {
    // if the keyOrNull points to a value that is equal to key
    // create new hash-map with valOrNode replaced by val
    // clone node and add val to it
    BitmapIndexedNode *newNode = clone_BitmapIndexedNode(node, idx, key, val);
    incRef((Value *)key);
    incRef((Value *)val);
    return((Value *)newNode);
  } else {
    // there is already a key/val pair at the position where key
    // would be placed. Extend tree a level
    Value *hashValue = sha1(keyOrNull);
    int64_t existingKeyHash = ((Number *)hashValue)->numVal;
    if (existingKeyHash == hash) {
      // make & return HashCollisionNode
      HashCollisionNode *newLeaf = malloc_hashCollisionNode(2);
      newLeaf->array[0] = keyOrNull;
      newLeaf->array[1] = valOrNode;
      newLeaf->array[2] = key;
      newLeaf->array[3] = val;
      incRef((Value *)keyOrNull);
      incRef((Value *)valOrNode);
      incRef((Value *)key);
      incRef((Value *)val);

      BitmapIndexedNode *newNode = clone_BitmapIndexedNode(node, idx, (Value *)0, (Value *)newLeaf);
      dec_and_free(hashValue);
      return((Value *)newNode);
    } else {
      Value *newLeaf = createNode(shift + 5,
                                  existingKeyHash, keyOrNull, valOrNode,
                                  hash, key, val);
      BitmapIndexedNode *newNode = clone_BitmapIndexedNode(node, idx, (Value *)0, newLeaf);
      dec_and_free(hashValue);
      return((Value *)newNode);
    }
  }
} else {
  // the position in the node is empty
  int n = __builtin_popcount(node->bitmap);
  if (n >= 16) {
    ArrayNode *newNode = (ArrayNode *)malloc_arrayNode();
    int jdx = mask(hash, shift);
    Value *newShift = (Value *)numberValue(shift + 5);
    newNode->array[jdx] = assoc((Value *)&emptyBMI, key, val, arg3, newShift);
    for (int i = 0, j = 0; i < 32; i++) {
      if ((node->bitmap >> i) & 1) {
        if (node->array[j] == (Value *)0) {
          newNode->array[i] = node->array[j + 1];
          incRef(newNode->array[i]);
        } else {
          Value *hash = sha1(node->array[j]);
          newNode->array[i] = assoc((Value *)&emptyBMI, node->array[j], node->array[j + 1], hash, newShift);
          dec_and_free(hash);
        }
        j += 2;
      }
    }
    dec_and_free(newShift);
    return((Value *)newNode);
  } else {
    int itemCount = n + 1;
    BitmapIndexedNode *newNode = malloc_bmiNode(itemCount);
    newNode->bitmap = node->bitmap | bit;
    incRef(key);
    incRef(val);
    for (int i = 0; i < idx * 2; i++) {
      if (node->array[i] != (Value *)0)
        incRef(node->array[i]);
      newNode->array[i] = node->array[i];
    }
    newNode->array[2 * idx] = key;
    newNode->array[2 * idx + 1] = val;
    for (int i = idx * 2; i < n * 2; i++) {
      if (node->array[i] != (Value *)0)
        incRef(node->array[i]);
      newNode->array[i + 2] = node->array[i];
    }
    return((Value *)newNode);
  }
}
"))
  (get* [node k v hash shift]
    (inline-text "
BitmapIndexedNode *node = (BitmapIndexedNode *)arg0;
Value *key = arg1;
int64_t hash = ((Number *)arg3)->numVal;
int shift = (int)((Number *)arg4)->numVal;

int bit = bitpos(hash, shift);
int idx = __builtin_popcount(node->bitmap & (bit - 1));
if (node->bitmap & bit) {
  // if the hash position is already filled
  Value *keyOrNull = node->array[2 * idx];
  Value *valOrNode = node->array[2 * idx + 1];
  if (keyOrNull == (Value *)0) {
    // There is no key in the position, so valOrNode is
    // pointer to a node.
    Value *newShift = (Value *)numberValue(shift + 5);
    Value *v = get(valOrNode, key, arg2, arg3, newShift);
    dec_and_free(newShift);
    return(v);
  } else {
    if (equal(key, keyOrNull)) {
      // fprintf(stderr, \"Found at: %d\\n\", idx);
      incRef(valOrNode);
      return(valOrNode);
    } else {
      incRef(arg2);
      return(arg2);
    }
  }
} else {
  incRef(arg2);
  return(arg2);
}
"))

  Associative
  (get [m k not-found]
    (inline-text "
Value *hash = sha1(arg1);
Value *shift = numberValue(0);
Value *found = get(arg0, arg1, arg2, hash, shift);
dec_and_free(shift);
dec_and_free(hash);
return(found);
"))
  (keys [m]
    (map (seq m) first))
  (vals [m]
    (map (seq m) second))
  (assoc [_ k v]
    (inline-text "
Value *hash = sha1(arg1);
Value *shift = numberValue(0);
Value *newNode = assoc(arg0, arg1, arg2, hash, shift);
dec_and_free(shift);
dec_and_free(hash);
return(newNode);
")))

(extend-type ArrayNode
  Collection
  (count [x]
    (inline-text Number "
int accum = 0;
for(int i = 0; i < 32; i++){
  if (((ArrayNode *)arg0)->array[i] != (Value *)0) {
    Number *subCnt = (Number *)count(((ArrayNode *)arg0)->array[i]);
    accum += subCnt->numVal;
    dec_and_free((Value *)subCnt);
  }
}
return(numberValue(accum));
"))
  (empty? [m]
    ;; TODO: make sure this holds when 'dissoc' is implemented
    false)

  Monoid
  (zero [_] emptyBMI)
  (comp* [mval mvals]
    (reduce mvals
            mval
            (fn [acc mval]
              (reduce (seq mval)
                      acc
                      (fn [acc pair]
                        (apply assoc acc pair))))))

  Seqable
  (seq [n]
    (hash-seq n empty-list))

  Stringable
  (string-list [n]
    (let [a-list (seq n)]
      (cond
       (list-empty? a-list) (list "{}")
       (let [kv-strs (map a-list
                          (fn [kv]
                            (let [strs (interpose (map kv string-list)
                                                   (list " "))]
                              (comp* (car strs) (cdr strs)))))
             body-list (let [strs (interpose kv-strs (list ", "))]
                         (comp* (car strs) (cdr strs)))]
         (comp (list "{")
               body-list
               (list "}"))))))

  HashMapNode
  (hash-seq [n s]
    (inline-text List "
ArrayNode *node = (ArrayNode *)arg0;
List *seq = (List *)arg1;
for (int i = 0; i < 32; i++) {
   if (node->array[i] != (Value *)0)
     seq = (List *)hashSeq(node->array[i], (Value *)seq);
}
return((Value *)seq);
"))

  (assoc* [node k v hash shift]
    (inline-text "
ArrayNode *node = (ArrayNode *)arg0;
Value *key = arg1;
Value *val = arg2;
int64_t hash = ((Number *)arg3)->numVal;
int shift = (int)((Number *)arg4)->numVal;
int idx = mask(hash, shift);
Value *newShift = (Value *)numberValue(shift + 5);
ArrayNode *newNode;

Value *subNode = node->array[idx];
if (subNode == (Value *)0) {
  newNode = (ArrayNode *)malloc_arrayNode();
  for (int i = 0; i < 32; i++) {
    if (node->array[i] != (Value *)0) {
      newNode->array[i] = node->array[i];
      incRef(newNode->array[i]);
    }
  }
  Value *hash = sha1(key);
  if (newNode->array[idx] != (Value *)0)
    decRef(newNode->array[idx]);
  newNode->array[idx] = assoc((Value *)&emptyBMI, key, val, hash, newShift);
  dec_and_free(hash);
} else {
    Value *hash = sha1(key);
    Value *n = assoc(subNode, key, val, hash, newShift);
    newNode = (ArrayNode *)malloc_arrayNode();
    for (int i = 0; i < 32; i++) {
      if (i != idx && node->array[i] != (Value *)0) {
        newNode->array[i] = node->array[i];
        incRef(newNode->array[i]);
      }
    }
    if (newNode->array[idx] != (Value *)0)
      decRef(newNode->array[idx]);
    newNode->array[idx] = n;
    dec_and_free(hash);
}
dec_and_free(newShift);
return((Value *)newNode);
"))
  (get* [node k v hash shift]
    (inline-text "
ArrayNode *node = (ArrayNode *)arg0;
Value *key = arg1;
Value *val = arg2;
int64_t hash = ((Number *)arg3)->numVal;
int shift = (int)((Number *)arg4)->numVal;
int idx = mask(hash, shift);
Value *newShift = (Value *)numberValue(shift + 5);
Value* found;

Value *subNode = node->array[idx];
if (subNode == (Value *)0) {
  found = val;
} else {
  found = get(subNode, key, val, arg3, newShift);
}
dec_and_free(newShift);
return((Value *)found);
"))

  Associative
  (get [m k not-found]
    (inline-text "
Value *hash = sha1(arg1);
Value *shift = numberValue(0);
Value *found = get(arg0, arg1, arg2, hash, shift);
dec_and_free(shift);
dec_and_free(hash);
return(found);
"))
  (keys [m]
    (map (seq m) first))
  (vals [m]
    (map (seq m) second))
  (assoc [_ k v]
    (inline-text "
Value *hash = sha1(arg1);
Value *shift = numberValue(0);
Value *newNode = assoc(arg0, arg1, arg2, hash, shift);
dec_and_free(shift);
dec_and_free(hash);
return(newNode);
")))

(extend-type HashCollisionNode
  Collection
  (count [x]
    (inline-text Number "
return(numberValue(((HashCollisionNode *) arg0)->count / 2));
"))
  (empty? [m]
    ;; TODO: make sure this holds when 'dissoc' is implemented
    false)

  Monoid
  (zero [_] emptyBMI)
  (comp* [mval mvals]
    (reduce mvals
            mval
            (fn [acc mval]
              (reduce (seq mval)
                      acc
                      (fn [acc pair]
                        (apply assoc acc pair))))))

  Seqable
  (seq [n]
    (hash-seq n empty-list))

  Stringable
  (string-list [n]
    (let [a-list (seq n)]
      (cond
       (list-empty? a-list) (list "{}")
       (let [kv-strs (map a-list
                          (fn [kv]
                            (let [strs (interpose (map kv string-list)
                                                   (list " "))]
                              (comp* (car strs) (cdr strs)))))
             body-list (let [strs (interpose kv-strs (list ", "))]
                         (comp* (car strs) (cdr strs)))]
         (comp (list "{")
               body-list
               (list "}"))))))

  HashMapNode
  (hash-seq [n s]
    (inline-text List "
HashCollisionNode *node = (HashCollisionNode *)arg0;
List *seq = (List *)arg1;
for (int i = 0; i < node->count / 2; i++) {
   if (node->array[2 * i] != (Value *)0 && node->array[2 * i + 1] != (Value *)0) {
     List *pair = listCons(node->array[2 * i], listCons(node->array[2 * i + 1], empty_list));
     incRef(node->array[2 * i]);
     incRef(node->array[2 * i + 1]);
     seq = listCons((Value *)pair, seq);
   }
}
return((Value *)seq);
"))

  (assoc* [node k v hash shift]
    (inline-text "
HashCollisionNode *node = (HashCollisionNode *)arg0;
Value *key = arg1;
Value *val = arg2;
int64_t hash = ((Number *)arg3)->numVal;
int shift = (int)((Number *)arg4)->numVal;
HashCollisionNode *newNode;
int itemCount = node->count / 2;

if(equal(sha1(node->array[0]), arg3)) {
   newNode = malloc_hashCollisionNode(itemCount + 1);
   for (int i = 0; i < itemCount; i++) {
      if (equal(node->array[2 * i], key)) {
         newNode->array[2 * i] = key;
         incRef(key);
         newNode->array[2 * i + 1] = val;
         incRef(val);
         newNode->count--;
      } else {
         newNode->array[2 * i] = node->array[2 * i];
         incRef(node->array[2 * i]);
         newNode->array[2 * i + 1] = node->array[2 * i + 1];
         incRef(node->array[2 * i + 1]);
      }
   }
   if (newNode->count != itemCount) {
      newNode->array[2 * itemCount] = key;
      incRef(key);
      newNode->array[2 * itemCount + 1] = val;
      incRef(val);
   }
   return((Value *)newNode);
} else {
   BitmapIndexedNode *bmi = &emptyBMI;
   Number newShift = {NumberType, -1, 0};

   bmi = (BitmapIndexedNode *)assoc((Value *)bmi, key, val, arg3, (Value *)&newShift);
   for (int i = 0; i < itemCount; i++) {
      bmi = (BitmapIndexedNode *)assoc((Value *)bmi, node->array[2 * i], node->array[2 * i + 1],
                                       sha1(node->array[i]), (Value *)&newShift);
   }
   return((Value *)bmi);
}
"))

  (get* [node k v hash shift]
    (inline-text List "
HashCollisionNode *node = (HashCollisionNode *)arg0;
List *seq = (List *)arg1;
for (int i = 0; i < node->count / 2; i++) {
   if (node->array[2 * i] != (Value *)0 && equal(arg1, node->array[2 * i])) {
      if (node->array[2 * i + 1] != (Value *)0) {
        incRef(node->array[2 * i + 1]);
        return(node->array[2 * i + 1]);
      } else {
        incRef(arg2);
        return(arg2);
      }
   }
}
incRef(arg2);
return(arg2);
"))

  Associative
  (get [m k not-found]
    (inline-text "
Value *hash = sha1(arg1);
Value *shift = numberValue(0);
Value *found = get(arg0, arg1, arg2, hash, shift);
dec_and_free(shift);
dec_and_free(hash);
return(found);
"))
  (keys [m]
    (map (seq m) first))
  (vals [m]
    (map (seq m) second))
  (assoc [_ k v]
    (inline-text "
Value *hash = sha1(arg1);
Value *shift = numberValue(0);
Value *newNode = assoc(arg0, arg1, arg2, hash, shift);
dec_and_free(shift);
dec_and_free(hash);
return(newNode);
"))
  )

(defn hash-map [& kv-pairs]
  (reduce (partition kv-pairs 2)
          emptyBMI
          (fn [bmi pair]
            (apply assoc bmi pair))))

(def not-found
  (reify
    Eq
    (=* [x y]
      (= (get-type x) (get-type y)))))

(defn merge-with [merge-fn hm & ms]
  (cond
   (list-empty? ms) hm
   (reduce ms hm
           (fn [hm m]
             (reduce (seq m) hm
                     (fn [hm [k v]]
                       (let [old-v (get hm k not-found)]
                         (cond
                          (= not-found old-v) (assoc hm k v)
                          (assoc hm k (merge-fn old-v v))))))))))

(defn get-in [m path nf]
  (cond
   (= (count path) 0) nf
   (= (count path) 1) (get m (first path) nf)
   (let [[curr-key & path] path
         v (get m curr-key :get-in-not-found)]
     (cond
      (= :get-in-not-found v) nf
      (get-in v path nf)))))

(defn update-in [m path f]
  (cond
   (= (count path) 0) m
   (= (count path) 1) (let [k (first path)
                            curr-v (get m k :update-in-nil)]
                        (cond
                         (= :update-in-nil curr-v) m
                         (assoc m k (f curr-v))))
   (let [[k & path] path
         v (get m k :update-in-nil)]
     (cond
      (= :update-in-nil v) m
      (assoc m k (update-in v path f))))))

(defn assoc-in [m path v]
  (cond
   (= (count path) 0) m
   (= (count path) 1) (assoc m (first path) v)
   (let [[k & path] path
         curr-v (get m k :assoc-in-nil)]
     (cond
      (= :assoc-in-nil curr-v) (assoc m k (assoc-in {} path v))
      (assoc m k (assoc-in curr-v path v))))))

(extend-type Keyword
  Eq
  (=* [x y]
    (symkey= x y))

  Named
  (name [v]
    (symkey-name v))

  Stringable
  (string-list [v] (list (name v)))

  Function
  (invoke [kw hm]
    (let [v (get hm kw not-found)]
      (cond
       (= not-found v) (let [_ (print-err "Could not look up " kw)]
                         (abort))
       v)))

  Hash
  (sha1 [_]
    (inline-text Number "
int64_t shaVal;
Sha1Context context;
SubString *subStrVal = (SubString *)arg0;

if (subStrVal->hash != (Number *)0) {
  incRef((Value *)subStrVal->hash);
  return((Value *)subStrVal->hash);
}
else {
  Sha1Initialise(&context);
  Sha1Update(&context, (void *)&subStrVal->type, 8);
  Sha1Update(&context, (void *)subStrVal->buffer, subStrVal->len);
  Sha1Finalise(&context, (SHA1_HASH *)&shaVal);
  Number *hashVal = (Number *)numberValue(shaVal);
  subStrVal->hash = (Number *)hashVal;
  incRef((Value *)hashVal);
  return((Value *)hashVal);
}
"))

  ;; (invoke [kw hm not-found]
  ;;   (get hm kw not-found))
  )

(extend-type Symbol
  Eq
  (=* [x y]
    (symkey= x y))

  Named
  (name [v]
    (symkey-name v))

  Stringable
  (string-list [v] (list (name v)))

  Function
  (invoke [sym-lit hm]
    (let [v (get hm sym-lit not-found)]
      (cond
       (= not-found v) (let [_ (print-err "Could not look up " sym-lit)]
                         (abort))
       v)))
  (invoke [sym-lit hm not-found]
    (get hm sym-lit not-found))

  Hash
(sha1 [_]
    (inline-text Number "
int64_t shaVal;
Sha1Context context;
SubString *subStrVal = (SubString *)arg0;

if (subStrVal->hash != (Number *)0) {
  incRef((Value *)subStrVal->hash);
  return((Value *)subStrVal->hash);
}
else {
  Sha1Initialise(&context);
  Sha1Update(&context, (void *)&subStrVal->type, 8);
  Sha1Update(&context, (void *)subStrVal->buffer, subStrVal->len);
  Sha1Finalise(&context, (SHA1_HASH *)&shaVal);
  Number *hashVal = (Number *)numberValue(shaVal);
  subStrVal->hash = (Number *)hashVal;
  incRef((Value *)hashVal);
  return((Value *)hashVal);
}
")))

(defn symbol? [sym]
  (instance? Symbol sym))

(defn keyword [kw-name]
  (new-keyword (str ":" kw-name)))

(defn keyword? [kw]
  (instance? Keyword kw))

(defn number? [n]
  (instance? Number n))

(defn string? [s]
  (or (= String (get-type s))
      (= SubStr (get-type s))))

(defn range* [n]
  (cond
   (= 0 n) (list 0)
   (cons n (range* (dec n)))))

(defn range [n]
  (reverse (range* (dec n))))

(defn repeat [n v]
  (cond
   (< n 1) empty-list
   (map (range* (dec n)) (fn [_] v))))

(inline-text "
 int64_t sym_counter = 0;
")

(defn get-sym-count []
  (inline-text Number "
  return numberValue(sym_counter);
"))

(defn set-sym-count [new-count]
  (inline-text Number "
  sym_counter = ((Number *)arg0)->numVal;
  return true;
"))

(defn new-sym-count []
  (inline-text Number "
 static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

 pthread_mutex_lock (&mutex);

 // store value before any other threads increment it further
 int64_t result = sym_counter;
 // only allow one thread to increment at a time
 ++sym_counter;

 pthread_mutex_unlock (&mutex);

 return numberValue(result);
"))

(defn gensym [prefix]
  (symbol (str prefix (new-sym-count))))
