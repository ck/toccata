
(def print-err)

(def VoidT "void")
(def Int8 "char")
(def Int8* "char *")
(def Int32 "int")
(def Int64 "int64_t")
(def ValueType Int64)  ;; type of boxed values
(def Value "typedef struct {int64_t type; int32_t refs;} Value;\n")
(def Value* "Value *")
(def NumberVal "typedef struct {int64_t type; int32_t refs; int64_t numVal;} Number;\n")
(def StringVal "typedef struct {int64_t type; int32_t refs; int64_t len; char buffer[0];} String;\n")
(def SubStringVal "typedef struct {int64_t type; int32_t refs; int64_t len; Value *source; char *buffer;} SubString;\n")
(def ListVal "typedef struct List {int64_t type; int32_t refs; int64_t len; Value* head; struct List *tail;} List;\n")
(def FnArityVal "typedef struct {int64_t type; int32_t refs; int count; List *closures; int variadic; void *fn;} FnArity;\n")
(def FunctionVal "typedef struct {int64_t type; int32_t refs; char *name; int64_t arityCount; FnArity *arities[];} Function;\n")
(def ProtoImpl "typedef struct {int64_t type; Value *implFn;} ProtoImpl;\n")
(def ProtoImpls "typedef struct {int64_t implCount; Value *defaultImpl; ProtoImpl impls[];} ProtoImpls;\n")
(def ReifiedVal "typedef struct {int64_t type; int32_t refs; int implCount; Value* impls[];} ReifiedVal;\n")
(def OpaqueVal "typedef struct {int64_t type; int32_t refs; void *ptr;} Opaque;\n")

(def true (inline-text "(Value *)&trueVal;"))
(def false (inline-text "(Value *)&falseVal;"))

(defn output-to-file [file-path]
  (inline-text
   "String *arg0Str = (String *)my_malloc(sizeof(String) + ((String *)arg0)->len + 5);
    if (arg0->type == StringType)
      snprintf(arg0Str->buffer, ((String *)arg0)->len + 1, \"%s\", ((String *)arg0)->buffer);
    else if (arg0->type == SubStringType)
      snprintf(arg0Str->buffer, ((String *)arg0)->len + 1, \"%s\", ((SubString *)arg0)->buffer);
    else {
      fprintf(stderr, \"\\ninvalid type for 'output-to-file'\\n\");
      abort();
    }

    outStream = fopen(arg0Str->buffer, \"w\");
    return((Value *)&trueVal);\n"))

(defn standard-output []
  (inline-text
   "outStream = stdout;
    return((Value *)&trueVal);\n"))

(defn symkey-name [v]
  (inline-text
   "return(stringValue(((SubString *)arg0)->buffer));\n"))

(defn char-code [c]
  (inline-text "if (arg0->type == StringType) {
                  String *s = (String *)arg0;
                  return(numberValue((int)s->buffer[0]));
                } else if (arg0->type == SubStringType) {
                  SubString *s = (SubString *)arg0;
                  return(numberValue((int)s->buffer[0]));
                } else
                  abort();\n "))

(defn symbol [sym-str]
  (inline-text "if (arg0->type == StringType) {
                     String *s = (String *)arg0;
                     SubString *subStr = malloc_substring();
                     subStr->type = SymbolType;
                     subStr->len = s->len;
                     subStr->source = arg0;
                     incRef(arg0);
                     subStr->buffer = s->buffer;
                     return((Value *)subStr);
                   } else if (arg0->type == SubStringType) {
                     SubString *s = (SubString *)arg0;
                     SubString *subStr = malloc_substring();
                     subStr->type = SymbolType;
                     subStr->len = s->len;
                     subStr->source = arg0;
                     incRef(arg0);
                     subStr->buffer = s->buffer;
                     return((Value *)subStr);
                   } else if (arg0->type == SymbolType) {
                     return(arg0);
                   }
                     abort();\n"))

(defn new-keyword [kw-str]
  (inline-text "if (arg0->type == StringType) {
                     String *s = (String *)arg0;
                     SubString *subStr = malloc_substring();
                     subStr->type = KeywordType;
                     subStr->len = s->len;
                     subStr->source = arg0;
                     incRef(arg0);
                     subStr->buffer = s->buffer;
                     return((Value *)subStr);
                   } else if (arg0->type == SubStringType) {
                     SubString *s = (SubString *)arg0;
                     SubString *subStr = malloc_substring();
                     subStr->type = SymbolType;
                     subStr->len = s->len;
                     subStr->source = arg0;
                     incRef(arg0);
                     subStr->buffer = s->buffer;
                     return((Value *)subStr);
                   } else
                     abort();\n"))

(defn abort []
  (inline-text
   "abort();
    return(true);\n"))

(defn get-type [value]
  (inline-text
   "return(numberValue(arg0->type));"))

(defn type= [x y]
  (inline-text "if (arg0->type == arg1->type)
                   return(true);
                else
                   return(false);\n"))

(defn subs
  ([src index]
     (inline-text "int64_t idx = ((Number *)arg1)->numVal;
                   if (arg0->type == StringType) {
                     String *s = (String *)arg0;
                     SubString *subStr = malloc_substring();
                     subStr->type = SubStringType;
                     if (idx < s->len) {
                       subStr->len = s->len - idx;
                       subStr->source = arg0;
                       incRef(arg0);
                       subStr->buffer = s->buffer + idx;
                     }
                     else {
                       subStr->len = 0;
                       subStr->source = (Value *)0;
                       subStr->buffer = (char *)0;
                     }
                     return((Value *)subStr);
                   } else if (arg0->type == SubStringType) {
                     SubString *s = (SubString *)arg0;
                     SubString *subStr = malloc_substring();
                     subStr->type = SubStringType;
                     if (idx < s->len) {
                       subStr->len = s->len - idx;
                       subStr->source = arg0;
                       incRef(arg0);
                       subStr->buffer = s->buffer + idx;
                     }
                     else {
                       subStr->len = 0;
                       subStr->source = (Value *)0;
                       subStr->buffer = (char *)0;
                     }
                     return((Value *)subStr);
                   } else
                     abort();\n"))
  ([src index length]
     (inline-text "int64_t idx = ((Number *)arg1)->numVal;
                   int64_t len = ((Number *)arg2)->numVal;
                   if (arg0->type == StringType) {
                     String *s = (String *)arg0;
                     SubString *subStr = malloc_substring();
                     subStr->type = SubStringType;
                     if (idx + len <= s->len) {
                       subStr->len = len;
                       subStr->source = arg0;
                       incRef(arg0);
                       subStr->buffer = s->buffer + idx;
                     }
                     else {
                       subStr->len = 0;
                       subStr->source = (Value *)0;
                       subStr->buffer = (char *)0;
                     }
                     return((Value *)subStr);
                   } else if (arg0->type == SubStringType) {
                     SubString *s = (SubString *)arg0;
                     SubString *subStr = malloc_substring();
                     subStr->type = SubStringType;
                     if (idx + len <= s->len) {
                       subStr->len = len;
                       subStr->source = arg0;
                       incRef(arg0);
                       subStr->buffer = s->buffer + idx;
                     }
                     else {
                       subStr->len = 0;
                       subStr->source = (Value *)0;
                       subStr->buffer = (char *)0;
                     }
                     return((Value *)subStr);
                   } else
                     abort();\n")))

;; this function assumes the type of 'n' has already been checked
(defn number-str [n]
  (inline-text
   "String *numStr = (String *)my_malloc(sizeof(String) + 10);
    snprintf(numStr->buffer, 9, \"%lld\", ((Number *)arg0)->numVal);
    numStr->type = StringType;
    numStr->len = strlen(numStr->buffer);
    return((Value *)numStr);\n"))

(defn number= [x y]
  (inline-text
   "if (arg0->type != arg1->type) {
      return(false);
   } else if (((Number *)arg0)->numVal != ((Number *)arg1)->numVal)
      return(false);
   else
      return(true);\n"))

;; this function assumes the type of 'x' has already been checked
(defn number-less-than [x y]
  (inline-text
   "if (arg0->type != arg1->type) {
      fprintf(outStream, \"\\ninvalid types for 'number-less-than'\\n\");
      abort();
   } else if (((Number *)arg0)->numVal < ((Number *)arg1)->numVal)
      return(true);
   else
      return(false);\n"))

;; this function assumes the type of 'x' has already been checked
(defn add-numbers [x y]
  (inline-text
   "if (arg0->type != arg1->type) {
      fprintf(outStream, \"\\ninvalid types for 'add-numbers'\\n\");
      abort();
    } else
      return(numberValue(((Number *)arg0)->numVal + ((Number *)arg1)->numVal));\n"))

;; this function assumes the type of 'x' has already been checked
(defn subtract-numbers [x y]
  (inline-text
   "if (arg0->type != arg1->type) {
      fprintf(outStream, \"\\ninvalid types for 'subtract-numbers'\\n\");
      abort();
    } else
      return(numberValue(((Number *)arg0)->numVal - ((Number *)arg1)->numVal));\n"))

;; this function assumes the type of 'x' has already been checked
(defn mult-numbers [x y]
  (inline-text
   "if (arg0->type != arg1->type) {
      fprintf(stderr, \"\\n*** invalid types for 'mult-numbers'\\n\");
      abort();
    } else
      return(numberValue(((Number *)arg0)->numVal * ((Number *)arg1)->numVal));\n"))

(defn rem [x y]
  (inline-text
   "if (arg0->type != NumberType ||
        arg1->type != NumberType) {
      fprintf(outStream, \"\\ninvalid types for 'rem'\\n\");
      abort();
    } else
      return(numberValue(((Number *)arg0)->numVal %
                         ((Number *)arg1)->numVal));\n"))

(def empty-list
  (inline-text "(Value *)&(List){4,-1,0,0,0};"))

(defn cons
  ([x]
     (inline-text "incRef(arg0);\nreturn((Value *)listCons(arg0, empty_list));\n"))
  ([x l]
     (inline-text "incRef(arg0);\nincRef(arg1);\nreturn((Value *)listCons(arg0, (List *)arg1));\n")))

(defn list-count [l]
  (inline-text
   "if (arg0->type != ListType)
      abort();
    else
      return(numberValue(((List *)arg0)->len));"))

(defn car [l]
  (inline-text
   "List *lst = (List *)arg0;
    if (arg0->type != ListType) {
      fprintf(stderr, \"\\n*** 'car' requires a list\\n\");
      abort();
    } else if (lst->len == 0) {
       fprintf(stderr, \"\\n*** Cannot get head of empty list!!\\n\");
       abort();
    } else {
       incRef(lst->head);
       return(lst->head);
    }\n"))

(defn cdr [l]
  (inline-text
   "List *lst = (List *)arg0;
    if (arg0->type != ListType) {
      fprintf(stderr, \"\\n*** 'cdr' requires a list\\n\");
      abort();
    } else if (lst->len == 0) {
       return((Value *)empty_list);
    } else {
       List *tail = ((List *)arg0)->tail;
       tail->len = lst->len - 1;
       incRef((Value *)tail);
       return((Value *)tail);
    }\n"))

(defn fn-name [f]
  (inline-text
   "if (arg0->type != FunctionType) {
      fprintf(stderr, \"\\n*** invalid type for 'fn-name'\\n\");
      abort();
    } else
      return(stringValue(((Function *)arg0)->name));\n"))

(defn char [n]
  (inline-text
   "if (arg0->type != NumberType) {
      fprintf(outStream, \"\\ninvalid type for 'char'\\n\");
      abort();
    }
    String *strVal = (String *)my_malloc(sizeof(String) + 2);
    strVal->type = StringType;
    strVal->len = 1;
    strVal->buffer[0] = ((Number *)arg0)->numVal;
    strVal->buffer[1] = 0;
    return((Value *)strVal);\n"))

(defn str-count [str]
  (inline-text
   "if (arg0->type != StringType && arg0->type != SubStringType ) {
      fprintf(outStream, \"\\ninvalid type for 'str-count'\\n\");
      abort();
    }
   return(numberValue(((String *)arg0)->len));\n"))

(defn str= [str1 str2]
  (inline-text
   "if (arg0->type == StringType && arg1->type == StringType) {
      String *s1 = (String *)arg0;
      String *s2 = (String *)arg1;
      if (s1->len == s2->len && strncmp(s1->buffer,s2->buffer,s1->len) == 0)
        return(true);
      else
        return(false);
    } else if (arg0->type == SubStringType && arg1->type == SubStringType) {
      SubString *s1 = (SubString *)arg0;
      SubString *s2 = (SubString *)arg1;
      if (s1->len == s2->len && strncmp(s1->buffer,s2->buffer,s1->len) == 0)
        return(true);
      else
        return(false);
    } else if (arg0->type == StringType &&
               arg1->type == SubStringType) {
      String *s1 = (String *)arg0;
      SubString *s2 = (SubString *)arg1;
      if (s1->len == s2->len && strncmp(s1->buffer,s2->buffer,s1->len) == 0)
        return(true);
      else
        return(false);
    } else if (arg0->type == SubStringType &&
               arg1->type == StringType) {
      SubString *s1 = (SubString *)arg0;
      String *s2 = (String *)arg1;
      if (s1->len == s2->len && strncmp(s1->buffer,s2->buffer,s1->len) == 0)
        return(true);
      else
        return(false);
    } else
       return(false);\n"))

(defn symkey= [v1 v2]
  (inline-text
   "if (arg0->type != arg1->type)
      return(false);
    else {
      SubString *s1 = (SubString *)arg0;
      SubString *s2 = (SubString *)arg1;
      if (s1->type == s2->type && strcmp(s1->buffer, s2->buffer) == 0) {
        return(true);
      } else
        return(false);
    }\n"))

(defn str-malloc [len]
  (inline-text
   "String *strVal = (String *)my_malloc(sizeof(String) + ((Number *)arg0)->numVal);
    strVal->type = StringType;
    strVal->len = 0;
    strVal->buffer[0] = 0;
    return((Value *)strVal);\n"))

(defn str-append [dest src]
  (inline-text
   " if (arg0->type != StringType) {
      fprintf(outStream, \"\\ninvalid type for 'str-append'\\n\");
      abort();
    }

    String *s1 = (String *)arg0;
    if (arg1->type == StringType) {
      String *s2 = (String *)arg1;
      strncat(s1->buffer, s2->buffer, s2->len);
      s1->len += s2->len;
    } else if (arg1->type == SubStringType) {
      SubString *s2 = (SubString *)arg1;
      strncat(s1->buffer, s2->buffer, s2->len);
      s1->len += s2->len;
    }
    incRef(arg0);
    return(arg0);\n"))

(defn pr-err* [str]
  (inline-text
   "if (arg0->type == StringType)
      fprintf(stderr, \"%-.*s\", (int)((String *)arg0)->len, ((String *)arg0)->buffer);
    else if (arg0->type == SubStringType)
      fprintf(stderr, \"%-.*s\", (int)((SubString *)arg0)->len, ((SubString *)arg0)->buffer);
    else {
      fprintf(stderr, \"\\ninvalid type for 'pr-err*'\\n\");
      abort();
    }
    return(true);\n"))

(defn slurp [fileName]
  (inline-text
   "String *arg0Str = (String *)my_malloc(sizeof(String) + ((String *)arg0)->len + 5);
    if (arg0->type == StringType)
      snprintf(arg0Str->buffer, ((String *)arg0)->len + 1, \"%s\", ((String *)arg0)->buffer);
    else if (arg0->type == SubStringType)
      snprintf(arg0Str->buffer, ((String *)arg0)->len + 1, \"%s\", ((SubString *)arg0)->buffer);
    else {
      fprintf(stderr, \"\\ninvalid type for 'slurp'\\n\");
      abort();
    }

    FILE *file = fopen(arg0Str->buffer, \"r\");
    fseek(file, 0, SEEK_END);
    int64_t buffSize = ftell(file);
    fseek(file, 0, SEEK_SET);
    String *strVal = (String *)my_malloc(sizeof(String) + buffSize + 10);
    strVal->type = StringType;
    strVal->len = buffSize;
    fread(strVal->buffer, 1, buffSize, file);
    fclose(file);
    decRef((Value *)arg0Str);
    my_free((Value *)arg0Str);
    return((Value *)strVal);\n"))

(defn fn-apply [x args]
  (inline-text "List *argList = (List *)arg1;
                     FnArity *_arity = findFnArity(arg0, argList->len);

                     if (_arity == (FnArity *)0) {
                       fprintf(stderr, \"\\n*** no arity found to apply\\n\");
                       abort();
                     } else if(_arity->variadic) {
                       FnType1 *_fn = (FnType1 *)_arity->fn;
                       return(_fn(_arity->closures, arg1));
                   ")
  (inline-text "} else if (argList->len == 1) {
                       FnType1 *_fn = (FnType1 *)_arity->fn;
                       Value *appArg0 = argList->head;
                       return(_fn(_arity->closures, appArg0));
                   ")
  (inline-text "} else if (argList->len == 2) {
                       FnType2 *_fn = (FnType2 *)_arity->fn;
                       Value *appArg0 = argList->head;
                       argList = argList->tail;
                       Value *appArg1 = argList->head;
                       return(_fn(_arity->closures, appArg0, appArg1));
                   ")
  (inline-text "} else if (argList->len == 3) {
                       FnType3 *_fn = (FnType3 *)_arity->fn;
                       Value *appArg0 = argList->head;
                       argList = argList->tail;
                       Value *appArg1 = argList->head;
                       argList = argList->tail;
                       Value *appArg2 = argList->head;
                       return(_fn(_arity->closures, appArg0, appArg1, appArg2));
                   ")
  (inline-text "} else if (argList->len == 4) {
                       FnType4 *_fn = (FnType4 *)_arity->fn;
                       Value *appArg0 = argList->head;
                       argList = argList->tail;
                       Value *appArg1 = argList->head;
                       argList = argList->tail;
                       Value *appArg2 = argList->head;
                       argList = argList->tail;
                       Value *appArg3 = argList->head;
                       return(_fn(_arity->closures, appArg0, appArg1, appArg2, appArg3));
                   ")
  (inline-text "} else if (argList->len == 5) {
                       FnType5 *_fn = (FnType5 *)_arity->fn;
                       Value *appArg0 = argList->head;
                       argList = argList->tail;
                       Value *appArg1 = argList->head;
                       argList = argList->tail;
                       Value *appArg2 = argList->head;
                       argList = argList->tail;
                       Value *appArg3 = argList->head;
                       argList = argList->tail;
                       Value *appArg4 = argList->head;
                       return(_fn(_arity->closures, appArg0, appArg1, appArg2, appArg3,
                                                    appArg4));
                   ")
  (inline-text "} else if (argList->len == 6) {
                       FnType6 *_fn = (FnType6 *)_arity->fn;
                       Value *appArg0 = argList->head;
                       argList = argList->tail;
                       Value *appArg1 = argList->head;
                       argList = argList->tail;
                       Value *appArg2 = argList->head;
                       argList = argList->tail;
                       Value *appArg3 = argList->head;
                       argList = argList->tail;
                       Value *appArg4 = argList->head;
                       argList = argList->tail;
                       Value *appArg5 = argList->head;
                       return(_fn(_arity->closures, appArg0, appArg1, appArg2, appArg3,
                                                    appArg4, appArg5));
                   ")
  (inline-text "} else if (argList->len == 7) {
                       FnType7 *_fn = (FnType7 *)_arity->fn;
                       Value *appArg0 = argList->head;
                       argList = argList->tail;
                       Value *appArg1 = argList->head;
                       argList = argList->tail;
                       Value *appArg2 = argList->head;
                       argList = argList->tail;
                       Value *appArg3 = argList->head;
                       argList = argList->tail;
                       Value *appArg4 = argList->head;
                       argList = argList->tail;
                       Value *appArg5 = argList->head;
                       argList = argList->tail;
                       Value *appArg6 = argList->head;
                       return(_fn(_arity->closures, appArg0, appArg1, appArg2, appArg3,
                                                    appArg4, appArg5, appArg6));
                   ")
  (inline-text "} else if (argList->len == 8) {
                       FnType8 *_fn = (FnType8 *)_arity->fn;
                       Value *appArg0 = argList->head;
                       argList = argList->tail;
                       Value *appArg1 = argList->head;
                       argList = argList->tail;
                       Value *appArg2 = argList->head;
                       argList = argList->tail;
                       Value *appArg3 = argList->head;
                       argList = argList->tail;
                       Value *appArg4 = argList->head;
                       argList = argList->tail;
                       Value *appArg5 = argList->head;
                       argList = argList->tail;
                       Value *appArg6 = argList->head;
                       argList = argList->tail;
                       Value *appArg7 = argList->head;
                       return(_fn(_arity->closures, appArg0, appArg1, appArg2, appArg3,
                                                    appArg4, appArg5, appArg6, appArg7));
                   ")
  (inline-text "} else if (argList->len == 9) {
                       FnType9 *_fn = (FnType9 *)_arity->fn;
                       Value *appArg0 = argList->head;
                       argList = argList->tail;
                       Value *appArg1 = argList->head;
                       argList = argList->tail;
                       Value *appArg2 = argList->head;
                       argList = argList->tail;
                       Value *appArg3 = argList->head;
                       argList = argList->tail;
                       Value *appArg4 = argList->head;
                       argList = argList->tail;
                       Value *appArg5 = argList->head;
                       argList = argList->tail;
                       Value *appArg6 = argList->head;
                       argList = argList->tail;
                       Value *appArg7 = argList->head;
                       argList = argList->tail;
                       Value *appArg8 = argList->head;
                       return(_fn(_arity->closures, appArg0, appArg1, appArg2, appArg3,
                                                    appArg4, appArg5, appArg6, appArg7,
                                                    appArg8));
                     } else {
                       fprintf(outStream, \"error in 'fn-apply'\\n\");
                       abort();
                     }
                   "))

(defn escape-chars [c]
  ;; does not allocate a Value
  (inline-text "if (arg0->type == StringType) {
                  String *s = (String *)arg0;
                  String *result = (String *)my_malloc(sizeof(String) + s->len * 2 + 5);
                  char *resultBuffer = result->buffer;
                  int resultIndex = 0;
                  for(int i = 0; i < s->len; i++) {
                    if (s->buffer[i] == 10) {
                      resultBuffer[resultIndex++] = 92;
                      resultBuffer[resultIndex++] = 110;
                    } else if (s->buffer[i] == 34) {
                      resultBuffer[resultIndex++] = 92;
                      resultBuffer[resultIndex++] = 34;
                    } else if (s->buffer[i] == 13) {
                      resultBuffer[resultIndex++] = 92;
                      resultBuffer[resultIndex++] = 114;
                    } else if (s->buffer[i] == 12) {
                      resultBuffer[resultIndex++] = 92;
                      resultBuffer[resultIndex++] = 102;
                    } else if (s->buffer[i] == 8) {
                      resultBuffer[resultIndex++] = 92;
                      resultBuffer[resultIndex++] = 98;
                    } else if (s->buffer[i] == 9) {
                      resultBuffer[resultIndex++] = 92;
                      resultBuffer[resultIndex++] = 116;
                    } else if (s->buffer[i] == 92) {
                      resultBuffer[resultIndex++] = 92;
                      resultBuffer[resultIndex++] = 92;
                    } else
                      resultBuffer[resultIndex++] = s->buffer[i];
                  }
                  resultBuffer[resultIndex] = 0;
                  result->type = StringType;
                  result->len = resultIndex;
                  return((Value *)result);
                } else if (arg0->type == SubStringType) {
                  SubString *s = (SubString *)arg0;
                  String *result = (String *)my_malloc(sizeof(String) + s->len * 2 + 5);
                  char *resultBuffer = result->buffer;
                  int resultIndex = 0;
                  for(int i = 0; i < s->len; i++) {
                    if (s->buffer[i] == 10) {
                      resultBuffer[resultIndex++] = 92;
                      resultBuffer[resultIndex++] = 110;
                    } else if (s->buffer[i] == 34) {
                      resultBuffer[resultIndex++] = 92;
                      resultBuffer[resultIndex++] = 34;
                    } else if (s->buffer[i] == 13) {
                      resultBuffer[resultIndex++] = 92;
                      resultBuffer[resultIndex++] = 114;
                    } else if (s->buffer[i] == 12) {
                      resultBuffer[resultIndex++] = 92;
                      resultBuffer[resultIndex++] = 102;
                    } else if (s->buffer[i] == 8) {
                      resultBuffer[resultIndex++] = 92;
                      resultBuffer[resultIndex++] = 98;
                    } else if (s->buffer[i] == 9) {
                      resultBuffer[resultIndex++] = 92;
                      resultBuffer[resultIndex++] = 116;
                    } else if (s->buffer[i] == 92) {
                      resultBuffer[resultIndex++] = 92;
                      resultBuffer[resultIndex++] = 92;
                    } else
                      resultBuffer[resultIndex++] = s->buffer[i];
                  }
                  resultBuffer[resultIndex] = 0;
                  result->type = StringType;
                  result->len = resultIndex;
                  return((Value *)result);
                } else
                  abort();\n "))

(defn pr* [str]
  (inline-text
   "if (arg0->type == StringType)
      fprintf(outStream, \"%-.*s\", (int)((String *)arg0)->len, ((String *)arg0)->buffer);
    else if (arg0->type == SubStringType)
      fprintf(outStream, \"%-.*s\", (int)((SubString *)arg0)->len, ((SubString *)arg0)->buffer);
    else {
      fprintf(outStream, \"\\ninvalid type for 'pr*'\\n\");
      abort();
    }
    return(true);\n"))

;; @jneen_
(defprotocol Variant ;; is CoProduct or Tagged Union
  (bippity [_])
  (match* [_]
    (pr* ":match*-one-arg"))
  (match* [_ match-targets]
    (pr* ":match*-two-args")))

(defprotocol Type
  (instance? [type val]))

(defprotocol Monad
  (flat-map [mval func]
    (print-err "*** 'flat-map' not implemented")
    (abort))
  (flatten [mval]
    (flat-map mval (fn [x] x))))

(defprotocol Comonad
  (extract [wv])
  (extend [wv f])
  (duplicate [wv]))

(def comprehend)

(defprotocol Applicative
  (wrap [x v]
    (print-err "*** 'wrap' not implemented"))
  (apply* [fv args]
    (cond
     (number= 0 (list-count args)) (flat-map fv (fn [f] (wrap fv (f))))
     (flat-map fv (fn [f] (comprehend f args))))))

(defn apply [fv & args]
  (apply* fv args))

(defn apply-to [f & args]
  (cond
   (number= 0 (list-count args)) (f)
   (apply* (wrap (car args) f) args)))

(defn list [& l]
  l)

(defprotocol Functor
  (map [v f]
    (flat-map v (fn [x] (wrap v (f x))))))

(defprotocol Named
  (name [value]
    (print-err "'name' not implemented for type " (get-type value))
    (abort)))

(defprotocol Stringable
  (string-list [value]
    (print-err "'string-list' not implemented for type" (get-type value))
    (abort)))

(defprotocol Serializable
  (serialize [value]
    (print-err "'serialize' not implemented for type" (get-type value))
    (abort)))

(defn list-empty? [coll]
  (number= 0 (list-count coll)))

(defn interpose [coll sep]
  (cond
   (list-empty? coll) coll
   (cons (car coll)
         (flat-map (cdr coll)
                   (fn [x]
                     (list sep x))))))

(defn prn [& vs]
  (map (interpose (flat-map vs serialize) " ")
       pr*)
  (pr* "\n"))

(defn print [& vs]
  (map (flat-map (interpose vs " ") string-list)
       pr*))

(defn println [& vs]
  (map (flat-map (interpose vs " ") string-list) pr*)
  (pr* "\n"))

(defn print-err [& vs]
  (pr-err* "\n*** ")
  (map (flat-map (interpose vs " ") string-list) pr-err*)
  (pr-err* "\n"))

(defprotocol Eq
  (=* [x y]
    (print-err "'=*' not implemented:" x)
    (abort)))

(defprotocol Ord
  (<* [value values]
    (print-err "'<*' not implemented:" value)
    (abort)))

(defprotocol Collection
  (empty? [coll])
  (empty [coll])
  (destruct [coll target])
  (count [coll]
    (print-err "'count' not implemented for " coll)
    (abort))
  (conj [coll value]))

(defn not-empty? [coll]
  (cond
   (empty? coll) false
   true))

(defprotocol Seqable
  (seq? [coll] false)
  (seq [coll])
  (first [coll])
  (rest [coll]))

(defn second [coll]
  (first (rest coll)))

(defprotocol Traversable
  (traverse [coll f]))

(defprotocol Crushable
  (crush [coll f]))

(defprotocol Monoid
  (zero [_])
  (comp* [mval mvals]))

(defn comp [coll & colls]
  (cond
   (empty? colls) coll
   (comp* coll colls)))

(defprotocol Associative
  (assoc [m k v])
  (get [m k not-found]
    (print-err "'get' not implemented: " :m m :k k)
    (abort))
  (keys [m])
  (vals [m]))

(defn not [b-val]
  (cond
   b-val 0
   1))

(defn and [& b-vals]
  (cond
   (empty? b-vals) 1
   (first b-vals) (apply and (rest b-vals))
   0))

(defn or [& b-vals]
  (cond
   (empty? b-vals) 0
   (first b-vals) 1
   (apply or (rest b-vals))))

(defn =
  ([x y] (=* x y))
  ([v & vs]
     (cond
      (empty? vs) 1
      (not (=* v (first vs))) 0
      (number= 1 (count vs)) 1
      (apply = vs))))

(defn <
  ([x y] (<* x y))
  ([v & vs]
     (cond
      (empty? vs) 1
      (not (<* v (first vs))) 0
      (number= 1 (count vs)) 1
      (apply < vs))))

(defn list** [arg args]
  (cond
   (empty? args) arg
   (cons arg (list** (first args) (rest args)))))

(defn list* [arg & args]
  (list** arg args))

(defn reduce [l result f]
  (cond
   (empty? l) result
   (let [head (first l)
         tail (rest l)
         mapped-val (f result head)]
     (cond
      (empty? tail) mapped-val
      (reduce tail mapped-val f)))))

(defn filter [l f]
  (inline-text
     "List *l = (List *)arg0;
      if (arg0->type != ListType) {
         fprintf(stderr, \"'filter' is only defined for 'List' values\\n\");
         abort();
      }

      if (l->len == 0)
        return((Value *)empty_list);
      else {
        List *head = empty_list;
        List *tail;
        for(Value *x = l->head; x != (Value *)0; l = l->tail, x = l->head) {
          Value *y;
          if(arg1->type != 3) {
            y = protoFnImpl_5(empty_list, arg1, x);
          } else {
            FnArity *arity2 = findFnArity(arg1, 1);
            if(arity2 != (FnArity *)0 && !arity2->variadic) {
              FnType1 *fn4 = (FnType1 *)arity2->fn;
              y = fn4(arity2->closures, x);
            } else if(arity2 != (FnArity *)0 && arity2->variadic) {
              FnType1 *fn4 = (FnType1 *)arity2->fn;
              List *varArgs3 = empty_list;
              incRef(x);
              varArgs3 = (List *)listCons(x, varArgs3);
              y = fn4(arity2->closures, (Value *)varArgs3);
              incRef(y);
              decRef((Value *)varArgs3);
              my_free((Value *)varArgs3);
              decRef(y);
            } else {
              fprintf(stderr, \"\\n*** no arity found for '%s'.\\n\", ((Function *)arg1)->name);
              abort();
            }
          }

          // 'y' is the filter boolean value

          if (isTrue(y)) {
            if (head == empty_list) {
              // if we haven't started the new list yet
              head = malloc_list();
              head->type = ListType;
              head->len = 1;
              head->head = x;
              incRef(x);
              head->tail = empty_list;
              tail = head;
            } else {
              // otherwise, append to tail of list
              List *new_tail = malloc_list();
              new_tail->type = ListType;
              new_tail->len = 1;
              new_tail->head = x;
              incRef(x);
              new_tail->tail = empty_list;
              tail->tail = new_tail;
              tail = new_tail;
              head->len++;
            }
          }
        }
        return((Value *)head);
      }\n"))

(defn remove [l f]
  (filter l (fn [v] (not (f v)))))

(defn reverse [l]
  (reduce l (empty l) conj))

(defn identity [x]
  x)

(extend-type Function
  Stringable
  (string-list [f] (list "<Fn: " (fn-name f) ">"))

  Monoid
  (zero [_] identity)
  (comp* [f fs]
    (fn [& args]
      (reduce fs (apply f args)
              (fn [x f]
                (f x)))))

  Applicative
  (apply* [f args]
    (cond
     (empty? args) (f)
     (let [new-args (list** (first args) (rest args))]
       ;; Remember, the last element of 'args' must be a list
       ;; everything up to that must be prepended to it
       (fn-apply f new-args)))))

(extend-type Number
  Eq
  (=* [x y]
    (number= x y))

  Ord
  (<* [x y] (number-less-than x y))

  Stringable
  (string-list [v] (list (number-str v))))

(defn any? [pred coll]
  (cond
   (empty? coll) 0
   (pred (first coll)) 1
   (any? pred (rest coll))))

(deftype ZipList [v]
  Applicative
  (apply* [zv arg-lists]
    (cond
     (any? empty? arg-lists) empty-list
     (let [cars (map arg-lists (fn [l] (cond
                                        (empty? l) :nil
                                        (first l))))
           cdrs (map arg-lists rest)]
       (cons (apply v cars)
             (apply* zv cdrs))))))

(defn partial [f & args]
  (fn [& more-args]
    (apply f (comp args more-args))))

(defn comprehend [f mvs]
  (cond
   (empty? mvs) (f)
   (let [mv (first mvs)
         rest-steps (reduce (reverse (rest mvs))
                            (fn [acc x]
                              (wrap mv (apply f (reverse (cons x acc)))))
                            (fn [steps new-mv]
                              (fn [acc x]
                                (flat-map new-mv (partial steps (cons x acc))))))]
     (cond
      (number= 1 (count mvs)) (flat-map (first mvs) (fn [x]
                                                      (wrap mv (f x))))
      (flat-map mv (partial rest-steps empty-list))))))

(defn list-concat [l1]
  (inline-text
   " List *ls = (List *)arg0;

  if (ls->len == 0) {
    return((Value *)empty_list);
  }
  else if (ls->len == 1) {
    incRef(ls->head);
    return(ls->head);
  }
  else {
    List *head = empty_list;
    List *tail;
    for (; ls != (List *)0; ls = ls->tail) {
      List *l = (List *)ls->head;
      Value *x;
      for(; l != (List *)0 && l->head != (Value *)0; l = l->tail) {
        x = l->head;
        if (head == empty_list) {
          // if we haven't started the new list yet
          head = malloc_list();
          head->type = ListType;
          head->len = 1;
          head->head = x;
          incRef(x);
          head->tail = empty_list;
          tail = head;
        } else {
          // otherwise, append to tail of list
          List *new_tail = malloc_list();
          new_tail->type = ListType;
          new_tail->len = 1;
          new_tail->head = x;
          incRef(x);
          new_tail->tail = empty_list;
          tail->tail = new_tail;
          tail = new_tail;
          head->len++;
        }
      }
    }
    return((Value *)head);
    }\n"))

(defn list=* [ls]
  (cond
   (empty? ls) 1
   (empty? (first ls)) 1
   (not (apply = (map ls (fn [l] (first l))))) 0
   (list=* (map ls rest))))

(extend-type List
  Crushable
  (crush [l f]
    (reduce (cdr l) (f (car l))
            (fn [x y] (comp x (f y)))))

  Traversable
  (traverse [l f]
    (let [vs (map l f)]
      (apply* (wrap (first vs) list) vs)))

  Eq
  (=* [x y]
    (cond
     (not (= (get-type x) (get-type y))) 0
     (not (number= (count x) (count y))) 0
     (list=* (list x y))))

  Stringable
  (string-list [l]
    (comp (list "(")
          (flat-map (interpose l ", ") string-list)
          (list ")")))

  Collection
  (empty? [coll] (number= 0 (list-count coll)))
  (empty [coll] empty-list)
  (conj [l v] (cons v l))
  (count [l] (list-count l))

  Seqable
  (seq? [l]
    true)
  (seq [l] l)
  (first [l] (car l))
  (rest [l] (cdr l))

  Monoid
  (zero [_] empty-list)
  (comp* [l ls]
     (list-concat (cons l ls)))

  Functor
  (map [l f]
    (inline-text
     "List *l = (List *)arg0;
      if (l->len == 0)
        return((Value *)empty_list);
      else {
        List *head = empty_list;
        List *tail;
        for(Value *x = l->head; x != (Value *)0; l = l->tail, x = l->head) {
          Value *y;
          if(arg1->type != 3) {
            y = protoFnImpl_5(empty_list, arg1, x);
          } else {
            FnArity *arity2 = findFnArity(arg1, 1);
            if(arity2 != (FnArity *)0 && !arity2->variadic) {
              FnType1 *fn4 = (FnType1 *)arity2->fn;
              y = fn4(arity2->closures, x);
            } else if(arity2 != (FnArity *)0 && arity2->variadic) {
              FnType1 *fn4 = (FnType1 *)arity2->fn;
              incRef(x);
              List *varArgs3 = (List *)listCons(x, empty_list);
              y = fn4(arity2->closures, (Value *)varArgs3);
              decRef((Value *)varArgs3);
              my_free((Value *)varArgs3);
            } else {
              fprintf(stderr, \"\\n*** no arity found for '%s'.\\n\", ((Function *)arg1)->name);
              abort();
            }
          }

          // 'y' is the value for the new list

          if (head == empty_list) {
            // if we haven't started the new list yet
            head = malloc_list();
            head->type = ListType;
            head->len = 1;
            head->head = y;
            head->tail = empty_list;
            tail = head;
          } else {
            // otherwise, append to tail of list
            List *new_tail = malloc_list();
            new_tail->type = ListType;
            new_tail->len = 1;
            new_tail->head = y;
            new_tail->tail = empty_list;
            tail->tail = new_tail;
            tail = new_tail;
            head->len++;
          }
        }
        return((Value *)head);
      }\n"))

  Applicative
  (wrap [x v] (list v))

  Monad
  (flat-map [mv mf]
    (let [l (map mv mf)]
      (cond
       (empty? l) empty-list
       (comp* (car l) (cdr l))))))

(defn some [coll f]
  (cond
   (empty? coll) 0
   (f (first coll)) 1
   (some (rest coll) f)))

(defn inc [x]
  (add-numbers x 1))

(defn + [& xs]
  (cond
   (empty? xs) 0
   (reduce xs 0 add-numbers)))

(defn * [& xs]
  (cond
   (empty? xs) 1
   (reduce xs 1 mult-numbers)))

(defn dec [x]
  (subtract-numbers x 1))

(defn - [& xs]
  (cond
   (empty? xs) 0
   (let [h (first xs)
         t (rest xs)]
     (cond
      (empty? t) h
      (reduce t h subtract-numbers)))))

(def maybe-val)

(def nothing
  (reify
    Stringable
    (string-list [_] (list "<nothing>"))

    Eq
    (=* [nv x] (type= nv x))

    Monoid
    (zero [nv] nv)
    (comp* [nv mvs]
      (cond
       (empty? mvs) nv
       (comp* (first mvs) (rest mvs))))

    Functor
    (map [nv f] nv)

    Applicative
    (wrap [_ x] (maybe-val x))
    (apply* [nv _] nv)

    Monad
    (flatten [nv] nv)
    (flat-map [nv _] nv)))

(deftype maybe-val [v]
  Stringable
  (string-list [mv]
    (comp (list "<maybe ")
          (string-list (.v mv))
          (list ">")))

  Eq
  (=* [x y]
    (cond
     (not (type= x y)) false
     (= v (.v y))))

  Monoid
  (zero [_] nothing)
  (comp* [mv _] mv)

  Functor
  (map [_ f]
    (maybe-val (f v)))

  Applicative
  (wrap [_ v] (maybe-val v))
  (apply* [fv args]
    (cond
     (some args (partial = nothing)) nothing
     (maybe-val (apply (.v fv) (map args .v)))))

  Monad
  (flatten [_] v)
  (flat-map [_ f]
    (f v)))

(def maybe
  (reify
    Function
    (invoke [_ v] (maybe-val v))

    Type
    (instance? [_ mv] (instance? maybe-val mv))

    Monoid
    (zero [_] nothing)
    (comp* [_ _] :nothing-here)
    ))

(extend-type String
  Eq
  (=* [x y] (str= x y))

  Collection
  (empty? [s]
    (= 0 (str-count s)))
  (empty [s]
    "")
  (count [s]
    (str-count s))
  (conj [s value]
    (apply comp (flat-map (list s value) string-list)))

  Seqable
  (seq [s]
    (cond
     (= s "") empty-list
     (cons (subs s 0 1) (seq (subs s 1)))))
  (first [s]
    (cond
     (= s "") nothing
     (maybe (subs s 0 1))))
  (rest [s]
    (subs s 1))

  Stringable
  (string-list [v] (list v))

  Monoid
  (comp* [s ss]
    (cond
     (list-empty? ss) s
     (let [ss-list (flat-map (cons s ss) string-list)
           new-len (reduce ss-list 0
                           (fn [len s]
                             (add-numbers len (str-count s))))
           new-str (str-malloc new-len)]
       (map ss-list (fn [s]
                      (str-append new-str s)
                      0))
       new-str))))

(extend-type SubStr
  Stringable
  (string-list [v] (list v))

  Eq
  (=* [x y] (str= x y))

  Collection
  (empty? [s]
    (= 0 (str-count s)))
  (empty [s]
    "")
  (count [s]
    (str-count s))
  (conj [s value]
    (apply comp (flat-map (list s value) string-list)))

  Seqable
  (seq [s]
    (cond
     (= s "") empty-list
     (cons (subs s 0 1) (seq (subs s 1)))))
  (first [s]
    (cond
     (= s "") nothing
     (maybe (subs s 0 1))))
  (rest [s]
    (subs s 1))

  Monoid
  (comp* [s ss]
    (cond
     (list-empty? ss) s
     (let [ss-list (flat-map (cons s ss) string-list)
           new-len (reduce ss-list 0
                           (fn [len s]
                             (add-numbers len (str-count s))))
           new-str (str-malloc new-len)]
       (map ss-list (fn [s]
                      (str-append new-str s)
                      0))
       new-str))))

(defn str [& vs]
  (cond
   (empty? vs) ""
   (let [ss-list (flat-map vs string-list)
         new-len (reduce ss-list 0
                         (fn [len s]
                           (add-numbers len (str-count s))))
         new-str (str-malloc new-len)]
     (map ss-list (fn [s]
                    (str-append new-str s)
                    0))
     new-str)))

(defn take [l n]
  (cond
   (empty? l) l
   (= 0 n) empty-list
   (cons (first l)
         (take (rest l) (dec n)))))

(defn drop [coll n]
  (cond
   (< n 1) coll
   (drop (rest coll) (dec n))))

(defn split
  ([l n prefix]
     (cond
      (or (empty? l) (< n 1)) (list (reverse prefix) l)
      (split (rest l) (dec n) (cons (first l) prefix))))
  ([l n]
     (split l n empty-list)))

(defn replace-at-nth [l n v]
  (cond
   (empty? l) l
   (< (dec (count l)) n) l
   (let [split-l (split l n)]
     (comp (first split-l)
           (list v)
           (rest (second split-l))))))

(defn remove-nth [l n]
  (cond
   (empty? l) l
   (< (dec (count l)) n) l
   (let [split-l (split l n)]
     (comp (first split-l)
           (rest (second split-l))))))

(defn partition [coll n]
  (cond
   (< (count coll) n) empty-list
   (cons (take coll n)
         (partition (drop coll n) n))))

(defn partition-all [coll n]
  (cond
   (< (count coll) n) (list coll)
   (cons (take coll n)
         (partition-all (drop coll n) n))))

(defn nth
  ([coll n]
     (cond
      (empty? coll) (let [_ (print-err "'nth' from empty seq")]
                      (abort))
      (= n 0) (first (seq coll))
      (nth (rest (seq coll)) (dec n))))
  ([coll n not-found]
     (cond
      (empty? coll) not-found
      (= n 0) (first (seq coll))
      (nth (rest (seq coll)) (dec n) not-found))))

(defn last [coll last-val]
  (nth coll (dec (count coll))))

(defn butlast [coll]
  (cond
   (empty? coll) coll
   (= 1 (count coll)) empty-list
   (cons (first coll) (butlast (rest coll)))))

(defn map-assoc [m k v]
  (cond
   (list-empty? m) (list (list k v))
   (= (car (car m)) k) (cons (list k v) (cdr m))
   (cons (car m) (map-assoc (cdr m) k v))))

(defn map-get [m k not-found]
  (cond
   (list-empty? m)
   not-found

   (= (car (car m)) k)
   (car (cdr (car m)))

   (map-get (cdr m) k not-found)))

(defn hash-map= [a-list m]
  (cond
   (empty? a-list) 1
   (let [kv-pair (first a-list)
         k (first kv-pair)
         v (first (rest kv-pair))]
     (cond
      (= :hm-nf k) 0
      (= :hm-nf v) 0
      (not (= v (get m k :hm-nf))) 0
      (hash-map= (rest a-list) m)))))

(deftype HashMap [a-list]
  Seqable
  (seq [_]
    a-list)
  (first [_]
    (car a-list))
  (rest [_]
    (cdr a-list))

  Eq
  (=* [x y]
    (cond
     (not (= (count a-list) (count (seq y)))) 0
     (hash-map= a-list y)))

  Stringable
  (string-list [m]
    (cond
     (list-empty? a-list) (list "{}")
     (let [kv-strs (map a-list
                        (fn [kv]
                          (apply comp (interpose (map kv string-list)
                                                 (list " ")))))
           body-list (apply comp (interpose kv-strs (list ", ")))]
       (comp (list "{")
             body-list
             (list "}")))))

  Collection
  (empty? [_]
    (empty? a-list))
  (count [_]
    (count a-list))

  Monoid
  (zero [_]
    (HashMap empty-list))
  (comp* [hm ms]
    (cond
     (empty? ms) hm
     (reduce ms hm
             (fn [hm m]
               (reduce (seq m) hm
                       (fn [hm kv]
                         (assoc hm (nth kv 0) (nth kv 1))))))))

  Associative
  (assoc [_ k v]
    (HashMap (map-assoc a-list k v)))

  (get [_ k not-found]
    (map-get a-list k not-found))

  (keys [m]
    (map a-list first))

  (vals [m]
    (map a-list second)))

(defn hash-map [& kv-pairs]
  (HashMap (partition kv-pairs 2)))

(defn merge-with [merge-fn hm & ms]
  (cond
   (empty? ms) hm
   (reduce ms hm
           (fn [hm m]
             (reduce (seq m) hm
                     (fn [hm kv]
                       (cond
                        (not (= 2 (count kv))) hm
                        (let [k (nth kv 0)
                              v (nth kv 1)
                              old-v (get hm k :not-found)]
                          (cond
                           (= :not-found old-v) (assoc hm k v)
                           (assoc hm k (merge-fn old-v v)))))))))))

(defn get-in [m path nf]
  (cond
   (= (count path) 0) nf
   (= (count path) 1) (get m (first path) nf)
   (let [v (get m (first path) :get-in-not-found)]
     (cond
      (= :get-in-not-found v) nf
      (get-in v (rest path) nf)))))

(defn update-in [m path f]
  (cond
   (= (count path) 0) m
   (= (count path) 1) (let [k (first path)
                            curr-v (get m k :update-in-nil)]
                        (cond
                         (= :update-in-nil curr-v) m
                         (assoc m k (f curr-v))))
   (let [k (first path)
         v (get m k :update-in-nil)]
     (cond
      (= :update-in-nil v) m
      (assoc m k (update-in v (rest path) f))))))

(defn assoc-in [m path v]
  (cond
   (= (count path) 0) m
   (= (count path) 1) (assoc m (first path) v)
   (let [k (first path)
         curr-v (get m k :assoc-in-nil)]
     (cond
      (= :assoc-in-nil curr-v) (assoc m k (assoc-in {} (rest path) v))
      (assoc m k (assoc-in curr-v (rest path) v))))))

(def not-found
  (reify
    Eq
    (=* [x y]
      (= (get-type x) (get-type y)))))

(extend-type Keyword
  Eq
  (=* [x y]
    (symkey= x y))

  Named
  (name [v]
    (symkey-name v))

  Stringable
  (string-list [v] (list (name v)))

  Function
  (invoke [kw hm]
    (let [v (get hm kw not-found)]
      (cond
       (= not-found v) (let [_ (print-err "Could not look up " kw)]
                         (abort))
       v)))
  ;; (invoke [kw hm not-found]
  ;;   (get hm kw not-found))
  )

(extend-type Symbol
  Eq
  (=* [x y]
    (symkey= x y))

  Named
  (name [v]
    (symkey-name v))

  Stringable
  (string-list [v] (list (name v)))

  Function
  (invoke [sym-lit hm]
    (let [v (get hm sym-lit not-found)]
      (cond
       (= not-found v) (let [_ (print-err "Could not look up " sym-lit)]
                         (abort))
       v)))
  (invoke [sym-lit hm not-found]
    (get hm sym-lit not-found)))

(defn symbol? [sym]
  (= Symbol (get-type sym)))

(defn keyword [kw-name]
  (new-keyword (str ":" kw-name)))

(defn keyword? [kw]
  (= Keyword (get-type kw)))

(defn number? [n]
  (= Number (get-type n)))

(defn string? [s]
  (or (= String (get-type s))
      (= SubStr (get-type s))))

(defn range* [n]
  (cond
   (= 0 n) (list 0)
   (cons n (range* (dec n)))))

(defn range [n]
  (reverse (range* (dec n))))

(defn repeat [n v]
  (cond
   (< n 1) empty-list
   (map (range* (dec n)) (fn [_] v))))
