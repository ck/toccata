
;; TODO:
;; implement lazy 'or', 'and'
;; refactor calls to 'match'
;; use #line directive
;; make 'match' efficient
;; memoize call-sites with static args
;; get rid of TODO's
;; implement dissoc
;; implement definitions that require initialization at start time.
;; supercompilation
;; better error messages
;; implement to-be-freed lists
;; problem in multi-arity defn when one arity has no args
;; test memory exhaustion handling
;; implements?
;; REPL
;; fn meta data; doc strings and ast
;; macro system
;; destructuring of maps and deftypes
;; destructuring in let bindings
;; green threads
;; async
;; dependencies
;; persistent data structures; vectors, hash-sets
;; FFI
;; Android/iOS
;; native arrays
;; linear algebra
;; compact lists cdr coding

;; Optimization hints:
;; eliminate closed-over syms from flat-map, wrap impls

(add-ns sm (module "core/state-maybe.toc"))
(add-ns fr (module "core/free.toc"))
(add-ns parser (module "core/parser.toc"))
(add-ns grmr (module "core/grammar.toc"))
(add-ns an (module "core/analyzer.toc"))
(add-ns ast (module "core/ast.toc"))

(def StringType (inline-text Number "(Value *)&(Number){NumberType, -1, StringType};"))
(def NumberType (inline-text Number "(Value *)&(Number){NumberType, -1, NumberType};"))
(def FunctionType (inline-text Number "(Value *)&(Number){NumberType, -1, FunctionType};"))
(def ListType (inline-text Number "(Value *)&(Number){NumberType, -1, ListType};"))
(def KeywordType (inline-text Number "(Value *)&(Number){NumberType, -1, KeywordType};"))
(def SubStringType (inline-text Number "(Value *)&(Number){NumberType, -1, SubStringType};"))
(def SymbolType (inline-text Number "(Value *)&(Number){NumberType, -1, SymbolType};"))
(def FnArityType (inline-text Number "(Value *)&(Number){NumberType, -1, FnArityType};"))
(def OpaqueType (inline-text Number "(Value *)&(Number){NumberType, -1, OpaqueType};"))
(def BitmapIndexedType (inline-text Number "(Value *)&(Number){NumberType, -1, BitmapIndexedType};"))
(def ArrayNodeType (inline-text Number "(Value *)&(Number){NumberType, -1, ArrayNodeType};"))
(def HashCollisionNodeType (inline-text Number "(Value *)&(Number){NumberType, -1, HashCollisionNodeType};"))

(defn debug [& args]
  (comp (for [debugging (sm/get-val :debug-on)]
          (apply print-err args))
        (sm/state-maybe "")))

(defn index [coll]
  (let [coll (seq coll)]
    (zip-lists (range (count coll)) coll)))

(deftype c-code [c-val init decl type-num]
  Stringable
  (string-list [_]
    (list "<C-Code " (str c-val) ", " (str type-num) ">"))

  Monoid
  (zero [_] (c-code "" empty-list empty-list :no-type))
  (comp* [c cs]
    (reduce cs c
            (fn [result expr]
              (c-code (.c-val expr)
                      (comp (.init result) (.init expr))
                      (comp (.decl result) (.decl expr))
                      (.type-num expr))))))

(defn write-strs [str-lists]
  (map (sm/state-maybe str-lists)
       (fn [str-list]
         (map str-list print))))

(defn genlocal [pre]
  (for [sym-count (sm/get-val :local-sym-count)
        _ (sm/set-val :local-sym-count (inc sym-count))]
    (symbol (str pre sym-count))))

(defprotocol Emitter
  (emit-c [ast]))

(extend-type Function
  Emitter
  (emit-c [f] (sm/state-maybe f)))

(extend-type ast/inline-ast
  Emitter
  (emit-c [ast]
    (for [type (sm/get-in-val (list :types (.result-type ast)) :no-type)]
      (c-code "" (list (.txt ast)) empty-list type))))

(defn already-closed-over [closed-over sym]
  (sm/when (some closed-over (fn [[c-sym sym-literal]]
                               (for [_ (= sym sym-literal)]
                                 c-sym)))))

(defn new-closure [sym]
  (for [closure-sym (genlocal "val")
        _ (sm/update-in-val (list :closed-over)
                            (partial cons (list closure-sym sym)))]
    closure-sym))

(defn closed-over-sym [sym]
  (for [;; it's supposed to fail if 'sym' is not in the context
        sym-val (sm/get-in-val (list :context sym))

        ;; if 'sym' is in the context, it should be in :closed-over
        closed-over (sm/get-val :closed-over)
        closure-sym (comp (already-closed-over closed-over sym)
                          (new-closure sym))]
    (c-code closure-sym empty-list empty-list (.type-num sym-val))))

(defn lookup-static-arity [target-sym num-args]
  (sm/get-in-val (list :static-fns target-sym num-args :c-code)))

(defn lookup-proto-arity [name num-args type-num]
  (for [qualified-name (sm/get-in-val (list :defined-protos name))
        proto-fn (sm/get-in-val (list :protocols qualified-name :impl-arities
                                      num-args type-num :fn-sym))
        arity-info (lookup-static-arity proto-fn num-args)]
    arity-info))

;; A symbol can be a local, from the context, from the dictionary, or
;; a getter
(defn lookup-sym [sym]
  (comp (sm/get-in-val (list :local-syms sym))
        (closed-over-sym sym)
        (sm/get-in-val (list :defined-syms sym))
        (for [disp-sym (sm/get-in-val (list :protocols (str "Getter/" sym) :dispatch-sym))]
          (c-code disp-sym empty-list empty-list FunctionType))))

(defn lookup-fn-arity [sym num-args]
  (for [fn-sym (lookup-sym sym)
        arity-sym (lookup-static-arity (.c-val fn-sym) num-args)]
    (.c-val arity-sym)))

;; TODO; try to get rid of this fn
(defn lookup-static-return-type [target-sym num-args]
  (comp (for [arity-info (lookup-static-arity target-sym num-args)]
          (.type-num arity-info))
        (sm/state-maybe :no-type)))

(extend-type ast/symbol-ast
  Emitter
  (emit-c [ast]
    (comp (lookup-sym (.sym ast))
          (for [file-name (sm/get-val :file-name)
                line-num (sm/get-val :line-num)]
            (let [_ (print-err "Undefined symbol:" (.sym ast) "at" file-name ":" line-num)]
              (abort))))))

(defn make-static-string [str-val]
  (let [str-len (count str-val)]
    (for [str-idx (sm/get-val :str-count)
          _ (sm/set-val :str-count (inc str-idx))
          :let [str-sym (str "str" str-idx)
                str-ptr (str "strPtr" str-idx)]
          _ (sm/assoc-in-val (list :static-strings str-val)
                             (c-code str-ptr empty-list empty-list StringType))]
      (c-code str-ptr
              empty-list
              (list "struct {int64_t type;\n int32_t refs;\n   int64_t len;\n   char buffer["
                    (inc str-len)
                    "];} " str-sym " = {StringType, -1, "
                    str-len ",\"" (escape-chars str-val) "\"};\n"
                    "Value *" str-ptr " = (Value *)&" str-sym ";\n")
              StringType))))

(extend-type ast/const-string-ast
  Emitter
  (emit-c [ast]
    (comp (sm/get-in-val (list :static-strings (.const-str ast)))
          (make-static-string (.const-str ast)))))

(defn make-static-num [num]
  (for [num-idx (sm/get-val :num-count)
        _ (sm/set-val :num-count (inc num-idx))
        :let [num-sym (str "num" num-idx)
              num-ptr (str "numPtr" num-idx)]
        _ (sm/assoc-in-val (list :numbers num)
                           (c-code num-ptr empty-list empty-list NumberType))]
    (c-code num-ptr
            empty-list
            (list "Number " num-sym " = {NumberType, -1, " num "};\n"
                  "Value *" num-ptr " = (Value *)&" num-sym ";\n")
            NumberType)))

(extend-type ast/const-number-ast
  Emitter
  (emit-c [ast]
    (let [num (.num ast)]
      (comp (sm/get-in-val (list :numbers num))
            (make-static-num num)))))

(defn make-static-kw [kw]
  (for [kw-idx (sm/get-val :kw-count)
        _ (sm/set-val :kw-count (inc kw-idx))
        :let [kw-sym (str "kw" kw-idx)
              kw-ptr (str "kwPtr" kw-idx)]
        _ (sm/assoc-in-val (list :keywords kw)
                           (c-code kw-ptr empty-list empty-list KeywordType))]
    (c-code kw-ptr
            empty-list
            (list "SubString " kw-sym " = {KeywordType, -1, " (count (str kw)) ", 0, 0, \"" kw "\"};\n"
                  "Value *" kw-ptr " = (Value *)&" kw-sym ";\n")
            KeywordType)))

(extend-type ast/keyword-ast
  Emitter
  (emit-c [ast]
    (let [kw (.kw ast)]
      (comp (sm/get-in-val (list :keywords kw))
            (make-static-kw kw)))))

(extend-type ast/quoted-ast
  Emitter
  (emit-c [ast]
    (let [sym (.q-val ast)]
      (comp (sm/get-in-val (list :symbols sym))
            (for [sym-idx (sm/get-val :sym-count)
                  _ (sm/set-val :sym-count (inc sym-idx))
                  :let [sym-sym (str "sym" sym-idx)
                        sym-ptr (str "symPtr" sym-idx)]
                  _ (sm/assoc-in-val (list :symbols sym)
                                     (c-code sym-ptr empty-list empty-list KeywordType))]
              (c-code sym-ptr
                      empty-list
                      (list "SubString " sym-sym " = {SymbolType, -1, " (count (str sym))
                            ", 0, 0, \"" sym "\"};\n"
                            "Value *" sym-ptr " = (Value *)&" sym-sym ";\n")
                      SymbolType))))))

(defn update-startup-init [init-list]
  (comp (for [_ (sm/when-not (list-empty? init-list))
              start-up-init (sm/get-val :startup-init)
              _ (sm/set-val :startup-init (cons init-list start-up-init))]
          "")
        (sm/state-maybe "")))

(defn define-inline-text-value [name evalled-expr]
  (for [_ (sm/when (= (.c-val evalled-expr) ""))
        c-name (comp (for [def (sm/get-in-val (list :defined-syms name))]
                       ;; for a declared symbol
                       (.c-val def))
                     (for [c-name (sm/state-maybe (gensym "var_"))]
                       ;; for a newly defined symbol
                       c-name))
        _ (write-strs (list "Value *" c-name " = "
                            (first (.init evalled-expr)) ";\n"))]
    (c-code c-name empty-list empty-list (.type-num evalled-expr))))

(defn declared-immediate-init [name evalled-expr]
  (for [def (sm/get-in-val (list :defined-syms name))
        :when (= (.c-val def) (.c-val evalled-expr))
        _ (update-startup-init (.init evalled-expr))]
    (c-code (.c-val def) empty-list empty-list (.type-num evalled-expr))))

(defn declared-startup-init [name evalled-expr]
  (for [def (sm/get-in-val (list :defined-syms name))
        _ (update-startup-init (comp (.init evalled-expr)
                                     (list (.c-val def) " = "
                                           (.c-val evalled-expr) ";\n")))]
    (c-code (.c-val def) empty-list empty-list (.type-num evalled-expr))))

(defn define-declared-symbol [defined-sym evalled-expr]
  (comp (declared-immediate-init defined-sym evalled-expr)
        (declared-startup-init defined-sym evalled-expr)))

(defn define-value [evalled-expr]
  (for [_ (update-startup-init (.init evalled-expr))]
    (c-code (.c-val evalled-expr) empty-list empty-list (.type-num evalled-expr))))

(extend-type ast/definition-ast
  Emitter
  (emit-c [ast]
    (let [defined-sym (.name ast)]
      (for [evalled-expr (fr/evaluate (.value ast) emit-c)
            _ (write-strs (.decl evalled-expr))
            value (comp (define-inline-text-value defined-sym evalled-expr)
                        (define-declared-symbol defined-sym evalled-expr)
                        (define-value evalled-expr))
            file-name (sm/get-val :file-name)
            _ (sm/assoc-in-val (list :modules file-name :syms defined-sym) value)
            _ (sm/assoc-in-val (list :defined-syms defined-sym) value)]
        (c-code "" empty-list empty-list :no-type)))))

(extend-type ast/declaration-ast
  Emitter
  (emit-c [ast]
    (let [c-name (gensym "var_")
          name (.name ast)
          def (c-code c-name empty-list empty-list :no-type)]
      (for [_ (write-strs (list "// forward declaration for '" name "'\n"
                                "Value *" c-name ";\n\n"))
            _ (sm/assoc-in-val (list :defined-syms name) def)]
        def))))

(defn emit-proto-default [proto-name [num-args impl-map]]
  (match (m-get impl-map :default)

         |maybe default-impl|
         (for [default-fn (fr/evaluate default-impl emit-c)
               _ (write-strs (.decl default-fn))
               ;; '0' is the 'default' type.
               _ (sm/assoc-in-val (list :protocols proto-name :impl-arities num-args 0 :arity-sym)
                                  (.c-val default-fn))]
           default-fn)

         (sm/assoc-in-val (list :protocols proto-name :impl-arities num-args) {})))

(defn declare-proto-dispatch-arity [proto-name dispatch-fn-sym [num-args]]
  (let [proto-arity-sym (gensym "protoDisp_")
        impls-sym (gensym "protoImpls_")]
    (for [_ (sm/assoc-in-val (list :protocols proto-name :impls-syms num-args) impls-sym)
          _ (sm/assoc-in-val (list :static-fns dispatch-fn-sym num-args :c-code)
                             (c-code proto-arity-sym empty-list empty-list :no-type))
          _ (write-strs (list "ProtoImpls " impls-sym ";\n"))
          _ (write-strs (list "Value *" proto-arity-sym "("))
          _ (write-strs (interpose (cons "List *closures"
                                         (map (range num-args)
                                              (fn [n]
                                                (str "Value *arg" n))))
                                   ", "))
          _ (write-strs (list ");\n"))]
      "")))

(extend-type ast/protocol-ast
  Emitter
  (emit-c [ast]
    (for [file-name (sm/get-val :file-name)
          :let [protocol-name (match file-name
                                     "" (str (.protocol-name ast) "/")
                                     (str file-name "/" (.protocol-name ast) "/"))]
          curr-fn-sym (sm/get-val :curr-fn-sym)
          curr-fn-ptr (sm/get-val :curr-fn-ptr)
          _ (sm/set-val :curr-fn-sym :no-fn)
          _ (sm/set-val :curr-fn-ptr :no-fn-ptr)
          _ (sm/traverse (seq (.prototypes ast))
                         (fn [[name arities]]
                           (let [dispatch-fn-sym (gensym "dispatchFnPtr_")
                                 qualified-name (str protocol-name name)
                                 dispatch-c-code (c-code dispatch-fn-sym empty-list
                                                         empty-list FunctionType)]
                             (for [_ (write-strs (list "\n// proto fn for " qualified-name "\n"
                                                       "Value *" dispatch-fn-sym ";\n"))
                                   _ (sm/assoc-in-val (list :modules file-name :protos name) qualified-name)
                                   _ (sm/assoc-in-val (list :modules file-name :syms name) dispatch-c-code)
                                   _ (sm/assoc-in-val (list :protocols qualified-name :dispatch-sym)
                                                      dispatch-fn-sym)
                                   _ (sm/assoc-in-val (list :defined-protos name) qualified-name)
                                   _ (sm/assoc-in-val (list :defined-syms name) dispatch-c-code)
                                   _ (sm/traverse (seq arities)
                                                  (partial declare-proto-dispatch-arity
                                                           qualified-name dispatch-fn-sym))
                                   _ (sm/traverse (seq arities)
                                                  (partial emit-proto-default qualified-name))]
                               ""))))
          _ (sm/set-val :curr-fn-sym curr-fn-sym)
          _ (sm/set-val :curr-fn-ptr curr-fn-ptr)]
      ;; prototype definitions are top level
      (c-code "" empty-list empty-list :no-type))))

(defn begin-scope []
  (for [scope-locals (sm/get-val :scope-locals)
        _ (sm/set-val :scope-locals {})]
    scope-locals))

(defn end-scope [scope-info]
  (sm/set-val :scope-locals scope-info))

(defn remember-local [sym]
  (sm/assoc-in-val (list :scope-locals (str sym))
                   (str "dec_and_free(" sym ");\n")))

(defn free-scope-locals [result-sym]
  (for [scope-locals (sm/get-val :scope-locals)]
    (let [locals (seq scope-locals)]
      ;; TODO: getting closer. Still needs work
      (match (comp (for [_ (= result-sym "")]
                     locals)
                   (for [_ (= 1 (count locals))
                         [local _] (m-first locals)
                         _ (= (str result-sym) local)]
                     empty-list))
             |maybe locals| (map locals second)
             (list* "incRef(" result-sym ");\n" (map locals second))))))

(defn emit-reified-fn [protocol-name type-num [name ast]]
  (let [fn-ptr (gensym "protoFnPtr_")
        num-args (count (.args (.v ast)))]
    (for [_ (sm/set-val :curr-fn-ptr fn-ptr)
          _ (sm/set-val :curr-fn-sym :no-fn)
          evalled (fr/evaluate ast emit-c)
          ;; TODO: blow up if 'protocol-name' or 'name' is not valid
          ;; qualified-name (sm/get-in-val (list :defined-protos name))
          ;; _ (debug :reifying protocol-name type-num name (type-name name) qualified-name)

          ;; is the refied fn impl a closure or not?
          _ (match (.init evalled)
                   ;; no, it's not a closure
                   empty-list (for [proto-fn-name (sm/get-in-val (list :defined-protos name))
                                    _ (sm/assoc-in-val (list :protocols proto-fn-name :impl-arities
                                                             num-args type-num)
                                                       {:arity-sym (.c-val evalled)
                                                        :fn-sym fn-ptr})]
                                evalled)

                   ;; yes it's a closure
                   (let [args (map (range num-args) (partial str "arg"))
                         arg-decls (apply str (interpose (cons (str "List *closures")
                                                               (map args (fn [arg] (str "Value *" arg))))
                                                         ", "))
                         args (apply str (interpose (cons "closures" args) ", "))
                         fn-arity-sym (gensym "protoFnArity_")]
                     (for [qualified-name (sm/get-in-val (list :defined-protos name))
                           reify-fn-index (sm/get-val :reify-fn-index)
                           impl-sym (sm/state-maybe (gensym "protoImpl_"))
                           _ (sm/assoc-in-val (list :protocols qualified-name :impl-arities num-args type-num)
                                              {:arity-sym (str "&" fn-arity-sym)
                                               :fn-sym fn-ptr})
                           _ (write-strs (list "// implementation of " protocol-name "\n"
                                               "Value *" impl-sym "(" arg-decls ") {\n"
                                               "FnArity *arityPtr = (FnArity *)((ReifiedVal *)arg0)->impls["
                                               reify-fn-index "];\n"
                                               "Value *rval = ((FnType" num-args
                                               " *)arityPtr->fn)(arityPtr->" args ");\n"
                                               "return(rval);\n"
                                               "};\n\n"
                                               "FnArity " fn-arity-sym " = {FnArityType, -1, " num-args
                                               ", (List *)0, 0, " impl-sym "};\n"
                                               "Function " fn-ptr " = {FunctionType, -1, \"" name
                                               "\", 1, {&" fn-arity-sym "}};\n\n"))
                           return-type (lookup-static-return-type (.c-val evalled) num-args)
                           _ (sm/assoc-in-val (list :static-fns fn-ptr num-args)
                                              {:c-code (c-code impl-sym empty-list empty-list return-type)
                                               :ast ast})]
                       evalled)))]
      evalled)))

(extend-type ast/reify-ast
  Emitter
  (emit-c [ast]
    (comp
     (for [types (sm/get-val :types)
           :let [type-num (inc (count types))]
           _ (sm/assoc-in-val (list :types type-num) type-num)
           reify-fn-index (sm/get-val :reify-fn-index)
           _ (sm/set-val :reify-fn-index 0)
           curr-fn-ptr (sm/get-val :curr-fn-ptr)
           curr-fn-sym (sm/get-val :curr-fn-sym)
           impl-fns (sm/traverse (for [[proto-name impl-fns] (seq (.impls ast))
                                       [fn-name arities] (seq impl-fns)
                                       impl-arity arities]
                                   (list proto-name (list fn-name impl-arity)))
                                 (fn [[proto-name impl-fn]]
                                   (for [impl-fn (emit-reified-fn proto-name type-num impl-fn)
                                         _ (sm/update-in-val (list :reify-fn-index) inc)]
                                     impl-fn)))
           _ (sm/set-val :curr-fn-ptr curr-fn-ptr)
           _ (sm/set-val :curr-fn-sym curr-fn-sym)
           _ (sm/set-val :reify-fn-index reify-fn-index)
           reified-result (let [inits (crush impl-fns .init)]
                            (comp
                             (for [reified-sym (genlocal "reifiedDyn_")
                                   :when (< 0 (count inits))
                                   _ (remember-local reified-sym)]
                               (let [impls-syms (map impl-fns .c-val)]
                                 (c-code reified-sym
                                         (comp inits
                                               (list "Value *" reified-sym " = (Value *)malloc_reified("
                                                     (count impls-syms) ");\n"
                                                     "((ReifiedVal *)" reified-sym ")->type = " type-num ";\n"
                                                     "((ReifiedVal *)" reified-sym ")->implCount = "
                                                     (count impl-fns) ";\n"
                                                     "((ReifiedVal *)" reified-sym ")->typeArgs = (Value *)0;\n")
                                               (flat-map (index impls-syms)
                                                         (fn [[index sym]]
                                                           (list "((ReifiedVal *)" reified-sym
                                                                 ")->impls[" index "] = (Value *)" sym ";\n"))))
                                         (crush impl-fns .decl)
                                         type-num)))

                             (let [reified-sym (gensym "reifiedStatic_")
                                   reified-ptr (gensym "reifiedPtr_")
                                   impl-count (count impl-fns)]
                               (sm/state-maybe
                                (c-code reified-ptr
                                        empty-list
                                        (comp
                                         (crush impl-fns .decl)
                                         (list "ReifiedVal " reified-sym " = {"
                                               type-num ", -1, (Value *)0, 0, {}};\n"
                                               "Value *" reified-ptr " = (Value *)&" reified-sym ";\n"))
                                        type-num)))))]
       reified-result)
     (flat-map (debug :booom)
               (fn [_]
                 (abort))))))

;; TODO: re-factor and clean this up
(extend-type ast/type-ast
  Emitter
  (emit-c [ast]
    (comp
     (for [file-name (sm/get-val :file-name)
           _ (sm/get-in-val (list :modules file-name :types (.name ast)))]
       (let [_ (print-err (str "Trying to re-define type name: '" (.name ast) "' in module '"
                               file-name "'"))]
         (abort)))

     (let [new-type-name (.name ast)
           fields (.fields ast)]
       (for [types (sm/get-val :types)
             ;; TODO: type-val-num needs to be made thread-safe like gen-sym
             :let [type-val-num (+ 2 (count types))]

             _ (sm/assoc-in-val (list :type-names (dec type-val-num)) (str new-type-name))
             type-num-info (comp (sm/get-in-val (list :numbers type-val-num))
                                 (make-static-num type-val-num))
             _ (write-strs (.decl type-num-info))

             ;; make sure the getters are declared
             _ (sm/traverse fields
                            (fn [field]
                              (let [getter-name (str "Getter/." field)]
                                (comp (for [_ (sm/get-in-val (list :protocols getter-name))
                                            _ (sm/assoc-in-val (list :defined-protos (symbol (str "." field)))
                                                               getter-name)]
                                        "")
                                      (let [dispatch-fn-sym (gensym "dispatchFnPtr_")
                                            proto-arity-sym (gensym "protoImpl_")
                                            impls-sym (gensym "protoImpls_")]
                                        (for [_ (sm/assoc-in-val (list :defined-protos (symbol (str "." field)))
                                                                 getter-name)
                                              _ (sm/assoc-in-val (list :protocols getter-name)
                                                                 {:dispatch-sym dispatch-fn-sym
                                                                  :impls-syms {1 impls-sym}
                                                                  :impl-arities {1 {}}})
                                              _ (write-strs (list "ProtoImpls " impls-sym ";\n"))
                                              _ (write-strs (list "Value *" dispatch-fn-sym ";\n"))
                                              _ (sm/assoc-in-val (list :static-fns dispatch-fn-sym 1 :c-code)
                                                                 (c-code proto-arity-sym empty-list
                                                                         empty-list :no-type))
                                              _ (write-strs (list "Value *" proto-arity-sym
                                                                  "(List *closures, Value *arg);\n"))]
                                          ""))))))

             _ (comp (for [def (sm/get-in-val (list :defined-syms new-type-name))
                           _ (sm/assoc-in-val (list :defined-syms new-type-name)
                                              (c-code (.c-val def) empty-list empty-list
                                                      (dec type-val-num)))]
                       (.c-val def))
                     (let [c-name (gensym "var_")]
                       (for [_ (write-strs (list "// forward declaration for '"
                                                 new-type-name "'\n"
                                                 "Value *" c-name ";\n\n"))
                             _ (sm/assoc-in-val (list :defined-syms new-type-name)
                                                (c-code c-name empty-list empty-list
                                                        (dec type-val-num)))]
                         c-name)))
             :let [impls (match fields
                                empty-list (.impls ast)
                                (map (.impls ast)
                                     (fn [impl]
                                       (match impl
                                              |List fn-name args & body|
                                              (let [args-map (reduce args {}
                                                                     (fn [m arg]
                                                                       (assoc m arg '_)))
                                                    fields (map fields (fn [f] (get args-map f f)))]
                                                (list fn-name args
                                                          (list* 'let (list (list (comp fields (list :dont-care))
                                                                                  (list 'type-args (second args))))
                                                                 body)))

                                              impl))))
                   getters (map fields
                                (fn [field]
                                  (list (symbol (str "." field))
                                        (list 'vector 'x)
                                        (list 'let
                                              (list (list (comp fields (list :dont-care))
                                                          '(type-args x)))
                                              field))))]
             type-ast (an/analyze-expr (list 'reify
                                             'Stringable
                                             (list 'string-list (list 'vector '_)
                                                   (list 'list "<TypeCon " (str new-type-name) " ["
                                                         (apply str (interpose fields ", ")) "]>"))
                                             'Type
                                             (list 'instance? (list 'vector '_ 'v)
                                                   (list 'instance? type-val-num 'v))
                                             'Applicative
                                             (list 'apply* (list 'vector '_ 'args)
                                                   (list 'apply 'invoke '_ 'args))
                                             'Function
                                             (list 'invoke (list* 'vector '_ fields)
                                                   (list 'new-type-value
                                                         (list*
                                                          'reify
                                                          'Eq
                                                          (list '=* (list 'vector 'x 'y)
                                                                '(=* (type-args x) (type-args y)))
                                                          'Getter
                                                          (list 'type-name (list 'vector '_)
                                                                (str new-type-name))
                                                          (comp
                                                           getters
                                                           impls))
                                                         (cons 'list fields)))))
             evalled (fr/evaluate type-ast emit-c)

             _ (write-strs (.decl evalled))
             result (define-declared-symbol new-type-name evalled)

             file-name (sm/get-val :file-name)
             _ (sm/assoc-in-val (list :modules file-name :syms new-type-name) result)
             _ (sm/assoc-in-val (list :modules file-name :types new-type-name) type-val-num)
             _ (sm/assoc-in-val (list :defined-types new-type-name) type-val-num)

             _ (sm/update-in-val (list :types)
                                 (fn [types]
                                   (reduce (seq types)
                                           {}
                                           (fn [m [name type-num]]
                                             (match (= type-num type-val-num)
                                                    nothing (assoc m name type-num)
                                                    (assoc m new-type-name type-num))))))]
         result)))))

(extend-type ast/extend-ast
  Emitter
  (emit-c [ast]
    (for [type-num (comp (sm/get-in-val (list :defined-types (.type ast)))
                         (sm/get-in-val (list :types (.type ast)) :no-type))
          _ (sm/traverse (for [[_ proto-impls] (seq (.impls ast))
                               [fn-name arities] (seq proto-impls)
                               impl-arity arities]
                           (list fn-name impl-arity))
                         (fn [[name ast]]
                           ;; TODO: blow up if protocol fn has not been declared yet
                           (for [ext-fn (fr/evaluate ast emit-c)
                                 _ (write-strs (.decl ext-fn))
                                 proto-fn-name (sm/get-in-val (list :defined-protos name))
                                 _ (sm/assoc-in-val (list :protocols proto-fn-name :impl-arities
                                                          (count (.args (.v ast))) type-num :arity-sym)
                                                    (.c-val ext-fn))]
                             "")))]
      (c-code "" empty-list "" :no-type))))

(defn eval-exprs [ast]
  (for [exprs (fr/evaluate ast emit-c)]
    (comp* (c-code "" empty-list empty-list :no-type) exprs)))

(defn unpack-arg-list [list-sym [arg-sym & arg-syms]]
  (let [arg (.c-val arg-sym)]
    (match (comp (for [_ (= arg "")]
                   (list ""))
                 (for [_ (= empty-list arg-syms)]
                   (list "Value *" arg " = (Value *) " list-sym ";\n")))
           |maybe v| v
           (comp (list "Value *" arg
                       " = " list-sym "->head;\n"
                       "if (" list-sym "->tail) " list-sym "->tail->len = " list-sym "->len - 1;\n"
                       list-sym " = " list-sym "->tail;\n")
                 (.init arg-sym)
                 (unpack-arg-list list-sym arg-syms)))))

(defn gen-arg-syms [args]
  (let [last-arg (last args :bogus)]
    (sm/traverse args (fn [arg]
                       (match arg
                         |Keyword|
                         (sm/state-maybe (c-code "" empty-list empty-list :no-type))

                         ;; TODO: test nested list destructuring
                         |List|
                         (for [args (gen-arg-syms arg)
                               c-sym (genlocal "arg")
                               list-sym (genlocal "arg")]
                           (c-code c-sym
                                   (list* "List *" list-sym " = (List *)" c-sym ";\n"
                                          (unpack-arg-list list-sym args))
                                   empty-list
                                   ListType))

                         (for [arg-sym (genlocal "arg")
                               :let [c-sym (match (= arg last-arg)
                                                  |maybe _| (c-code arg-sym empty-list empty-list ListType)
                                            (c-code arg-sym empty-list empty-list :no-type))]
                               _ (sm/assoc-in-val (list :local-syms arg) c-sym)]
                           c-sym))))))

(extend-type ast/binding-ast
  Emitter
  (emit-c [ast]
    (for [evalled (fr/evaluate (.val ast) emit-c)
          result (match (.binding ast)
                        |Symbol|
                        (for [_ (sm/assoc-in-val (list :local-syms (.binding ast))
                                                 (c-code (.c-val evalled) empty-list empty-list
                                                         (.type-num evalled)))]
                          evalled)

                        (for [arg-syms (gen-arg-syms (.binding ast))
                              list-sym (genlocal "arg")]
                          (c-code ""
                                  (comp (.init evalled)
                                        (list "List *" list-sym " = (List *)" (.c-val evalled) ";\n")
                                        (unpack-arg-list list-sym arg-syms))
                                  (.decl evalled)
                                  :no-type)))]
      result)))

(extend-type ast/let-ast
  Emitter
  (emit-c [ast]
    (for [locals (sm/get-val :local-syms)
          bindings (fr/evaluate (.bindings ast) emit-c)
          body-exprs (eval-exprs (.body ast))
          _ (sm/set-val :local-syms locals)]
      (c-code (.c-val body-exprs)
              (comp (crush bindings .init)
                    (.init body-exprs))
              (comp (comp* empty-list (map bindings .decl)) (.decl body-exprs))
              (.type-num body-exprs)))))

(defn eval-cond-clause [cond-result clause]
  (match clause
         |List test-ast value-ast|
         (for [_ (begin-scope)
               test (fr/evaluate test-ast emit-c)
               :let [test-sym (str (.c-val test))]
               _ (sm/assoc-in-val (list :scope-locals test-sym) "")
               test-suffix (sm/get-val :scope-locals)
               _ (begin-scope)
               clause-result (fr/evaluate value-ast emit-c)
               clause-suffix (sm/get-val :scope-locals)]
           (c-code cond-result
                   (comp (.init test)
                         (map (seq test-suffix) second)
                         (list "\nif (" test-sym "->type != nothing_type) {\n"
                               "dec_and_free(" test-sym ");\n")
                         (.init clause-result)
                         (list "incRef(" (.c-val clause-result) ");\n")
                         (list (str cond-result " = " (.c-val clause-result) ";\n"))
                         (map (seq clause-suffix) second)
                         (list "} else {\n"
                               "dec_and_free(" test-sym ");\n"))
                   (comp (.decl test)
                         (.decl clause-result))
                   (.type-num clause-result)))

         (for [_ (begin-scope)
               clause-result (fr/evaluate clause emit-c)
               clause-suffix (sm/get-val :scope-locals)]
           (c-code cond-result
                   (comp (.init clause-result)
                         (list "incRef(" (.c-val clause-result) ");\n")
                         (list cond-result " = " (.c-val clause-result) ";\n")
                         (map (seq clause-suffix) second))
                   (.decl clause-result)
                   (.type-num clause-result)))))

(extend-type ast/cond-ast
  Emitter
  (emit-c [ast]
    (for [cond-result (genlocal "cond")
          scope-info (begin-scope)
          evalled-clauses (sm/traverse (comp (.clauses ast) (list (.default ast)))
                                       (partial eval-cond-clause cond-result))
          _ (end-scope scope-info)
          _ (remember-local cond-result)]
      (let [return-type (match (apply = (map evalled-clauses .type-num))
                               |maybe return-type| return-type
                               :no-type)
            evalled-clauses (apply comp evalled-clauses)]
        (c-code cond-result
                (comp (list "Value *" cond-result ";\n")
                      (.init evalled-clauses)
                      (repeat (count (.clauses ast)) "}\n"))
                (.decl evalled-clauses)
                return-type)))))

(defn expand-match-clauses [match-val-sym type-args-sym clauses]
  (sm/traverse clauses
               (fn [[pattern expr]]
                 (match pattern
                        |List|
                        (let [dont-care (gensym "dont_care_")
                              [[pattern-type & symbols] [_ & literals]]
                              (reduce (reverse pattern)
                                      (list empty-list empty-list)
                                      (fn [[symbols literals] x]
                                        (match x
                                               "&" (list (cons x symbols)
                                                         literals)

                                               |Symbol| (list (cons x symbols)
                                                              (cons dont-care literals))
                                               (list (cons dont-care symbols)
                                                     (cons x literals)))))
                              binding-syms (remove symbols (partial = "&"))
                              binding-syms (match (= (count symbols) (count binding-syms))
                                                  nothing binding-syms
                                                  (comp symbols (list dont-care)))]
                          ;; TODO: could probably use 'some' here
                          (match (remove literals (partial = dont-care))
                                 empty-list
                                 (apply-to list
                                           (an/analyze-expr
                                            (list 'cond
                                                  (list 'instance? pattern-type match-val-sym)
                                                  (list 'let
                                                        (list (list type-args-sym
                                                                    (list 'type-args match-val-sym)))
                                                        (list 'cond (list '< (list 'count type-args-sym)
                                                                          (dec (count binding-syms)))
                                                              'nothing
                                                              'maybe1))

                                                  'nothing))
                                           (for [b (an/analyze-let-binding (list binding-syms
                                                                                 (list 'type-args match-val-sym)))]
                                             (ast/let-expr (list b) (list expr))))

                                 (apply-to list
                                           (let [temp-args (cons (gensym "t-")
                                                                 (map literals (fn [_] (gensym "t-"))))
                                                 lit-checks (map (remove (zip-lists temp-args literals)
                                                                         (fn [[_ literal]]
                                                                           (= literal dont-care)))
                                                                 (partial cons '=))]
                                             (an/analyze-expr (list 'cond
                                                                    (list 'instance? pattern-type match-val-sym)
                                                                    (list 'let
                                                                          (list (list type-args-sym
                                                                                      (list 'type-args match-val-sym)))
                                                                          (list 'cond
                                                                          (list '< (list 'count type-args-sym)
                                                                                (dec (count binding-syms)))
                                                                          'nothing

                                                                          (list 'let (list (list temp-args type-args-sym))
                                                                                ;; TODO: test this!!!
                                                                                (match (count lit-checks)
                                                                                       1 (first lit-checks)
                                                                                       (cons 'and lit-checks)))))

                                                                    'nothing)))
                                           (for [b (an/analyze-let-binding (list binding-syms
                                                                                 (list 'type-args match-val-sym)))]
                                             (ast/let-expr (list b) (list expr))))))

                        (for [test (an/analyze-expr (list '= pattern match-val-sym))]
                          (list test expr))))))

(extend-type ast/match-ast
  Emitter
  (emit-c [ast]
    (let [match-val-sym (gensym "match-val-")
          type-args-sym (gensym "type-args-")]
      (for [expanded-asts (expand-match-clauses match-val-sym type-args-sym (.clauses ast))
            ;; TODO: this just guarantees that "(instance? 'List ...) works
            list-type (sm/get-in-val (list :types 'List))
            _ (an/analyze-expr list-type)
            :let [match-ast (ast/let-expr
                             (list (ast/binding match-val-sym (.value ast)))
                             (list
                              (ast/cond-expr
                               expanded-asts
                               (.default ast))))]
            result (fr/evaluate match-ast emit-c)]
        result))))

(defn get-module-defs []
  (for [syms (sm/get-val :defined-syms)
        types (sm/get-val :defined-types)
        protos (sm/get-val :defined-protos)
        file-name (sm/get-val :file-name)]
    (list syms types protos file-name)))

(defn set-module-defs [defs]
  (match defs
         |List syms types protos file-name|
         (for [current-defs (get-module-defs)
               _ (sm/set-val :defined-syms syms)
               _ (sm/set-val :defined-types types)
               _ (sm/set-val :defined-protos protos)
               _ (sm/set-val :file-name file-name)]
           current-defs)
         (zero sm/state-maybe)))

(defn add-module-info [ns-sym module-name]
  (apply-to (fn [& _]
              (c-code "" empty-list empty-list :no-type))
            (for [new-mod-syms (sm/get-in-val (list :modules module-name :syms))
                  _ (sm/traverse (seq new-mod-syms)
                                 (fn [[sym def]]
                                   (sm/assoc-in-val (list :defined-syms (symbol (str ns-sym "/" sym))) def)))]
              "")
            (comp (for [new-mod-protos (sm/get-in-val (list :modules module-name :protos))
                        _ (sm/traverse (seq new-mod-protos)
                                       (fn [[proto def]]
                                         (let [proto-sym (symbol (str ns-sym "/" proto))]
                                           (for [dispatch-fn-sym (sm/get-in-val (list :protocols def :dispatch-sym))
                                                 _ (sm/assoc-in-val (list :defined-protos proto-sym) def)
                                                 _ (sm/assoc-in-val (list :defined-syms proto-sym)
                                                                    (c-code dispatch-fn-sym empty-list
                                                                            empty-list FunctionType))]
                                             ""))))]
                    "")
                  (sm/state-maybe ""))
            (comp (for [new-mod-types (sm/get-in-val (list :modules module-name :types))
                        _ (sm/traverse (seq new-mod-types)
                                       (fn [[type def]]
                                         (sm/assoc-in-val (list :defined-types (symbol (str ns-sym "/" type))) def)))]
                    "")
                  (sm/state-maybe ""))))

(extend-type ast/add-ns-ast
  Emitter
  (emit-c [ast]
    (let [module-name (.const-str (.v (first (.asts ast))))]
      (comp
       (add-module-info (.ns-sym ast) module-name)
       (for [core-defs (sm/get-val :core-defs)
             current-defs (set-module-defs core-defs)
             _ (sm/set-val :file-name module-name)
             _ (sm/traverse (rest (.asts ast)) (fn [ast] (fr/evaluate ast emit-c)))
             _ (set-module-defs current-defs)
             result (add-module-info (.ns-sym ast) module-name)]
         result)
       (sm/state-maybe (c-code "" empty-list empty-list :no-type))))))

(extend-type ast/main-ast
  Emitter
  (emit-c [ast]
    (let [main-sym (gensym "main_")]
      (for [_ (sm/set-val :main-sym main-sym)
            arg-syms (gen-arg-syms (.args ast))
            _ (sm/set-val :local-sym-count 0)
            scope-info (begin-scope)
            body (eval-exprs (.body ast))
            _ (write-strs (.decl body))
            _ (write-strs (list "\nint " main-sym " ("))
            _ (write-strs (interpose (map arg-syms (fn [arg] (str "Value *" (.c-val arg))))
                                     ", "))
            _ (write-strs (cons ") {\n" (.init body)))
            scope-locals (for [scope-locals (sm/get-val :scope-locals)]
                           (map (seq scope-locals) second))
            _ (write-strs scope-locals)
            _ (write-strs (list "\nreturn(0);\n}\n\n"))]
        (c-code "" empty-list empty-list :no-type)))))

(extend-type ast/fn-ast
  Emitter
  (emit-c [ast]
    (let [fn-sym (gensym "fn_")
          fn-ptr-sym (gensym "fnPtr_")
          fn-name (.sym (.v (.fn-name ast)))]
      (for [curr-fn-sym (sm/get-val :curr-fn-sym)
            curr-fn-ptr (sm/get-val :curr-fn-ptr)
            _ (sm/assoc-in-val (list :deref-pointers fn-ptr-sym) fn-sym)
            _ (sm/set-val :curr-fn-sym fn-sym)
            _ (sm/set-val :curr-fn-ptr fn-ptr-sym)
            _ (write-strs (list "\n// --------- " fn-name " --------------\n"
                                "Function " fn-sym ";\n"
                                "Value *" fn-ptr-sym ";\n"))
            _ (remember-local fn-ptr-sym)
            _ (comp (for [def (sm/get-in-val (list :defined-syms fn-name))
                          :when (match (= 'anon fn-name)
                                       nothing maybe1
                                       nothing)
                          _ (update-startup-init (list (.c-val def) " = " fn-ptr-sym ";\n"))]
                      "")
                    (sm/state-maybe ""))
            ;; TODO: check for anon fn, save previous value of
            ;; :defined-syms and restore at end
            _ (sm/assoc-in-val (list :defined-syms fn-name)
                               (c-code fn-ptr-sym empty-list empty-list FunctionType))
            arity-vals (fr/evaluate (.arities ast) emit-c)
            :let [arity-count (count arity-vals)
                  arity-syms (map arity-vals .c-val)
                  arity-init (crush arity-vals .init)
                  arity-decl (crush arity-vals .decl)]
            result (match arity-init
                          empty-list (for [_ (sm/assoc-in-val (list :scope-locals fn-ptr-sym) "")]
                                       (c-code fn-ptr-sym
                                               empty-list
                                               (comp arity-decl
                                                     (list "\n// --------- " fn-name " main body --------------\n"
                                                           "Function " fn-sym " = {FunctionType, -1, \""
                                                           fn-name "\", " arity-count ", "
                                                           "{" (apply str (interpose arity-syms ", ")) "}};\n"
                                                           "Value *" fn-ptr-sym " = (Value *)&" fn-sym ";\n\n"))
                                               FunctionType))
                          (sm/state-maybe
                           (c-code fn-ptr-sym
                                   (comp arity-init
                                         (list "Function *" fn-sym " = malloc_function(" arity-count ");\n"
                                               fn-sym "->type = FunctionType;\n"
                                               fn-sym "->name = \"" fn-name "\";\n"
                                               fn-sym "->arityCount = " arity-count ";\n"
                                               "Value *" fn-ptr-sym " = (Value *)" fn-sym ";\n\n")
                                         (map (range arity-count)
                                              (fn [index]
                                                (str fn-sym "->arities[" index "] = "
                                                     (nth arity-syms index "") ";\n"))))
                                   arity-decl
                                   FunctionType)))
            _ (sm/set-val :curr-fn-sym curr-fn-sym)
            _ (sm/set-val :curr-fn-ptr curr-fn-ptr)]
        result))))

(defn reset-fn-context [arity-fn-sym num-args]
  (for [locals (sm/get-val :local-syms)
        _ (sm/set-val :local-syms {})
        local-sym-count (sm/get-val :local-sym-count)
        _ (sm/set-val :local-sym-count 0)
        context (sm/get-val :context)
        _ (sm/set-val :context (comp context locals))
        closed-over (sm/get-val :closed-over)
        _ (sm/set-val :closed-over empty-list)
        curr-arity-fn-sym (sm/get-val :curr-arity-fn-sym)
        _ (sm/set-val :curr-arity-fn-sym arity-fn-sym)
        curr-arg-count (sm/get-val :curr-arg-count)
        _ (sm/set-val :curr-arg-count num-args)]
    (list locals local-sym-count context closed-over
          curr-arity-fn-sym curr-arg-count)))

(defn restore-fn-context [[locals local-sym-count context closed-over curr-arity-fn-sym curr-arg-count]]
  (apply-to list
            (sm/set-val :context context)
            (sm/set-val :local-syms locals)
            (sm/set-val :local-sym-count local-sym-count)
            (sm/set-val :closed-over closed-over)
            (sm/set-val :curr-arity-fn-sym curr-arity-fn-sym)
            (sm/set-val :curr-arg-count curr-arg-count)))

(defn emit-closures []
  (for [closures (sm/get-val :closed-over)]
    (flat-map (reverse closures)
                                (fn [[closure]]
                                  (list "Value *" closure
                                        " = closures->head;\n"
                                        "if (closures->tail)\nclosures->tail->len = closures->len - 1;\n"
                                        "closures = closures->tail;\n")))))

(defn closures-init [arity-sym closures]
  (for [closure-syms (sm/traverse (map closures second) lookup-sym)
        :when (m-first closures)]
    (reduce (reverse closure-syms) empty-list
            (fn [closed-over sym]
              (let [c-sym (.c-val sym)]
                (list* "incRef((Value *)" c-sym ");\n"
                       arity-sym "->closures = listCons((Value *)"
                       c-sym ", (List *)" arity-sym "->closures);\n"
                       closed-over))))))

;; TODO: combine with fn-arity-ast. gen-arg-syms can put stuff in .init
(extend-type ast/variadic-arity-ast
  Emitter
  (emit-c [ast]
    (let [arity-fn-sym (gensym "arityImpl_")]
      (for [fn-context (reset-fn-context arity-fn-sym (count (.args ast)))
            arg-syms (gen-arg-syms (.args ast))
            scope-info (begin-scope)
            body-exprs (eval-exprs (.body ast))
            closures (emit-closures)
            locals (free-scope-locals (.c-val body-exprs))
            :let [decl (comp (.decl body-exprs)

                             (list "Value *" arity-fn-sym "(List *closures, Value *varArgs) {\n"
                                   "List *argsList = (List *)varArgs;\n")
                             (unpack-arg-list "argsList" arg-syms)
                             closures
                             (comp* empty-list (map arg-syms .init))
                             (.init body-exprs)
                             locals
                             ;; TODO: this is silly. every fn should return a value
                             (match (= (.c-val body-exprs) "")
                                    |maybe _| ""
                                    (list "return(" (.c-val body-exprs) ");\n"))
                             (list "};\n\n"))]
            _ (end-scope scope-info)
            closures (sm/get-val :closed-over)
            _ (restore-fn-context fn-context)
            result (comp
                    (for [arity-sym (genlocal "arity_")
                          closed-over (closures-init arity-sym closures)]
                      (c-code arity-sym
                              (list* "FnArity *" arity-sym " = malloc_fnArity();\n"
                                     arity-sym "->type = FnArityType;\n"
                                     arity-sym "->count = 2;\n"
                                     arity-sym "->closures = empty_list;\n"
                                     arity-sym "->variadic = 1;\n"
                                     arity-sym "->fn = " arity-fn-sym ";\n"
                                     closed-over)
                              decl
                              FnArityType))

                    (for [fn-ptr-sym (sm/get-val :curr-fn-ptr)
                          _ (sm/assoc-in-val (list :static-fns fn-ptr-sym :variadic)
                                             {:c-code (c-code arity-fn-sym empty-list
                                                              empty-list (.type-num body-exprs))
                                              :ast (fr/free ast)})]
                      (let [arity-ptr (gensym "fnArity_")]
                        (c-code (str "&" arity-ptr)
                                empty-list
                                (comp decl
                                      (list "FnArity " arity-ptr  " = {FnArityType, -1, 2, (List *)0, 1, "
                                            arity-fn-sym "};\n"))
                                FnArityType))))]
        result))))

(extend-type ast/fn-arity-ast
  Emitter
  (emit-c [ast]
    (let [arity-fn-sym (gensym "arityImpl_")
          args (.args ast)
          arg-count (count args)]
      (for [fn-context (reset-fn-context arity-fn-sym arg-count)
            arg-syms (gen-arg-syms (comp args (list :no-tail)))
            :let [arg-syms (remove arg-syms (fn [arg] (= "" (.c-val arg))))]
            scope-info (begin-scope)
            body-exprs (eval-exprs (.body ast))
            closures (emit-closures)
            locals (free-scope-locals (.c-val body-exprs))
            :let [decl (comp (.decl body-exprs)
                             (list "Value *" arity-fn-sym "(")
                             (interpose (cons "List *closures"
                                              (map arg-syms (fn [arg] (str "Value *" (.c-val arg)))))
                                        ", ")
                             (list ") {\n")
                             closures
                             (comp* empty-list (map arg-syms .init))
                             (.init body-exprs)
                             locals
                             ;; TODO: this is silly. every fn should return a value
                             (match (= (.c-val body-exprs) "")
                                    |maybe _| ""
                                    (list "return(" (.c-val body-exprs) ");\n"))
                             (list "};\n\n"))]
            _ (end-scope scope-info)
            closures (sm/get-val :closed-over)
            _ (restore-fn-context fn-context)
            result (comp (for [arity-sym (genlocal "arity_")
                               closed-over (closures-init arity-sym closures)]
                           (c-code arity-sym
                                   (list* "FnArity *" arity-sym " = malloc_fnArity();\n"
                                          arity-sym "->type = FnArityType;\n"
                                          arity-sym "->count = " (str arg-count) ";\n"
                                          arity-sym "->closures = empty_list;\n"
                                          arity-sym "->variadic = 0;\n"
                                          arity-sym "->fn = " arity-fn-sym ";\n"
                                          closed-over)
                                   decl
                                   FnArityType))

                         (for [fn-ptr-sym (sm/get-val :curr-fn-ptr)
                               _ (sm/assoc-in-val (list :static-fns fn-ptr-sym arg-count)
                                                  {:c-code (c-code arity-fn-sym empty-list
                                                                   empty-list (.type-num body-exprs))
                                                   :ast (fr/free ast)})]
                           (let [arity-sym (gensym "fnArity_")]
                             (c-code (str "&" arity-sym)
                                     empty-list
                                     (comp decl
                                           (list "FnArity " arity-sym  " = {FnArityType, -1, "
                                                 arg-count ", (List *)0, 0, " arity-fn-sym "};\n"))
                                     FnArityType))))]
        result))))

(defn call-instance? [ast args]
  (let [type-val (.type-num (second args))]
    (match type-val
           :no-type (zero sm/state-maybe)
           (match ast
                  |ast/call-ast callee args|
                  (match callee
                         |fr/free target-ast|
                         (match target-ast
                                |ast/symbol-ast 'instance?|
                                (match args
                                       |fr/free-app _ arg-asts|
                                       ;; TODO: 'type-sym' is not general enough.
                                       (let [type-sym (.sym (.v (first arg-asts)))]
                                         (for [instance-type (sm/get-in-val (list :types type-sym))
                                               :when (= instance-type type-val)]
                                           (c-code "true", empty-list, empty-list, Number)))
                                       (zero sm/state-maybe))
                                (zero sm/state-maybe))
                         (zero sm/state-maybe))
                  (zero sm/state-maybe)))))

(defn call-invoke [target args]
  (for [arity-info (lookup-proto-arity 'invoke (inc (count args)) (.type-num target))
        result-sym (genlocal "rslt")
        _ (remember-local result-sym)]
    (c-code result-sym
            (comp (list "Value *" result-sym " = " (.c-val arity-info) "(")
                  (interpose (cons "empty_list" (map (cons target args) .c-val)) ", ")
                  (list ");\n"))
            empty-list
            (.type-num arity-info))))

(defn call-proto-impl [target-ast args]
  (match args
         |List dispatch-val|
         (match target-ast
                |fr/free target|
                (match target
                       |ast/symbol-ast name|
                       (comp
                        (for [arity-info (lookup-proto-arity name (count args) (.type-num dispatch-val))
                              result-sym (genlocal "rslt")
                              _ (remember-local result-sym)]
                          (let [return-type (.type-num arity-info)
                                return-type (match return-type
                                                   ;; TODO: these should be the result of
                                                   ;; asserts on the protocol fn defs
                                                   :no-type (match name
                                                                   |Symbol 'map| (.type-num dispatch-val)
                                                                   |Symbol 'map| (.type-num dispatch-val)
                                                                   |Symbol 'comp*| (.type-num dispatch-val)
                                                                   |Symbol 'comp| (.type-num dispatch-val)
                                                                   |Symbol 'flat-map| (.type-num dispatch-val)
                                                                   :no-type)
                                                   return-type)
                                arg-syms (cons "empty_list" (map args .c-val))]
                            (c-code result-sym
                                    (comp (list "Value *" result-sym " = " (.c-val arity-info) "(")
                                          (interpose arg-syms ", ")
                                          (list ");\n"))
                                    empty-list
                                    return-type)))
                        (for [qualified-name (sm/get-in-val (list :defined-protos name))
                              impls-sym (sm/get-in-val (list :protocols qualified-name :impls-syms (count args)))
                              result-sym (genlocal "rslt")
                              _ (remember-local result-sym)]
                          (c-code result-sym
                                  (comp (list "Value *" result-sym " = proto" (count args) "Arg(&"
                                              impls-sym ", \"" qualified-name "\", ")
                                        (interpose (map args .c-val) ", ")
                                        (list ");\n"))
                                  empty-list
                                  :no-type)))
                       (zero sm/state-maybe))
                (zero sm/state-maybe))
         (zero sm/state-maybe)))

(defn call-static-fixed [target arg-syms]
  (for [arity-info (lookup-static-arity (.c-val target) (count arg-syms))
        result-sym (genlocal "rslt")
        _ (remember-local result-sym)]
    (c-code result-sym
            (list "Value *" result-sym " = " (.c-val arity-info) "("
                  (apply str (interpose (cons "empty_list" arg-syms) ", ")) ");\n")
            empty-list
            (.type-num arity-info))))

(defn call-static-variadic [target args]
  (for [arity-info (lookup-static-arity (.c-val target) :variadic)
        variadic-sym (genlocal "varArgs")
        result-sym (genlocal "rslt")
        _ (remember-local result-sym)]
    (c-code result-sym
            (comp (list "List *" variadic-sym " = empty_list;\n")
                  (map (reverse args)
                       (fn [arg]
                         (let [arg-sym (.c-val arg)]
                           (str "incRef((Value *)" arg-sym ");\n"
                                variadic-sym " = (List *)listCons("
                                "(Value *)" arg-sym
                                ", " variadic-sym ");\n"))))
                  (list "Value *" result-sym " = " (.c-val arity-info) "(empty_list, (Value *)"
                        variadic-sym ");\n"
                        "dec_and_free((Value *)" variadic-sym ");\n"))
            empty-list
            (.type-num arity-info))))

(defn call-dyn-fn-value [target args]
  (for [arity-sym (genlocal "arity")
        :when (= FunctionType (.type-num target))
        variadic-sym (genlocal "varArgs")
        fn-sym (genlocal "fn")
        result-sym (genlocal "rslt")
        _ (remember-local result-sym)]
    (let [args (map args .c-val)
          arg-syms (cons (str arity-sym "->closures") args)
          num-args (count args)]
      (c-code result-sym
              (comp (list "Value *" result-sym ";\n"
                          "FnArity *" arity-sym " = findFnArity(" (.c-val target)
                          ", " num-args ");\n"
                          "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) {\n"
                          "FnType" num-args " *" fn-sym " = (FnType" num-args " *)"
                          arity-sym "->fn;\n"
                          result-sym " = " fn-sym "(" (apply str (interpose arg-syms ", ")) ");\n"
                          "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) {\n"
                          "FnType1 *" fn-sym " = (FnType1 *)" arity-sym "->fn;\n"
                          "List *" variadic-sym " = empty_list;\n")
                    (map (reverse (cdr arg-syms))
                         (fn [arg-sym]
                           (str "incRef(" arg-sym ");\n"
                                variadic-sym " = (List *)listCons("
                                arg-sym ", " variadic-sym ");\n")))
                    (list result-sym " = " fn-sym "(" (car arg-syms) ", (Value *)"
                          variadic-sym ");\n"
                          "dec_and_free((Value *)" variadic-sym ");\n"
                          "} else {\nfprintf(stderr, \"\\n*** no arity found for '%s'.\\n\", "
                          "((Function *)" (.c-val target) ")->name"
                          ");\n  abort();\n}\n"))
              empty-list
              :no-type))))

(defn call-dyn-unknown-type [target args target-ast]
  (let [num-args (count args)
        call-target (match args
                           empty-list ""
                           (match target-ast
                                  |fr/free target|
                                  (match target
                                         |ast/symbol-ast target-sym| (str target-sym)
                                         "")
                                  ""))]
    (for [arity-sym (genlocal "arity")
          variadic-sym (genlocal "varArgs")
          fn-sym (genlocal "fn")
          result-sym (genlocal "rslt")
          _ (remember-local result-sym)
          invoke-arity-sym (lookup-fn-arity 'invoke (inc num-args))]
      (let [args (map args .c-val)
            arg-syms (cons (str arity-sym "->closures") args)]
        (c-code result-sym
                (comp (list "Value *" result-sym ";\n"
                            "// call to '" call-target "'\n"
                            "if((" (.c-val target) ")->type != FunctionType) {\n"

                            result-sym " = " invoke-arity-sym "(empty_list, "
                            (apply str (interpose (cons (.c-val target) args) ", "))
                            ");\n} else {\n"

                            "FnArity *" arity-sym " = findFnArity(" (.c-val target) ", " num-args ");\n"
                            "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) {\n"
                            "FnType" num-args " *" fn-sym " = (FnType" num-args " *)" arity-sym "->fn;\n"
                            result-sym " = " fn-sym "(" (apply str (interpose arg-syms ", ")) ");\n"
                            "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) {\n"
                            "FnType1 *" fn-sym " = (FnType1 *)" arity-sym "->fn;\n"
                            "List *" variadic-sym " = empty_list;\n")
                      (map (reverse (cdr arg-syms))
                           (fn [arg-sym]
                             (str "incRef(" arg-sym ");\n"
                                  variadic-sym " = (List *)listCons("
                                  arg-sym ", " variadic-sym ");\n")))
                      (list result-sym " = " fn-sym "(" (car arg-syms) ", (Value *)" variadic-sym ");\n"
                            "dec_and_free((Value *)" variadic-sym ");\n"
                            "} else {\nfprintf(stderr, \"\\n*** no arity found for '%s'.\\n\", "
                            "((Function *)" (.c-val target) ")->name"
                            ");\n  abort();\n}\n}\n"))
                empty-list
                :no-type)))))

(extend-type ast/call-ast
  Emitter
  (emit-c [ast]
    (for [target (fr/evaluate (.callee ast) emit-c)
          args (match (.args (.params ast))
                      empty-list (sm/state-maybe empty-list)
                      (fr/evaluate (.params ast) emit-c))
          _ (sm/update-in-val (list :call-site-count :total) inc)
          call-site (comp
                     ;; (match args
                     ;;             |List _ _| (call-instance? ast args)
                     ;;             (zero sm/state-maybe))
                          (call-proto-impl (.callee ast) args)
                          (call-static-fixed target (map args .c-val))
                          (call-static-variadic target args)
                          (call-invoke target args)
                          (call-dyn-fn-value target args)
                          ;; TODO: use this
                          (for [;; _ (debug :calling (.callee ast) (.type-num target))
                                _ (sm/update-in-val (list :call-site-count :generic) inc)
                                r (call-dyn-unknown-type target args (.callee ast))]
                            r)
                          (map (sm/state-maybe (list target ast))
                               (fn [[target ast]]
                                 (print-err (str "could not emit callsite for '"
                                                 (fr/evaluate (.callee ast) string-list)
                                                 "'"))
                                 (print-err :target (.c-val target))
                                 (abort))))]
      (comp (comp* target args) call-site))))

(defn emit-proto-arity [proto-name fn-ptr-sym proto-impls [num-args impls]]
  (let [impls-sym (match (get-in proto-impls (list :impls-syms num-args))
                         |maybe sym| sym
                         (gensym "protoImpls_"))
        arity-sym (gensym "protoFnArity_")
        args (map (range num-args) (partial str "arg"))]
    (for [arity-info (lookup-static-arity fn-ptr-sym num-args)
          :let [c-sym (.c-val arity-info)]
          _ (write-strs (list "\n// " proto-name " " num-args " args\n"
                              "ProtoImpls " impls-sym " = {"
                              (count impls) ", {"))
          _ (write-strs (interpose (map (seq impls)
                                        (fn [[type-num impl-sym]]
                                          (str "{" type-num ", (Value *)"
                                               (get impl-sym :arity-sym "") "}")))
                                   ", "))
          _ (write-strs (list "}};\n"))
          _ (write-strs (list "Value *" c-sym "("))
          _ (write-strs (interpose (cons "List *closures"
                                         (map args (fn [arg] (str "Value *" arg))))
                                   ", "))
          _ (write-strs
             (list ") {\n"
                   "  return(proto" num-args "Arg(&" impls-sym ", \"" proto-name "\", "))
          _ (write-strs (interpose args ", "))
          _ (write-strs (list "));\n}\n"
                              "FnArity " arity-sym " = {FnArityType, -1, "
                              num-args ", (List *)0, 0, " c-sym "};\n"))]
      (str "&" arity-sym))))

(defn finalize-protocols []
  (for [protocols (sm/get-val :protocols)
        _ (sm/traverse
           (seq protocols)
           (fn [[proto-name proto-impls]]
             (match (m-get proto-impls :dispatch-sym)
                    |maybe dispatch-fn-sym|
                    (let [fn-sym (gensym "protoFn_")]
                      (for [arity-syms (match (m-get proto-impls :impl-arities)
                                              |maybe impls-map|
                                              (sm/traverse (seq impls-map)
                                                           (partial emit-proto-arity proto-name
                                                                    dispatch-fn-sym proto-impls))
                                              (zero sm/state-maybe))
                            _ (write-strs (list "Function " fn-sym " = {FunctionType, -1, \""
                                                proto-name "\", " (count arity-syms) ", {"))
                            _ (write-strs (interpose arity-syms ", "))
                            _ (write-strs (list "}};\n" "Value *" dispatch-fn-sym
                                                " = (Value *)&" fn-sym ";\n\n"))]
                        ""))
                    (zero sm/state-maybe))))]
    ""))

(defn emit-main []
  (for [_ (sm/set-val :local-sym-count 0)
        main-sym (sm/get-val :main-sym)
        _ (finalize-protocols)
        _ (write-strs (list "\nint main(int argc, char *argv[]) {\n"))
        start-up-init (sm/get-val :startup-init)
        _ (sm/traverse (reverse start-up-init) write-strs)
        nothing-info (lookup-sym 'nothing)
        _ (write-strs (list "     nothing = " (.c-val nothing-info) ";\n"
                            "     maybe1 = maybe((List *)0, (Value *)0, numPtr0);\n"
                            "     maybe1->refs = -1;\n"
                            "     outStream = stdout;\n"
                            "     List *argList = malloc_list();\n"
                            "      argList->type = ListType;\n"
                            "      argList->len = 0;\n"
                            "      argList->head = (Value *)0;\n"
                            "      argList->tail = (List *)0;\n"
                            "      List *tail = argList;\n"
                            "      for(int i = 0; i < argc; i++) {\n"
                            "         List *newTail = malloc_list();\n"
                            "         newTail->type = ListType;\n"
                            "         newTail->len = 0;\n"
                            "         newTail->tail = (List *)0;\n"
                            "         newTail->head = (Value *)0;\n"
                            "         tail->head = stringValue(argv[i]);\n"
                            "         tail->tail = newTail;\n"
                            "         tail = newTail;\n"
                            "         argList->len++;\n}\n"
                            "  int the_final_answer = " main-sym "((Value *)argList);\n"
                            "  maybe1->refs = 1;\n"
                            "  dec_and_free(maybe1);\n"
                            "  decRef((Value *)argList);\n"
                            "  dec_and_free((Value *)argList);\n"
                            "  for (int i = 0; i < 10; i++) {\n"
                            "    for(DirectLL *item = freeFunctions[i]; item != (DirectLL *)0; item =  item->next) {\n"
                            "      free_count++;\n"
                            "    }\n}\n"
                            "  for (int i = 0; i < 20; i++) {\n"
                            "    for(DirectLL *item = freeReified[i]; item != (DirectLL *)0; item =  item->next) {\n"
                            "      free_count++;\n"
                            "    }\n}\n"
                            "  for (int i = 0; i < 20; i++) {\n"
                            "    for(DirectLL *item = freeBMINodes[i]; item != (DirectLL *)0; item =  item->next) {\n"
                            "      free_count++;\n"
                            "    }\n}\n"
                            "  for(DirectLL *item = freeNumbers; item != (DirectLL *)0; item =  item->next) {\n"
                            "    free_count++;\n"
                            "  }\n"
                            "  for(DirectLL *item = freeArrayNodes; item != (DirectLL *)0; item =  item->next) {\n"
                            "    free_count++;\n"
                            "  }\n"
                            "  for(DirectLL *item = freeFnArities; item != (DirectLL *)0; item =  item->next) {\n"
                            "    free_count++;\n"
                            "  }\n"
                            "  for(DirectLL *item = freeLists; item != (DirectLL *)0; item =  item->next) {\n"
                            "    free_count++;\n"
                            "  }\n"
                            "  for(DirectLL *item = freeSubStrings; item != (DirectLL *)0; item =  item->next) {\n"
                            "    free_count++;\n"
                            "  }\n"
                            "  fprintf(stderr, \"malloc count: %lld  free count: %lld  diff: %lld\\n\""
                            ", malloc_count, free_count, malloc_count - free_count);\n"
                            "  if (malloc_count - free_count != 0)\n"
                            "     return(1);"
                            "  else\n"
                            "    return(the_final_answer);\n};\n"))
        _ (write-strs (list "int64_t nothing_type = " (.type-num nothing-info) ";\n"))

        proto-name (sm/get-in-val (list :defined-protos 'type-name))
        dispatch-fn-sym (sm/get-in-val (list :protocols proto-name :dispatch-sym))
        arity-info (lookup-static-arity dispatch-fn-sym 1)
        _ (write-strs (list "Value *(*type_name)(List *, Value *) = "
                            (.c-val arity-info) ";\n"))

        proto-name (sm/get-in-val (list :defined-protos 'invoke))
        dispatch-fn-sym (sm/get-in-val (list :protocols proto-name :dispatch-sym))
        arity-info (lookup-static-arity dispatch-fn-sym 2)
        _ (write-strs (list "Value *(*invoke1Arg)(List *, Value *, Value*) = "
                            (.c-val arity-info) ";\n"))

        proto-name (sm/get-in-val (list :defined-protos 'assoc*))
        dispatch-fn-sym (sm/get-in-val (list :protocols proto-name :dispatch-sym))
        arity-info (lookup-static-arity dispatch-fn-sym 5)
        _ (write-strs (list "Value *(*assoc)(List *, Value*, Value*, Value*, Value*, Value*) = "
                            (.c-val arity-info) ";\n"))

        proto-name (sm/get-in-val (list :defined-protos 'get*))
        dispatch-fn-sym (sm/get-in-val (list :protocols proto-name :dispatch-sym))
        arity-info (lookup-static-arity dispatch-fn-sym 5)
        _ (write-strs (list "Value *(*get)(List *, Value*, Value*, Value*, Value*, Value*) = "
                            (.c-val arity-info) ";\n"))

        proto-name (sm/get-in-val (list :defined-protos 'sha1))
        dispatch-fn-sym (sm/get-in-val (list :protocols proto-name :dispatch-sym))
        arity-info (lookup-static-arity dispatch-fn-sym 1)
        _ (write-strs (list "Value *(*sha1)(List *, Value*) = "
                            (.c-val arity-info) ";\n"))

        proto-name (sm/get-in-val (list :defined-protos 'hash-seq))
        dispatch-fn-sym (sm/get-in-val (list :protocols proto-name :dispatch-sym))
        arity-info (lookup-static-arity dispatch-fn-sym 2)
        _ (write-strs (list "Value *(*hashSeq)(List *, Value*, Value*) = "
                            (.c-val arity-info) ";\n"))

        proto-name (sm/get-in-val (list :defined-protos 'count))
        dispatch-fn-sym (sm/get-in-val (list :protocols proto-name :dispatch-sym))
        arity-info (lookup-static-arity dispatch-fn-sym 1)
        _ (write-strs (list "Value *(*count)(List *, Value*) = "
                            (.c-val arity-info) ";\n"))

        arity-info (lookup-fn-arity '=* 2)
        _ (write-strs (list "Value *(*equal_star)(List *, Value*, Value*) = " arity-info ";\n"))

        maybe-info (lookup-sym 'maybe)
        arity-info (lookup-proto-arity 'invoke 2 (.type-num maybe-info))
        _ (write-strs (list "Value *(*maybe)(List *, Value*, Value*) = " (.c-val arity-info) ";\n"))
        ]
    ""))

(defn compile-module [parser src-file-name]
  (apply-to list
            ;; (sm/set-val :text (fio/file-stream (fio/fopen-read src-file)))
            (sm/set-val :text (slurp src-file-name))
            (sm/recur (for [expr parser
                            ast (an/analyze-expr expr)
                            emitted (fr/evaluate ast emit-c)
                            _ (write-strs (.init emitted))]
                        ""))))

(defn compile-file [src-file-name]
  (let [parser (for [[p] (fr/evaluate (grmr/read-form) parser/recursive-descent)]
                 p)
        compiling-fn (comp (apply-to list
                                     (sm/set-val :file-name "")
                                     (sm/set-val :line-num 0)
                                     (compile-module parser "core.toc")
                                     (for [core-defs (get-module-defs)
                                           _ (sm/set-val :core-defs core-defs)]
                                       "")
                                     (sm/set-val :file-name src-file-name)
                                     (sm/set-val :line-num 0)
                                     (compile-module parser src-file-name)
                                     (emit-main)
                                     (for [call-sites (sm/get-val :call-site-count)
                                           _ (debug :call-sites
                                                    :total (:total call-sites)
                                                    :inst? (:inst? call-sites)
                                                    :invoke (:invoke call-sites)
                                                    :proto (:proto call-sites)
                                                    :fixed (:fixed call-sites)
                                                    :var (:var call-sites)
                                                    :dyn-fn (:dyn-fn call-sites)
                                                    :generic (:generic call-sites))]
                                       ""))
                           (map (sm/get-val :line-num) (fn [line]
                                                         (print-err "compilation failed " line)
                                                         (abort)))
                           (map (sm/state-maybe "don't know where") (fn [line]
                                                         (print-err "compilation failed " line)
                                                         (abort))))
        types {'String StringType
               'Number NumberType
               'Function FunctionType
               'List ListType
               'Keyword KeywordType
               'SubStr SubStringType
               'Symbol SymbolType
               'FnArity FnArityType
               'Opaque OpaqueType
               'BitmapIndexedNode BitmapIndexedType
               'ArrayNode ArrayNodeType
               'HashCollisionNode HashCollisionNodeType}
        type-names {StringType "String"
                    NumberType "Number"
                    FunctionType "Function"
                    ListType "List"
                    KeywordType "Keyword"
                    SubStringType "SubStr"
                    SymbolType "Symbol"
                    FnArityType "FnArity"
                    OpaqueType "Opaque"
                    BitmapIndexedType "BitmapIndexedNode"
                    ArrayNodeType "ArrayNode"
                    HashCollisionNodeType "HashCollisionNode"}
        init-state {:debug-on :any-value
                    :parser parser
                    :abort? 1
                    :expr empty-list
                    :static-strings {}
                    :str-count 0
                    :numbers {}
                    :num-count 0
                    :symbols {}
                    :sym-count 0
                    :keywords {}
                    :kw-count 0
                    :new-strings {}
                    :new-numbers {}
                    :new-symbols {}
                    :new-keywords {}
                    :scope-locals {}
                    :types types
                    :type-names type-names
                    :curr-fn-sym :no-fn
                    :curr-fn-ptr :no-fn
                    :defined-syms (reduce (seq types) {}
                                          (fn [ts [type-name _]]
                                            (assoc ts
                                              type-name (c-code (str type-name "TypeNum")
                                                                empty-list empty-list NumberType))))
                    :static-fns {}
                    :context {}
                    :local-syms {}
                    :local-sym-count 0
                    :closed-over empty-list
                    :curr-arity-fn-sym 'no-sym
                    :curr-arg-count 0
                    :startup-init empty-list
                    :reify-fn-index 0
                    :deref-pointers {}
                    :protocols {}

                    :call-site-count {:total 0
                                      :inst? 0
                                      :invoke 0
                                      :proto 0
                                      :fixed 0
                                      :var 0
                                      :dyn-fn 0
                                      :generic 0}
                    }]
    (compiling-fn init-state)
    ;; (fio/close-stream text)
    ))

(main [arg-list]
      (match arg-list
             |List _ src-file| (compile-file src-file)
             (print-err "Please provide a Toccata file to compile.")))
