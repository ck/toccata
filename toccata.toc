
;; TODO:
;; match constant values
;; implement to-be-freed lists
;; problem in multi-arity defn when one arity has no args
;; test memory exhaustion handling
;; optimize away instance? calls
;; remove booleans where possible
;; implements?
;; REPL
;; fn meta data; doc strings and ast
;; macro system
;; destructuring of maps and deftypes
;; destructuring in let bindings
;; green threads
;; async
;; dependencies
;; persistent data structures; vectors, hash-sets
;; supercompilation
;; FFI
;; Android/iOS
;; native arrays
;; linear algebra
;; compact lists cdr coding

;; Optimization hints:
;; eliminate closed-over syms from flat-map, wrap impls

(toccata-core "core.toc")

(add-ns sm (module "core/state-maybe.toc"))
(add-ns fr (module "core/free.toc"))
(add-ns parser (module "core/parser.toc"))
(add-ns grmr (module "core/grammar.toc"))
(add-ns ast (module "core/ast.toc"))
(add-ns an (module "core/analyzer.toc"))
;; (add-ns fio (module "core/file-io.toc"))
;; (add-ns rwr (module "core/ast-rewrite.toc"))

(defn debug [& args]
  (comp (for [debugging (sm/get-val :debug-on)
              :when debugging]
          (apply print-err args))
        (sm/state-maybe "")))

(defn types []
  ;; type numbers must start at 1 and be contiguous
  {'String 1
   'Number 2
   'Function 3
   'List 4
   'Keyword 5
   'SubStr 6
   'Symbol 7
   'FnArity 8
   'Opaque 9
   'BitmapIndexedNode 10
   'ArrayNode 11
   'HashCollisionNode 12
   })

(defn type-num-to-name [type-num]
  (sm/get-in-val (list :type-names type-num) :unknown-type))

(deftype c-code [c-val init decl type-num]
  Stringable
  (string-list [_]
    (list "<C-Code " (str c-val) ", " (str type-num) ">")))

(defn write [str]
  (map (sm/state-maybe str) print))

(defn write-strs [str-list]
  (map (sm/state-maybe str-list)
       (fn [str-list]
         (map str-list print))))

(defn genlocal [pre]
  (for [sym-count (sm/get-val :local-sym-count)
        _ (sm/set-val :local-sym-count (inc sym-count))]
    (symbol (str pre sym-count))))

(defn local-sym [sym]
  (sm/get-in-val (list :local-syms sym)))

(defn closed-over-sym [sym]
  (for [;; fails if 'sym' is not in the context
        sym-val (sm/get-in-val (list :context sym))

        closed-over (sm/get-val :closed-over)
        :let [closure-sym (.v (comp
                               (for [closure-sym (some closed-over (fn [[sym-literal _]]
                                                                     (m= sym sym-literal)))]
                                 (second closure-sym))
                               (maybe :not-found)))]
        closure-sym (cond
                     (= closure-sym :not-found) (for [closure-sym (genlocal "val")
                                                      _ (sm/update-in-val (list :closed-over)
                                                                          (fn [closures]
                                                                            (cons (list closure-sym sym)
                                                                                  closures)))]
                                                  closure-sym)
                     (sm/state-maybe closure-sym))]
    (c-code closure-sym empty-list "" (.type-num sym-val))))

(defn core-def [sym]
  (for [ext-ref (sm/get-in-val (list :core-defined-syms sym))
        _ (sm/assoc-in-val (list :defined-syms sym) ext-ref)
        _ (sm/assoc-in-val (list :core-externs sym) ext-ref)
        _ (sm/update-in-val (list :new-externs)
                            (fn [externs]
                              (cons (car ext-ref) externs)))]
    (second ext-ref)))

;; A symbol can be a local, from the context, from the dictionary or
;; from the core
(defn lookup-sym* [sym]
  (comp (sm/get-in-val (list :local-syms sym))
        (closed-over-sym sym)
        (for [ext-ref (sm/get-in-val (list :defined-syms sym))]
          (second ext-ref))
        (for [ext-ref (sm/get-in-val (list :core-externs sym))]
          (second ext-ref))
        (core-def sym)))

(defn lookup-sym [sym]
  (comp (lookup-sym* sym)
        (for [file-name (sm/get-val :file-name)
              line-num (sm/get-val :line-num)]
          (let [_ (print-err "Undefined symbol:" sym "at" file-name ":" line-num)]
            (abort)))))

(defn reset-fn-context [arity-fn-sym num-args]
  (for [locals (sm/get-val :local-syms)
        _ (sm/set-val :local-syms {})
        local-sym-count (sm/get-val :local-sym-count)
        _ (sm/set-val :local-sym-count 0)
        context (sm/get-val :context)
        _ (sm/set-val :context (comp context locals))
        closed-over (sm/get-val :closed-over)
        _ (sm/set-val :closed-over empty-list)
        curr-arity-fn-sym (sm/get-val :curr-arity-fn-sym)
        _ (sm/set-val :curr-arity-fn-sym arity-fn-sym)
        curr-arg-count (sm/get-val :curr-arg-count)
        _ (sm/set-val :curr-arg-count num-args)]
    (list locals local-sym-count context closed-over
          curr-arity-fn-sym curr-arg-count)))

(defn restore-fn-context [[locals local-sym-count context closed-over curr-arity-fn-sym curr-arg-count]]
  (apply-to list
            (sm/set-val :context context)
            (sm/set-val :local-syms locals)
            (sm/set-val :local-sym-count local-sym-count)
            (sm/set-val :closed-over closed-over)
            (sm/set-val :curr-arity-fn-sym curr-arity-fn-sym)
            (sm/set-val :curr-arg-count curr-arg-count)))

(defn begin-scope []
  (for [scope-locals (sm/get-val :scope-locals)
        _ (sm/set-val :scope-locals {})]
    scope-locals))

(defn end-scope [scope-info]
  (sm/set-val :scope-locals scope-info))

(defn remember-local [sym]
  (sm/assoc-in-val (list :scope-locals (str sym)) true))

(defn emit-closures []
  (for [closures (sm/get-val :closed-over)]
    (map (reverse closures)
         (fn [[closure]]
           (print "Value *" closure
                  " = closures->head;\n"
                  "if (closures->tail)\nclosures->tail->len = closures->len - 1;\n"
                  "closures = closures->tail;\n")))))

(defn closures-init [arity-sym closures]
  (for [closure-syms (traverse (map closures second) lookup-sym)]
    (reduce (reverse closure-syms) empty-list
            (fn [closed-over sym]
              (let [c-sym (.c-val sym)]
                (list* "incRef((Value *)" c-sym ");\n"
                       arity-sym "->closures = listCons((Value *)"
                       c-sym ", (List *)" arity-sym "->closures);\n"
                       closed-over))))))

(defn fixed-arity [arity-sym arity-fn-sym num-args closures return-type ast]
  (for [fn-arity-type (sm/get-in-val (list :types 'FnArity) :no-fn-type)
        result (comp
                (for [closed-over (closures-init arity-sym closures)]
                  (c-code arity-sym
                          (list* "FnArity *" arity-sym " = malloc_fnArity();\n"
                                 arity-sym "->type = FnArityType;\n"
                                 arity-sym "->count = " (str num-args) ";\n"
                                 arity-sym "->closures = empty_list;\n"
                                 arity-sym "->variadic = 0;\n"
                                 arity-sym "->fn = " arity-fn-sym ";\n"
                                 closed-over)
                          {num-args {:fn-sym arity-fn-sym
                                     :return-type return-type
                                     :ast (fr/free ast)}}
                          fn-arity-type))

                (sm/state-maybe (c-code (str "&(FnArity){FnArityType, -1, "
                                             num-args ", (List *)0, 0, " arity-fn-sym "}")
                                        empty-list
                                        {num-args {:fn-sym arity-fn-sym
                                                   :return-type return-type
                                                   :ast (fr/free ast)}}
                                        fn-arity-type)))]
    result))

(defn variadic-arity [arity-sym arity-fn-sym num-args closures return-type ast]
  (for [fn-arity-type (sm/get-in-val (list :types 'FnArity) :no-fn-type)
        result (comp
                (for [closed-over (closures-init arity-sym closures)]
                  (c-code arity-sym
                          (list* "FnArity *" arity-sym " = malloc_fnArity();\n"
                                 arity-sym "->type = FnArityType;\n"
                                 arity-sym "->count = " (str num-args) ";\n"
                                 arity-sym "->closures = empty_list;\n"
                                 arity-sym "->variadic = 1;\n"
                                 arity-sym "->fn = " arity-fn-sym ";\n"
                                 closed-over)
                          {num-args {;; :fn-sym arity-fn-sym
                                     :return-type return-type
                                     :ast (fr/free ast)}}
                          fn-arity-type))

                (sm/state-maybe (c-code (str "&(FnArity){FnArityType, -1, "
                                             num-args ", (List *)0, 1, " arity-fn-sym "}")
                                        empty-list
                                        {:variadic {:fn-sym arity-fn-sym
                                                    :return-type return-type
                                                    :ast (fr/free ast)}}
                                        fn-arity-type)))]
    result))

(defn emit-externs []
  (for [externs (sm/get-val :new-externs)
        _ (write-strs (map externs (fn [ext] (str "extern " ext ";\n"))))
        _ (sm/set-val :new-externs empty-list)

        static-fns (sm/get-val :new-static-fns)
        _ (write-strs static-fns)
        _ (sm/set-val :new-static-fns empty-list)]
    ""))

(defn core-static-fn [target-sym num-args]
  (let [args (cons "List *" (cond
                             (= 0 num-args) empty-list
                             (= :variadic num-args) (list "Value *")
                             (repeat num-args "Value *")))
        args (apply str (interpose args ", "))]
    (for [arity-sym (sm/get-in-val (list :core-static-fns target-sym num-args :fn-sym))
          _ (sm/assoc-in-val (list :static-fns target-sym num-args :fn-sym) arity-sym)
          _ (sm/update-in-val (list :new-static-fns)
                              (fn [s-fns]
                                (cons (str "Value *" arity-sym "(" args ");\n") s-fns)))]
      arity-sym)))

(defn lookup-static-fn [target-sym num-args]
  (comp (sm/get-in-val (list :static-fns target-sym num-args :fn-sym))
        (core-static-fn target-sym num-args)))

(defn lookup-static-return-type [target-sym num-args]
  (comp (sm/get-in-val (list :static-fns target-sym num-args :return-type))
        (sm/get-in-val (list :core-static-fns target-sym num-args :return-type) :no-type)))

(defn call-dyn-fn-value [target args arg-stmts]
  (let [num-args (count args)]
    (for [fn-type (sm/get-in-val (list :types 'Function) :type-not-found)
          :when (= fn-type (.type-num target))
          arity-sym (genlocal "arity")
          variadic-sym (genlocal "varArgs")
          fn-sym (genlocal "fn")
          result-sym (genlocal "rslt")
          _ (remember-local result-sym)]
      (let [args (map args .c-val)
            arg-syms (cons (str arity-sym "->closures") args)]
        (c-code result-sym
                (comp (.init target)
                      arg-stmts
                      (list "Value *" result-sym ";\n"
                            "FnArity *" arity-sym " = findFnArity(" (.c-val target)
                            ", " num-args ");\n"
                            "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) {\n"
                            "FnType" num-args " *" fn-sym " = (FnType" num-args " *)"
                            arity-sym "->fn;\n"
                            result-sym " = " fn-sym "(" (apply str (interpose arg-syms ", ")) ");\n"
                            "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) {\n"
                            "FnType1 *" fn-sym " = (FnType1 *)" arity-sym "->fn;\n"
                            "List *" variadic-sym " = empty_list;\n")
                      (map (reverse (cdr arg-syms))
                           (fn [arg-sym]
                             (str "incRef(" arg-sym ");\n"
                                  variadic-sym " = (List *)listCons("
                                  arg-sym ", " variadic-sym ");\n")))
                      (list result-sym " = " fn-sym "(" (car arg-syms) ", (Value *)"
                            variadic-sym ");\n"
                            "dec_and_free((Value *)" variadic-sym ");\n"
                            "} else {\nfprintf(stderr, \"\\n*** no arity found for '%s'.\\n\", "
                            "((Function *)" (.c-val target) ")->name"
                            ");\n  abort();\n}\n"))
                "" :no-type)))))

(defn call-dyn-unknown-type [target args arg-stmts]
  (cond
   (not (= :no-type (.type-num target)))
   (zero sm/state-maybe)

   (let [num-args (count args)]
     (for [arity-sym (genlocal "arity")
           variadic-sym (genlocal "varArgs")
           fn-sym (genlocal "fn")
           result-sym (genlocal "rslt")
           _ (remember-local result-sym)
           invoke-sym (lookup-sym 'invoke)
           invoke-arity-sym (lookup-static-fn (.c-val invoke-sym) (inc num-args))]
       (let [args (map args .c-val)
             arg-syms (cons (str arity-sym "->closures") args)]
         (c-code result-sym
                 (comp (.init target)
                       arg-stmts
                       (list "Value *" result-sym ";\n"
                             "if((" (.c-val target) ")->type != FunctionType) {\n"

                             result-sym " = " invoke-arity-sym "(empty_list, "
                             (apply str (interpose (cons (.c-val target) args) ", "))
                             ");\n} else {\n"

                             "FnArity *" arity-sym " = findFnArity(" (.c-val target) ", " num-args ");\n"
                             "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) {\n"
                             "FnType" num-args " *" fn-sym " = (FnType" num-args " *)" arity-sym "->fn;\n"
                             result-sym " = " fn-sym "(" (apply str (interpose arg-syms ", ")) ");\n"
                             "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) {\n"
                             "FnType1 *" fn-sym " = (FnType1 *)" arity-sym "->fn;\n"
                             "List *" variadic-sym " = empty_list;\n")
                       (map (reverse (cdr arg-syms))
                            (fn [arg-sym]
                              (str "incRef(" arg-sym ");\n"
                                   variadic-sym " = (List *)listCons("
                                   arg-sym ", " variadic-sym ");\n")))
                       (list result-sym " = " fn-sym "(" (car arg-syms) ", (Value *)" variadic-sym ");\n"
                             "dec_and_free((Value *)" variadic-sym ");\n"
                             "} else {\nfprintf(stderr, \"\\n*** no arity found for '%s'.\\n\", "
                             "((Function *)" (.c-val target) ")->name"
                             ");\n  abort();\n}\n}\n"))
                 "" :no-type))))))

(defn call-dyn-known-type [target args arg-stmts]
  (let [num-args (count args)]
    (for [result-sym (genlocal "rslt")
          _ (remember-local result-sym)
          invoke-sym (lookup-sym 'invoke)
          invoke-arity-sym (lookup-static-fn (.c-val invoke-sym) (inc num-args))

          qualified-name (sm/get-in-val (list :defined-protos 'invoke))
          proto-fn (sm/get-in-val (list :protocols qualified-name :impls
                                        (.type-num target) :fn-sym)
                                  :failed)
          fn-sym (comp (for [fn-sym (lookup-static-fn proto-fn (inc num-args))]
                         fn-sym)
                       (sm/state-maybe invoke-arity-sym))
          return-type (lookup-static-return-type proto-fn (inc num-args))]
      (c-code result-sym
              (comp (.init target)
                    arg-stmts
                    (list "Value *" result-sym " = " fn-sym "(empty_list, "
                          (apply str (interpose (cons (.c-val target)
                                                      (map (car args) .c-val)) ", "))
                          ");\n"))
              "" return-type))))

(defn call-recursive [target args arg-stmts]
  (let [args (map args .c-val)]
    (for [curr-fn-sym (sm/get-val :curr-fn-sym)
          curr-num-args (sm/get-val :curr-arg-count)
          :when (and (= (str "(Value *)&" curr-fn-sym) (.c-val target))
                     (= (count args) curr-num-args))
          curr-arity-fn-sym (sm/get-val :curr-arity-fn-sym)
          result-sym (genlocal "rslt")
          _ (remember-local result-sym)]
      (c-code result-sym
              (comp (.init target)
                    arg-stmts
                    (list "Value *" result-sym " = " curr-arity-fn-sym
                          "(" (apply str (interpose (cons "closures" args) ", ")) ");\n"))
              "" :no-type))))

(defn call-proto-impl [target-ast args arg-stmts]
  (cond
   (not (instance? fr/free target-ast)) (zero sm/state-maybe)
   (not (instance? ast/symbol-ast (.v target-ast))) (zero sm/state-maybe)
   (empty? args) (zero sm/state-maybe)
   (let [name (.sym (.v target-ast))
         num-args (count args)]
     (for [qualified-name (sm/get-in-val (list :defined-protos name))
           proto-fn (sm/get-in-val (list :protocols qualified-name :impls
                                         (.type-num (car args)) :fn-sym))
           fn-sym (lookup-static-fn proto-fn num-args)
           return-type (cond
                        (= "core/free.toc/FreeEval/evaluate" qualified-name)
                        (lookup-static-return-type (.c-val (second args)) 2)

                        (lookup-static-return-type proto-fn num-args))
           result-sym (genlocal "rslt")
           ;; _ (debug :name name :type-num (.type-num (car args)))
           _ (remember-local result-sym)]
       (let [return-type (cond
                          (not (= :no-type return-type)) return-type
                          ;; TODO: these should be the result of
                          ;; asserts on the protocol fn defs
                          (= 'map name) (.type-num (car args))
                          (= 'comp* name) (.type-num (car args))
                          (= 'comp name) (.type-num (car args))
                          (= 'flat-map name) (.type-num (car args))
                          :no-type)
             arg-syms (cons "empty_list" (map args .c-val))]
         (c-code result-sym
                 (comp arg-stmts
                       (list "Value *" result-sym " = " fn-sym "(")
                       (interpose arg-syms ", ")
                       (list ");\n"))
                 ""
                 return-type))))))

(defn call-invoke [target args arg-stmts]
  (for [proto-fn (sm/get-in-val (list :protocols "Function/invoke" :impls
                                      (.type-num target) :fn-sym))
        :let [arg-stmts (comp (.init target) arg-stmts)
              args (cons target args)
              num-args (count args)]
        fn-sym (lookup-static-fn proto-fn num-args)
        return-type (lookup-static-return-type proto-fn num-args)
        result-sym (genlocal "rslt")
        _ (remember-local result-sym)]
    (c-code result-sym
            (comp arg-stmts
                  (list "Value *" result-sym " = " fn-sym "(")
                  (interpose (cons "empty_list" (map args .c-val)) ", ")
                  (list ");\n"))
            ""
            return-type)))

(defn call-static-fixed [target args arg-stmts]
  (let [args (map args .c-val)
        num-args (count args)]
    (for [arity-sym (lookup-static-fn (.c-val target) num-args)
          result-type (lookup-static-return-type (.c-val target) num-args)
          result-sym (genlocal "rslt")
          _ (remember-local result-sym)]
      (c-code result-sym
              (comp (.init target)
                    arg-stmts
                    (list (str Value* result-sym " = " arity-sym "("
                               (apply str (interpose (cons "empty_list" args) ", ")) ");\n")))
              "" result-type))))

(defn call-static-variadic [target args arg-stmts]
  (for [arity-sym (lookup-static-fn (.c-val target) :variadic)
        result-type (lookup-static-return-type (.c-val target) :variadic)
        variadic-sym (genlocal "varArgs")
        result-sym (genlocal "rslt")
        _ (remember-local result-sym)]
    (c-code result-sym
            (comp (.init target)
                  arg-stmts
                  (list "List *" variadic-sym " = empty_list;\n")
                  (map (reverse args)
                       (fn [arg]
                         (let [arg-sym (.c-val arg)]
                           (str "incRef((Value *)" arg-sym ");\n"
                                variadic-sym " = (List *)listCons("
                                "(Value *)" arg-sym
                                ", " variadic-sym ");\n"))))
                  (list Value* result-sym " = " arity-sym "(empty_list, (Value *)" variadic-sym ");\n"
                        "dec_and_free((Value *)" variadic-sym ");\n"))
            "" result-type)))

(defprotocol Emitter
  (emit-c [ast]
    (sm/state-maybe ast)))

(extend-type ast/inline-ast
  Emitter
  (emit-c [ast]
    (for [type (sm/get-in-val (list :types (.result-type ast)) :no-type)]
      (c-code "" (list (.txt ast)) "" type))))

(extend-type ast/symbol-ast
  Emitter
  (emit-c [ast]
    (lookup-sym (.sym ast))))

(extend-type ast/keyword-ast
  Emitter
  (emit-c [ast]
    (for [static-kw (sm/get-in-val (list :keywords (.kw ast)))
          type-num (sm/get-in-val (list :types 'Keyword))]
      (c-code (str "(Value *)&" static-kw)
              empty-list
              (str "SubString " static-kw)
              type-num))))

(extend-type ast/const-number-ast
  Emitter
  (emit-c [ast]
    (for [static-num (comp (sm/get-in-val (list :numbers (.num ast)))
                           (sm/get-in-val (list :new-numbers (.num ast))))
          type-num (sm/get-in-val (list :types 'Number))]
      (c-code (str "(Value *)&" static-num)
              empty-list
              ""
              type-num))))

(extend-type ast/const-string-ast
  Emitter
  (emit-c [ast]
    (for [static-str (sm/get-in-val (list :strings (.const-str ast)) :no-static-str)
          type-num (sm/get-in-val (list :types 'String))]
      (c-code (str "(Value *)&" static-str)
              empty-list
              (str "String " static-str)
              type-num))))

(defn eval-exprs [ast]
  (for [exprs (fr/evaluate ast emit-c)]
    (reduce exprs (c-code "" empty-list "" :no-type)
            (fn [result expr]
              (c-code (.c-val expr)
                      (comp (.init result) (.init expr))
                      ""
                      (.type-num expr))))))

(defn unpack-closures [list-sym [arg-sym & arg-syms]]
  (let [arg (.c-val arg-sym)]
    (cond
     (= arg "")
     (list "")

     (empty? arg-syms)
     (list "Value *" arg " = (Value *) " list-sym ";\n")

     (let [results (unpack-closures list-sym arg-syms)]
       (list* "Value *" arg
              " = " list-sym "->head;\n"
              "if (" list-sym "->tail) " list-sym "->tail->len = " list-sym "->len - 1;\n"
              list-sym " = " list-sym "->tail;\n"
              (comp (.init arg-sym)
                    results))))))

(defn gen-arg-syms [args]
  (cond
   (< 0 (count args))
   (let [last-arg (last args :bogus)
         gen-arg (fn [arg]
                   (cond
                    (instance? Keyword arg)
                    (sm/state-maybe (c-code "" empty-list "" :no-type))

                    (instance? List arg)
                    (for [args (gen-arg-syms arg)
                          c-sym (genlocal "arg")
                          list-sym (genlocal "arg")]
                      (c-code c-sym
                              (comp (list "List *" list-sym " = (List *)" c-sym ";\n")
                                    (unpack-closures list-sym args))
                              ""
                              List))

                    (for [arg-sym (genlocal "arg")
                          :let [c-sym (cond
                                       (= arg last-arg) (c-code arg-sym empty-list "" List)
                                       (c-code arg-sym empty-list "" :no-type))]
                          _ (sm/assoc-in-val (list :local-syms arg) c-sym)]
                      c-sym)))
         args (map args gen-arg)]

     (apply* (sm/state-maybe list)
             args))

   (sm/state-maybe empty-list)))

(defn type-str [types type]
  (match (m-get types type)
         |maybe v| (str v)
         ":no-type"))

(defn base-types []
  (for [types (sm/get-val :types)
        result (write-strs (list
                            "#include <sys/types.h>\n"
                            "#include <stdio.h>\n"
                            "#include <string.h>\n\n"
                            Value
                            NumberVal
                            StringVal
                            SubStringVal
                            ListVal
                            FnArityVal
                            FunctionVal
                            ProtoImpl
                            ProtoImpls
                            ReifiedVal
                            OpaqueVal
                            BitmapIndexedVal
                            ArrayNodeVal
                            HashCollisionVal
                            "List *listCons(Value *x, List *l);\n"
                            "Value *stringValue(char *s);\n"
                            "#define NumberType " (type-str types 'Number) "\n"
                            "#define KeywordType " (type-str types 'Keyword) "\n"
                            "#define SymbolType " (type-str types 'Symbol) "\n"
                            "#define StringType " (type-str types 'String) "\n"
                            "#define SubStringType " (type-str types 'SubStr) "\n"
                            "#define ListType " (type-str types 'List) "\n"
                            "#define FunctionType " (type-str types 'Function) "\n"
                            "#define FnArityType " (type-str types 'FnArity) "\n"
                            "#define OpaqueType " (type-str types 'Opaque) "\n"
                            "#define BitmapIndexedType " (type-str types 'BitmapIndexedNode) "\n"
                            "#define ArrayNodeType " (type-str types 'ArrayNode) "\n"
                            "#define HashCollisionNodeType " (type-str types 'HashCollisionNode) "\n"
                            "List *empty_list;\n"
                            "Value *number_literals();\n"
                            "Value *counts();\n"
                            "Value *types();\n"
                            "Value *symbol_literals();\n"
                            "Value *keyword_literals();\n"
                            "Value *string_literals();\n"
                            "Value *defined_syms();\n"
                            "Value *static_fns();\n"
                            "Value *protocols();\n"
                            "\n"))]
    result))

(defn extern-base-types []
  (for [types (sm/get-val :types)
        result (write-strs (list
                            "#include <sys/types.h>\n"
                            "#include <stdio.h>\n"
                            "#include <string.h>\n\n"
                            Value
                            NumberVal
                            StringVal
                            SubStringVal
                            ListVal
                            FnArityVal
                            FunctionVal
                            ProtoImpl
                            ProtoImpls
                            ReifiedVal
                            OpaqueVal
                            BitmapIndexedVal
                            ArrayNodeVal
                            HashCollisionVal
                            "extern List *listCons(Value *x, List *l);\n"
                            "extern Value *stringValue(char *s);\n"
                            "#define NumberType " (type-str types 'Number) "\n"
                            "#define KeywordType " (type-str types 'Keyword) "\n"
                            "#define SymbolType " (type-str types 'Symbol) "\n"
                            "#define StringType " (type-str types 'String) "\n"
                            "#define SubStringType " (type-str types 'SubStr) "\n"
                            "#define ListType " (type-str types 'List) "\n"
                            "#define FunctionType " (type-str types 'Function) "\n"
                            "#define FnArityType " (type-str types 'FnArity) "\n"
                            "#define OpaqueType " (type-str types 'Opaque) "\n"
                            "#define BitmapIndexedType " (type-str types 'BitmapIndexedNode) "\n"
                            "#define ArrayNodeType " (type-str types 'ArrayNode) "\n"
                            "#define HashCollisionNodeType " (type-str types 'HashCollisionNode) "\n"
                            "extern List *empty_list;\n"
                            "extern Value *number_literals();\n"
                            "extern Value *counts();\n"
                            "extern Value *types();\n"
                            "extern Value *symbol_literals();\n"
                            "extern Value *keyword_literals();\n"
                            "extern Value *string_literals();\n"
                            "extern Value *defined_syms();\n"
                            "extern Value *static_fns();\n"
                            "extern Value *protocols();\n"
                            "\n"))]
    result))

(defn extern-fixed-fn [name return-type & arg-types]
  (write-strs (comp (list "extern " return-type " " name "(")
                    (interpose arg-types ", ")
                    (list ");\n"))))

(defn extern-variadic-fn [name return-type & arg-types]
  (write-strs (comp (list "extern " return-type " " name "(")
                    (interpose arg-types ", ")
                    (list ", ...);\n"))))

(defn extern-functions []
  (apply-to list
            (write "\n")
            (extern-fixed-fn 'abort VoidT)
            (extern-variadic-fn 'printf Int32 "const char *")
            (extern-fixed-fn 'free VoidT "void *")
            (extern-fixed-fn 'malloc "void *" "unsigned long")))

(defn static-syms [syms sym-type]
  (let [syms (seq syms)]
    (comp
     (traverse syms
               (fn [[sym c-sym]]
                 (write-strs (list "SubString "
                                   c-sym
                                   " = {"
                                   sym-type
                                   ", -1, " (count (str sym)) ", 0, 0, \""
                                   sym
                                   "\"};\n"))))

     (sm/state-maybe ""))))

(defn static-values []
  (for [string-type (sm/get-in-val (list :types 'String) "no_String_type")
        _ (for [strs (sm/get-val :new-strings)
                _ (sm/update-in-val (list :strings)
                                    (fn [old-strs]
                                      (comp old-strs strs)))
                _ (sm/assoc-in-val (list :new-strings) {})]
            (for [[str-val str-ptr] (seq strs)
                  :let [str-len (count str-val)]
                  x (list
                     "struct {int64_t type;\n int32_t refs;\n   int64_t len;\n   char buffer["
                     (inc str-len)
                     "];} " str-ptr " = {" string-type ", -1, "
                     str-len ",\"" (escape-chars str-val) "\"};\n")]
              (print x)))

        number-type (sm/get-in-val (list :types 'Number) "no_Number_type")
        _ (for [nums (sm/get-val :new-numbers)
                _ (sm/update-in-val (list :numbers)
                                    (fn [old-nums]
                                      (comp old-nums nums)))
                _ (sm/assoc-in-val (list :new-numbers) {})]
            (for [[num c-sym] (seq nums)
                  x (list "Number " c-sym " = {" number-type ", -1, " num "};\n")]
              (print x)))

        syms (sm/get-in-val (list :new-symbols) {})
        symbol-type (sm/get-in-val (list :types 'Symbol) "no_Symbol_type")
        _ (apply-to list
                    (static-syms syms symbol-type)
                    (sm/update-in-val (list :symbols)
                                      (fn [old-sys]
                                        (comp old-sys syms)))
                    (sm/assoc-in-val (list :new-symbols) {}))

        kws (sm/get-in-val (list :new-keywords) {})
        keyword-type (sm/get-in-val (list :types 'Keyword) "no_Keyword_type")
        _ (apply-to list
                    (static-syms kws keyword-type)
                    (sm/update-in-val (list :keywords)
                                      (fn [old-kws]
                                        (comp old-kws kws)))
                    (sm/assoc-in-val (list :new-keywords) {}))]
    ""))


(defn fixed-fn-types []
  (apply-to list
            (write-strs (list "typedef Value *(FnType0)(List *);\n"))
            (traverse (range 9)
                      (fn [arg-count]
                        (apply-to list
                                  (write-strs (list "typedef Value *(FnType" (inc arg-count) ")("))
                                  (write-strs (interpose (cons "List *"
                                                               (repeat (inc arg-count) "Value *"))
                                                         ", "))
                                  (write ");\n"))))))

(defn add-module-info [ns-sym module-name]
  (apply-to (fn [& _]
              (c-code "" empty-list "" :no-type))
            ;; this is supposed to fail if there are no symbols
            ;; defined in the module
            (for [new-mod-syms (sm/get-in-val (list :modules module-name :syms))
                  _ (traverse (seq new-mod-syms)
                              (fn [[sym def]]
                                (let [path (cond
                                            (= "." (subs (str sym) 0 1))
                                            (list :defined-syms sym)

                                            (list :defined-syms (symbol (str ns-sym "/" sym))))]
                                  (sm/assoc-in-val path def))))]
              "")
            (comp (for [new-mod-protos (sm/get-in-val (list :modules module-name :protos))
                        _ (traverse (seq new-mod-protos)
                                    (fn [[proto def]]
                                      (let [path (cond
                                                  (= "." (subs (str proto) 0 1))
                                                  (list :defined-protos proto)

                                                  (list :defined-protos (symbol (str ns-sym "/" proto))))]
                                        (sm/assoc-in-val path def))))]
                    "")
                  (sm/state-maybe ""))
            (comp (for [new-mod-types (sm/get-in-val (list :modules module-name :types))
                        _ (traverse (seq new-mod-types)
                                    (fn [[type def]]
                                      (sm/assoc-in-val (list :defined-types (symbol (str ns-sym "/" type))) def)))]
                    "")
                  (sm/state-maybe ""))))

(extend-type ast/add-ns-ast
  Emitter
  (emit-c [ast]
    (let [module-name (.const-str (.v (first (.asts ast))))]
      (comp
       (add-module-info (.ns-sym ast) module-name)
       (for [syms (sm/get-val :defined-syms)
             _ (sm/set-val :defined-syms {})

             types (sm/get-val :defined-types)
             _ (sm/set-val :defined-types {})

             protos (sm/get-val :defined-protos)
             core-protos (sm/get-in-val (list :modules "core" :protos) {})
             _ (sm/set-val :defined-protos (reduce (filter (seq protos)
                                                           (fn [[name]]
                                                             (= "." (subs (str name) 0 1))))
                                                   core-protos
                                                   (fn [m [name qualified-name]]
                                                     (assoc m name qualified-name))))

             file-name (sm/get-val :file-name)
             _ (sm/set-val :file-name module-name)
             _ (cond
                (= 1 (count (.asts ast))) (sm/state-maybe "")
                (traverse (.asts ast) (fn [ast] (fr/evaluate ast emit-c))))

             _ (sm/set-val :file-name file-name)
             _ (sm/set-val :defined-syms syms)
             _ (sm/set-val :defined-protos protos)
             _ (sm/set-val :defined-types types)

             _ (add-module-info (.ns-sym ast) module-name)]
         (c-code "" empty-list "" :no-type))
       (sm/state-maybe (c-code "" empty-list "" :no-type))))))

(extend-type ast/variadic-arity-ast
  Emitter
  (emit-c [ast]
    (let [c-args (list "closures" "varArgs")
          arg-count (count (.args ast))
          arity-fn-sym (gensym "arityImpl_")]
      (for [arity-sym (genlocal "arity_")
            fn-context (reset-fn-context arity-fn-sym arg-count)
            arg-syms (gen-arg-syms (.args ast))
            scope-info (begin-scope)
            body-exprs (eval-exprs (.body ast))
            _ (emit-externs)
            _ (write-strs (list "Value *" arity-fn-sym "(List *closures, Value *varArgs) {\n"
                                "List *argsList = (List *)varArgs;\n"))
            _ (write-strs (unpack-closures "argsList" arg-syms))

            :let [result-sym (.c-val body-exprs)]
            _ (apply-to list
                        (emit-closures)
                        (write-strs (.init body-exprs))
                        (for [scope-locals (sm/get-val :scope-locals)
                              :let [locals (map (filter (seq scope-locals) second) first)
                                    only-result? (cond
                                                  (< 1 (count locals)) false
                                                  (empty? locals) false
                                                  (= (str result-sym) (car locals)))]
                              _ (write-strs (cond
                                             only-result? empty-list
                                             (= result-sym "") empty-list
                                             (list "incRef(" result-sym ");\n")))
                              :let [locals (cond
                                            only-result? empty-list
                                            locals) ]
                              _ (write-strs (map locals
                                                 (fn [local]
                                                   (str "dec_and_free(" local ");\n"))))]
                          "")
                        (end-scope scope-info)
                        (cond
                         (= result-sym "") (sm/state-maybe "")
                         (write-strs (list "return(" result-sym ");\n")))
                        (write "};\n"))
            closures (sm/get-val :closed-over)
            _ (restore-fn-context fn-context)
            result (variadic-arity arity-sym arity-fn-sym
                                   (count c-args) closures
                                   (.type-num body-exprs)
                                   ast)]
        result))))

(extend-type ast/fn-arity-ast
  Emitter
  (emit-c [ast]
    (let [arity-fn-sym (gensym "arityImpl_")]
      (for [arity-sym (genlocal "arity_")
            :let [args (.args ast)
                  arg-count (count args)
                  args (comp args (list :no-tail))]
            fn-context (reset-fn-context arity-fn-sym arg-count)
            arg-syms (gen-arg-syms args)
            :let [arg-syms (remove arg-syms (fn [arg] (= "" (.c-val arg))))]
            scope-info (begin-scope)
            body-exprs (eval-exprs (.body ast))
            _ (emit-externs)

            :let [result-sym (.c-val body-exprs)]
            _ (apply-to list
                        (write-strs (list "Value *" arity-fn-sym "("))
                        (write-strs (interpose (cons "List *closures"
                                                     (map arg-syms (fn [arg] (str "Value *" (.c-val arg)))))
                                               ", "))
                        (write ") {\n")
                        (emit-closures)
                        (let [arg-init (remove (map arg-syms .init) empty?)]
                          (cond
                           (empty? arg-init) (sm/state-maybe "")
                           (write-strs (apply comp arg-init))))
                        (write-strs (.init body-exprs))
                        (for [scope-locals (sm/get-val :scope-locals)
                              :let [locals (map (filter (seq scope-locals) second) first)
                                    only-result? (cond
                                                  (< 1 (count locals)) false
                                                  (empty? locals) false
                                                  (= (str result-sym) (car locals)))
                                    locals (cond
                                            only-result? empty-list
                                            locals)]
                              _ (write-strs (cond
                                             only-result? empty-list
                                             (= result-sym "") empty-list
                                             (list "incRef(" result-sym ");\n")))
                              _ (write-strs (map locals
                                                 (fn [local]
                                                   (str "dec_and_free(" local ");\n"))))]
                          "")
                        (end-scope scope-info)
                        (cond
                         (= result-sym "") (sm/state-maybe "")
                         (write-strs (list "return(" result-sym ");\n")))
                        (write "};\n\n"))
            closures (sm/get-val :closed-over)
            _ (restore-fn-context fn-context)
            result (fixed-arity arity-sym arity-fn-sym
                                arg-count closures
                                (.type-num body-exprs)
                                ast)]
        result))))

(extend-type ast/main-ast
  Emitter
  (emit-c [ast]
    (let [main-sym (gensym "main_")]
      (for [_ (static-values)
            _ (sm/set-val :main-sym main-sym)
            arg-syms (gen-arg-syms (.args ast))
            _ (sm/set-val :local-sym-count 0)
            scope-info (begin-scope)
            body (eval-exprs (.body ast))
            _ (emit-externs)
            _ (write-strs (list "\nint " main-sym " ("))
            _ (write-strs (interpose (map arg-syms (fn [arg] (str "Value *" (.c-val arg))))
                                     ", "))
            _ (write ") {\n")
            _ (write-strs (.init body))
            scope-locals (sm/get-val :scope-locals)
            _ (write-strs (map (filter (seq scope-locals) second)
                               (fn [[fn-sym-str]]
                                 (str "dec_and_free(" fn-sym-str ");\n"))))
            _ (write "\nreturn(0);\n}\n\n")]
        (c-code "" empty-list "" :no-type)))))

(defn eval-args [args]
  (comp
   (for [evalled (traverse args (fn [arg-ast] (fr/evaluate arg-ast emit-c)))]
     (reduce evalled (list empty-list empty-list)
             (fn [[args stmts] evalled]
               (let [evalled-stmts (.init evalled)]
                 (list (comp args (list evalled))
                       (comp stmts evalled-stmts))))))
   (sm/state-maybe (list empty-list empty-list))))

(defn zip-lists [l1 l2]
  (cond
   (empty? l1) empty-list
   (empty? l2) empty-list
   (let [[l1-head & l1-tail] l1
         [l2-head & l2-tail] l2]
     (cons (list l1-head l2-head)
           (zip-lists l1-tail l2-tail)))))

(defn call-instance? [ast args]
  (let [num-args (count (.args (.params ast)))
        target-ast (.callee ast)]
    (cond
     (not (= 2 num-args)) (zero sm/state-maybe)
     (not (instance? fr/free target-ast)) (zero sm/state-maybe)
     (not (instance? ast/symbol-ast (.v target-ast))) (zero sm/state-maybe)
     (not (= 'instance? (.sym (.v target-ast)))) (zero sm/state-maybe)
     (let [type-sym (.sym (.v (first (.args (.params ast)))))
           type-val (.type-num (second args))]
       (for [instance-type (sm/get-in-val (list :types type-sym))
             :when (= instance-type type-val)
             _ (debug :calling-instance? type-sym instance-type type-val)
             ]
         (c-code "(Value *)&trueVal", empty-list, "", Number))))))

(extend-type ast/call-ast
  Emitter
  (emit-c [ast]
    (for [target (fr/evaluate (.callee ast) emit-c)
          [args arg-stmts] (eval-args (.args (.params ast)))
          result (comp (call-instance? ast args)
                       (call-proto-impl (.callee ast) args arg-stmts)
                       (call-invoke target args arg-stmts)
                       (call-static-fixed target args arg-stmts)
                       (call-static-variadic target args arg-stmts)
                       (call-recursive target args arg-stmts)
                       (call-dyn-fn-value target args arg-stmts)
                       (call-dyn-unknown-type target args arg-stmts)
                       (call-dyn-known-type target args arg-stmts)
                       (map (sm/state-maybe (list target ast))
                            (fn [[target ast]]
                              (print-err (str "could not emit callsite for '"
                                              (first (fr/evaluate (.callee ast) string-list))
                                              "'"))
                              (print-err :target (.c-val target))
                              (abort))))]
      result)))

(extend-type ast/binding-ast
  Emitter
  (emit-c [ast]
    (for [evalled (fr/evaluate (.val ast) emit-c)
          result (cond
                  (instance? Symbol (.binding ast))
                  (for [_ (sm/assoc-in-val (list :local-syms (.binding ast))
                                           (c-code (.c-val evalled) empty-list "" (.type-num evalled)))]
                    (c-code "" (.init evalled) "" :no-type))

                  (for [arg-syms (gen-arg-syms (.binding ast))
                        list-sym (genlocal "arg")]
                    (c-code ""
                            (comp (.init evalled)
                                  (list "List *" list-sym " = (List *)" (.c-val evalled) ";\n")
                                  (unpack-closures list-sym arg-syms))
                            ""
                            :no-type)))]
      result)))

(extend-type ast/let-ast
  Emitter
  (emit-c [ast]
    (for [locals (sm/get-val :local-syms)
          bindings (fr/evaluate (.bindings ast) emit-c)
          body-exprs (eval-exprs (.body ast))
          _ (sm/set-val :local-syms locals)]
      (c-code (.c-val body-exprs)
              (comp (crush bindings .init)
                    (.init body-exprs))
              ""
              (.type-num body-exprs)))))

(extend-type ast/fn-ast
  Emitter
  (emit-c [ast]
    (let [fn-sym (gensym "fn_")
          fn-name (.sym (.v (.fn-name ast)))]
      (for [_ (static-values)
            fn-type (sm/get-in-val (list :types 'Function) :no-type)
            curr-fn-sym (sm/get-val :curr-fn-sym)
            :let [fn-sym-str (str "(Value *)" fn-sym)]
            _ (sm/set-val :curr-fn-sym fn-sym)
            _ (write-strs (list "\n// --------- " fn-name " --------------\n"
                                "Function " fn-sym ";\n"))
            _ (remember-local fn-sym-str)
            ;; TODO: check for anon fn, save previous value of
            ;; :defined-syms and restore at end
            _ (sm/assoc-in-val (list :defined-syms fn-name)
                               (list (str "Function " fn-sym)
                                     (c-code (str "(Value *)&" fn-sym) empty-list "" fn-type)))
            arity-vals (fr/evaluate (.arities ast) emit-c)
            :let [arity-count (count arity-vals)
                  arity-syms (map arity-vals .c-val)
                  arity-init (crush arity-vals .init)
                  static-arities (crush arity-vals .decl)]
            _ (cond
               (= 0 (count arity-init))
               (apply-to list
                         (write-strs (list "\n// --------- " fn-name " main body --------------\n"
                                           "Function " fn-sym " = {FunctionType, -1, \""
                                           fn-name "\", " arity-count ", "
                                           "{" (apply str (interpose arity-syms ", ")) "}};\n\n"))
                         (sm/assoc-in-val (list :scope-locals fn-sym-str) false)
                         (sm/assoc-in-val (list :static-fns (str "(Value *)&" fn-sym)) static-arities))

               (sm/state-maybe ""))
            _ (sm/set-val :curr-fn-sym curr-fn-sym)]
        (cond
         (= 0 (count arity-init))
         (c-code (str "(Value *)&" fn-sym) empty-list (str "Function " fn-sym) fn-type)

         (c-code (str "(Value *)" fn-sym)
                 (comp arity-init
                       (list (str "Function *" fn-sym " = malloc_function(" arity-count ");\n")
                             (str fn-sym "->type = FunctionType;\n")
                             (str fn-sym "->name = \"" fn-name "\";\n")
                             (str fn-sym "->arityCount = " arity-count ";\n"))
                       (map (range arity-count)
                            (fn [index]
                              (str fn-sym "->arities[" index "] = "
                                   (nth arity-syms index "") ";\n"))))
                 (str "Function " fn-sym)
                 fn-type))))))

(extend-type ast/quoted-ast
  Emitter
  (emit-c [ast]
    (let [sym (.q-val ast)]
      (comp
       (for [sym-val (sm/get-in-val (list :symbols sym))
             symbol-type (sm/get-in-val (list :types 'Symbol) :no-type)]
         (c-code (str "(Value *)&" sym-val) empty-list "" symbol-type))
       (map (sm/state-maybe sym) (fn [sym]
                                   (print-err "not found" sym)))))))

(defn forward-decl
  ([name c-name type-num]
     (for [file-name (sm/get-val :file-name)
           :let [def (list (str "Value *" c-name)
                           (c-code c-name empty-list "" type-num))]
           _ (sm/assoc-in-val (list :modules file-name :syms name) def)
           _ (sm/assoc-in-val (list :defined-syms name) def)]
       (c-code c-name empty-list "" type-num)))
  ([name type-num]
     (let [c-name (gensym "var_")]
       (for [_ (write-strs (list (str "// forward declaration for '" name "'\n")
                                 (str "Value *" c-name ";\n\n")))
             result (forward-decl name c-name type-num)]
         result))))

(defn define-fwd-decl [name value]
  (for [c-name (sm/get-in-val (list :defined-syms name))
        evalled-expr (fr/evaluate value emit-c)
        :let [c-name (.c-val (second c-name))
              result-sym (.c-val evalled-expr)
              initialization (.init evalled-expr)
              init-count (count initialization)
              initialization (cond
                              (empty? initialization) ""
                              (first initialization))]
        new-def (cond
                 (= result-sym "")
                 (for [_ (write-strs (list "Value *" c-name " = " initialization))]
                   initialization)

                 (< 1 init-count)
                 (sm/state-maybe (let [_ (print-err (str "invalid definition: " name))]
                                   (abort)))

                 (for [_ (write-strs (list initialization
                                           "Value *" c-name " = " result-sym ";\n"))]
                   result-sym))
        static-fn (comp (for [static-fn (sm/get-in-val (list :static-fns new-def))
                              _ (sm/assoc-in-val (list :static-fns c-name) static-fn)]
                          "")
                        (sm/state-maybe ""))]
    (c-code "" empty-list "" (.type-num evalled-expr))))

(defn inline-text-definition [name [initialization]]
  (let [c-name (gensym "var_")]
    (for [_ (write-strs (list Value* c-name " = " initialization ";\n"))
          _ (sm/assoc-in-val (list :defined-syms name)
                             (list (str "Value *" c-name ";")
                                   (c-code c-name empty-list "" :no-type)))]
      c-name)))

(defn expression-definition [name result-sym initialization extern-def expr-type]
  (let [c-name (gensym "var_")]
    (for [_ (cond
             (< 0 (count initialization)) (write (first initialization))
             (sm/state-maybe ""))
          file-name (sm/get-val :file-name)
          _ (sm/assoc-in-val (list :modules file-name :syms name)
                             (list extern-def (c-code result-sym empty-list "" expr-type)))
          _ (sm/assoc-in-val (list :defined-syms name)
                             (list extern-def (c-code result-sym empty-list "" expr-type)))]
      c-name)))

(defn define-value [name value]
  (for [evalled-expr (fr/evaluate value emit-c)
        :let [result-sym (.c-val evalled-expr)
              initialization (.init evalled-expr)
              extern-def (.decl evalled-expr)
              expr-type (.type-num evalled-expr)]
        _ (cond
           (= result-sym "") (inline-text-definition name initialization)
           (< 1 (count initialization)) (sm/state-maybe (let [_ (print-err (str "invalid definition: " name))]
                                                          (abort)))
           (expression-definition name result-sym initialization extern-def expr-type))]
    (c-code "" empty-list "" :no-type)))

(extend-type ast/definition-ast
  Emitter
  (emit-c [ast]
    (flat-map (static-values)
              (fn [_]
                (cond
                 (= :no-value (.value ast)) (forward-decl (.name ast) :no-type)
                 (comp (define-fwd-decl (.name ast) (.value ast))
                       (define-value (.name ast) (.value ast))))))))

(defn eval-cond-clause [[[test-ast value-ast] & clauses] default cond-result]
  (for [_ (begin-scope)
        test (fr/evaluate test-ast emit-c)
        :let [test-sym (str (.c-val test))
              test-stmts (.init test)]
        test-suffix (for [scope-locals (sm/get-val :scope-locals)]
                      (map (seq scope-locals)
                           (fn [[fn-sym-str local?]]
                             (cond
                              (= test-sym fn-sym-str) ""
                              local? (str "dec_and_free(" fn-sym-str ");\n")
                              ""))))
        _ (begin-scope)
        clause-result (fr/evaluate value-ast emit-c)
        :let [clause-sym (.c-val clause-result)
              clause-stmts (.init clause-result)]
        clause-suffix (for [scope-locals (sm/get-val :scope-locals)]
                        (map (filter (seq scope-locals) second)
                             (fn [[fn-sym-str]]
                               (str "dec_and_free(" fn-sym-str ");\n"))))
        cond-rest (cond
                   (empty? clauses)
                   (sm/state-maybe (c-code cond-result (nth default 1 empty-list)
                                           "" (.type-num clause-result)))

                   (eval-cond-clause clauses default cond-result))]
    (let [result-type (cond
                       (= (.type-num cond-rest) (.type-num clause-result)) (.type-num clause-result)
                       :no-type)]
      (c-code cond-result
              (comp test-stmts
                    test-suffix
                    (list "\nif (isTrue(" test-sym ")) {\n"
                          "dec_and_free(" test-sym ");\n")
                    clause-stmts
                    (list "incRef(" clause-sym ");\n")
                    (list (str cond-result " = " clause-sym ";\n"))
                    clause-suffix
                    (list "} else {\n"
                          "dec_and_free(" test-sym ");\n")
                    (.init cond-rest)
                    (list "}\n"))
              ""
              result-type))))

(extend-type ast/cond-ast
  Emitter
  (emit-c [ast]
    (for [cond-result (genlocal "cond")
          :let [cond-result (str cond-result)]
          scope-info (begin-scope)
          default (fr/evaluate (.default ast) emit-c)
          :let [default-result (.c-val default)
                default-type (.type-num default)]
          default-suffix (for [scope-locals (sm/get-val :scope-locals)]
                           (map (filter (seq scope-locals) second)
                                (fn [[fn-sym-str]]
                                  (str "dec_and_free(" fn-sym-str ");\n"))))
          :let [default-stmts (comp (.init default)
                                    (list "incRef(" default-result ");\n")
                                    (list cond-result " = " default-result ";\n")
                                    default-suffix)
                default (list default-result default-stmts)]
          evalled-clauses (eval-cond-clause (.clauses ast) default cond-result)
          _ (end-scope scope-info)
          _ (remember-local cond-result)]
      (let [result-type (cond
                         (= (.type-num evalled-clauses) default-type) default-type
                         :no-type)]
        (c-code cond-result
                (comp (list "Value *" cond-result ";\n")
                      (.init evalled-clauses))
                "" result-type)))))

(defn expand-match-clauses [match-val-sym type-args-sym clauses]
  (comp
   (traverse clauses
             (fn [[pattern expr]]
               (let [dont-care (gensym "dont-care-")
                     [[pattern-type & symbols] [_ & literals]] (reduce (reverse pattern)
                                                                       (list empty-list empty-list)
                                                                       (fn [[symbols literals] x]
                                                                         (cond
                                                                          (= x "&")
                                                                          (list (cons x symbols)
                                                                                literals)

                                                                          (instance? Symbol x)
                                                                          (list (cons x symbols)
                                                                                (cons dont-care literals))

                                                                          (list (cons dont-care symbols)
                                                                                (cons x literals)))))
                     binding-syms (remove symbols (partial = "&"))
                     binding-syms (cond
                                   (= (count symbols) (count binding-syms))
                                   (comp symbols (list dont-care))

                                   binding-syms)]
                 (cond
                  (empty? (remove literals (partial = dont-care)))
                  (apply-to list
                            (an/analyze-expr
                             (list 'cond
                                   (list 'instance? pattern-type match-val-sym)
                                   (list 'cond (list '<* (list 'count type-args-sym)
                                                     (dec (count binding-syms)))
                                         'false
                                         'true)

                                   'false))
                            (for [b (an/analyze-let-binding (list binding-syms
                                                                  type-args-sym))]
                              (ast/let-expr (list b) (list expr))))

                  (apply-to list
                            (let [temp-args (cons (gensym "t-")
                                                  (map literals (fn [_] (gensym "t-"))))
                                  lit-args (remove (zip-lists temp-args literals)
                                                   (fn [[_ literal]]
                                                     (= literal dont-care)))
                                  lit-checks (map lit-args (partial cons '=))]
                              (an/analyze-expr (list 'cond
                                                     (list 'instance? pattern-type match-val-sym)
                                                     (list 'cond
                                                           (list '<* (list 'count type-args-sym)
                                                                 (dec (count binding-syms)))
                                                           'false

                                                           (list 'let (list (list temp-args type-args-sym))
                                                                 (cond
                                                                  (= 1 (count lit-checks))
                                                                  (first lit-checks)

                                                                  (cons 'and lit-checks))))

                                                     'false)))
                            (for [b (an/analyze-let-binding (list binding-syms
                                                                  type-args-sym))]
                              (ast/let-expr (list b) (list expr))))))))
   (sm/state-maybe empty-list)))

(extend-type ast/match-ast
  Emitter
  (emit-c [ast]
    (let [match-val-sym (gensym "match-val-")
          type-args-sym (gensym "type-args-")]
      (for [expanded-asts (expand-match-clauses match-val-sym type-args-sym (.clauses ast))
            ;; TODO: this just guarantees that "(instance? 'List ...) works
            list-type (sm/get-in-val (list :types 'List))
            _ (an/analyze-expr list-type)
            :let [match-ast (ast/let-expr
                             (list (ast/binding match-val-sym (.value ast))
                                   (ast/binding type-args-sym (ast/call-expr (ast/sym 'type-args)
                                                                             (list (ast/sym match-val-sym)))))
                             (list
                              (ast/cond-expr
                               expanded-asts
                               (.default ast))))]
            result (fr/evaluate match-ast emit-c)]
        result))))

(defn emit-extension [type-num [_ proto-impls]]
  (for [_ (traverse proto-impls
                    (fn [[name ast]]
                      (for [ext-fn (fr/evaluate ast emit-c)
                            _ (write-strs (.init ext-fn))
                            proto-fn-name (sm/get-in-val (list :defined-protos name))
                            _ (sm/assoc-in-val (list :protocols proto-fn-name :impls
                                                     type-num :fn-sym)
                                               (.c-val ext-fn))]
                        "")))]
    (c-code "" empty-list "" :no-type)))

(extend-type ast/extend-ast
  Emitter
  (emit-c [ast]
    (for [type-num (comp (sm/get-in-val (list :defined-types (.type ast)))
                         (sm/get-in-val (list :types (.type ast)) :no-type))
          _ (traverse (seq (.impls ast)) (partial emit-extension type-num))]
      (c-code "" empty-list "" :no-type))))

(defn emit-reified-fn [protocol-name type-num [name ast]]
  (let [args (remove (.args (.v (first (.args (.arities (.v ast))))))
                     (partial instance? Keyword))
        num-args (count args)
        fn-sym (gensym "protoFn_")]
    (for [evalled (fr/evaluate ast emit-c)
          :let [args (map (range num-args) (fn [idx] (str "arg" idx)))
                arg-decls (apply str (interpose (cons (str "List *closures")
                                                      (map args (fn [arg] (str "Value *" arg))))
                                                ", "))
                args (apply str (interpose (cons "closures" args) ", "))]
          reify-fn-index (sm/get-val :reify-fn-index)

          proto-fn-name (sm/get-in-val (list :protocols (str protocol-name "/" name) :impls type-num :fn-sym)
                                       :not-defined)
          impl-sym (comp (sm/get-in-val (list :static-fns proto-fn-name num-args :fn-sym))
                         (map (sm/state-maybe "protoImpl_") gensym))

          _ (sm/set-val :reify-fn-index (inc reify-fn-index))
          _ (write-strs (list "Value *" impl-sym "(" arg-decls ") {\n"
                              "FnArity *arityPtr = ((Function *)((ReifiedVal *)arg0)->impls["
                              reify-fn-index "])->arities[0];\n"
                              "Value *rval = ((FnType" num-args " *)arityPtr->fn)(arityPtr->" args ");\n"
                              "return(rval);\n"
                              "};\n\n"
                              "Function " fn-sym " = {FunctionType, -1, \"" name
                              "\", 1, {&(FnArity){FnArityType, -1, "
                              num-args ", (List *)0, 0, " impl-sym"}}};\n\n"))
          proto-fn-name (sm/get-in-val (list :defined-protos name))
          return-type (lookup-static-return-type (.c-val evalled) num-args)
          _ (sm/assoc-in-val (list :static-fns (str "(Value *)&" fn-sym))
                             {num-args {:fn-sym impl-sym
                                        :return-type return-type
                                        :ast ast}})
          _ (sm/assoc-in-val (list :protocols proto-fn-name :impls type-num :fn-sym)
                             (str "(Value *)&" fn-sym))]
      evalled)))

(defn reified-type [type-num impl-fns]
  (for [reified-sym (genlocal "reified_")
        _ (remember-local reified-sym)]
    (let [inits (crush impl-fns .init)
          impls-syms (map impl-fns .c-val)
          reify-init (list* "Value *" reified-sym " = (Value *)malloc_reified(" (count impls-syms) ");\n"
                            "((ReifiedVal *)" reified-sym ")->type = " type-num ";\n"
                            "((ReifiedVal *)" reified-sym ")->implCount = " (count impl-fns) ";\n"
                            (map (range (count impl-fns))
                                 (fn [index]
                                   (let [sym-init (nth impl-fns index empty-list)
                                         sym (.c-val sym-init)]
                                     (str "((ReifiedVal *)" reified-sym ")->impls[" index "] = " sym ";\n"
                                          "incRef(" sym ");\n")))))]
      (c-code reified-sym (comp inits reify-init) "" type-num))))

(defn static-reified [type-num impl-fns]
  (let [reified-sym (gensym "reified_")]
    (for [_ (write-strs (list "ReifiedVal " reified-sym " = {"
                              type-num ", -1, " (count impl-fns) ", {"
                              (apply str (interpose (map impl-fns .c-val) ", "))
                              "}};\n"))]
      (c-code (str "(Value *)&" reified-sym) empty-list (str "ReifiedVal " reified-sym)
              type-num))))

(extend-type ast/reify-ast
  Emitter
  (emit-c [ast]
    (cond
     (empty? (.impls ast)) (let [_ (print-err :no-impls)]
                             (sm/state-maybe (c-code "" empty-list "" :no-type)))

     (for [types (sm/get-val :types)
           :let [type-num (inc (count types))]
           _ (sm/assoc-in-val (list :types type-num) type-num)
           reify-fn-index (sm/get-val :reify-fn-index)
           _ (sm/set-val :reify-fn-index 0)
           impl-fns (apply* (sm/state-maybe list)
                            (for [[proto-name impl-fns] (seq (.impls ast))
                                  impl-fn impl-fns]
                              (emit-reified-fn proto-name type-num impl-fn)))
           _ (sm/set-val :reify-fn-index reify-fn-index)
           reified-result (cond
                           (= 0 (count (crush impl-fns .init)))
                           (static-reified type-num impl-fns)

                           (reified-type type-num impl-fns))]
       reified-result))))

(defn emit-proto-default [arity]
  (let [default-impl (get (nth arity 1 {}) :default :no-default)]
    (cond
     (= :no-default default-impl) (sm/state-maybe empty-list)

     (for [default-fn (fr/evaluate default-impl emit-c)
           _ (write-strs (.init default-fn))]
       (list (.c-val default-fn))))))

(defn emit-proto-arity [name fn-sym impls-sym arity]
  (let [num-args (nth arity 0 1)
        args (map (range num-args) (fn [idx] (str "arg" idx)))
        c-name (gensym "protoFnImpl_")
        arity-sym (gensym "protoFnArity_")]
    (for [type-name-fn (comp (for [type-name-sym (lookup-sym* 'type-name)
                                   type-name-arity-sym (lookup-static-fn (.c-val type-name-sym) 1)]
                               (str "%s\\n\", extractStr(" type-name-arity-sym "(empty_list, arg0))"))
                             (sm/state-maybe "%lld\\n\", arg0->type"))
          _ (apply-to list
                      (write-strs (list "Value *" c-name "("))
                      (write-strs
                       (interpose (cons "List *closures" (map args (fn [arg] (str "Value *" arg))))
                                  ", "))
                      (write-strs
                       (list ") {\n"
                             "  Function *implFn = (Function *)findProtoImpl(arg0->type, "
                             impls-sym ");\n"
                             "  if(implFn == (Function *)0) {\n"
                             "   fprintf(stderr, \"\\n*** Could not find proto impl for '"
                             name "' " type-name-fn ");\nabort();\n}\n"
                             "  FnArity *_arity = findFnArity((Value *)implFn, " num-args ");\n"
                             "  if(_arity == (FnArity *)0 || _arity->variadic) {\n"
                             "    fprintf(stderr, \"\\n*** Invalid number of args in call to '"
                             name "'\\n\");\n"
                             "    abort();\n}\n"
                             "  FnType" num-args " *_fn = (FnType" num-args " *)_arity->fn;\n"
                             "  return(_fn("))
                      (write-strs (interpose (cons "_arity->closures" args) ", "))
                      (write-strs (list "));\n}\n"
                                        "FnArity "
                                        (str arity-sym) " = {FnArityType, -1, "
                                        (str num-args) ", (List *)0, 0, "
                                        (str c-name) "};\n"))
                      (sm/assoc-in-val (list :static-fns (str "(Value *)&" fn-sym) num-args :fn-sym) c-name))]
      (str "&" arity-sym))))

(defn emit-proto-fn [protocol-name [name arities]]
  (let [arities (seq arities)
        qualified-name (str protocol-name name)
        impls-sym (gensym "protoImpls_")
        fn-sym (gensym "protoFn_")
        default-fn-sym (gensym "defaultFn_")]
    (for [fn-type (sm/get-in-val (list :types 'Function) :no-fn-type)
          _ (write-strs (list "ProtoImpls *" impls-sym ";\n"))
          _ (sm/assoc-in-val (list :defined-syms name)
                             (list (str "Function " fn-sym)
                                   (c-code (str "(Value *)&" fn-sym) empty-list ""
                                           fn-type)))
          _ (write-strs (list "Function " fn-sym ";\n"))
          default-syms (crush arities emit-proto-default)
          arity-syms (traverse arities (partial emit-proto-arity name fn-sym impls-sym))
          file-name (sm/get-val :file-name)
          _ (apply-to list
                      (cond
                       (empty? default-syms) (sm/state-maybe "")
                       (write-strs (list "Function " default-fn-sym " = {FunctionType, -1, \""
                                         name "\", " (count default-syms)
                                         ", {" (apply str (interpose default-syms ",\n"))
                                         "}};\n\n")))
                      (write-strs (list "Function " (str fn-sym)  " = {FunctionType, -1, \""
                                        (str name) "\", " (count arity-syms)
                                        ", {" (apply str (interpose arity-syms ",\n")) "}};\n\n"))

                      (sm/assoc-in-val (list :modules file-name :syms name)
                                       (list (str "Function " fn-sym)
                                             (c-code (str "(Value *)&" fn-sym) empty-list ""
                                                     fn-type)))
                      (sm/assoc-in-val (list :modules file-name :protos name) qualified-name)
                      (sm/assoc-in-val (list :defined-protos name) qualified-name)
                      (sm/assoc-in-val (list :protocols qualified-name)
                                       {:impls-sym impls-sym
                                        :name name
                                        :impls (cond
                                                (empty? default-syms) {}
                                                {:default {:fn-sym (str "(Value *)&" default-fn-sym)}})
                                        :extern-def (str "extern Function " fn-sym ";")}))]
      fn-sym)))

(extend-type ast/protocol-ast
  Emitter
  (emit-c [ast]
    (for [_ (static-values)
          file-name (sm/get-val :file-name)
          :let [qualified-proto-name (str file-name "/" (.protocol-name ast) "/")]
          result (traverse (seq (.prototypes ast)) (partial emit-proto-fn qualified-proto-name))]
      (c-code "" empty-list "" :no-type))))

(defn replace-type [types type-val-num name]
  (cond
   (empty? types) (list (list name type-val-num))
   (= (first (first types)) type-val-num) (cons (list name type-val-num)
                                                (rest types))
   (cons (first types) (replace-type (rest types) type-val-num name))))

(extend-type ast/type-ast
  Emitter
  (emit-c [ast]
    (comp
     (for [file-name (sm/get-val :file-name)
           _ (sm/get-in-val (list :modules file-name :types (.name ast)))]
       (let [_ (print-err (str "Trying to re-define type name: '" (.name ast) "' in module '"
                               file-name "'"))]
         (abort)))
     (for [types (sm/get-val :types)
           :let [new-type-name (.name ast)
                 type-val-num (+ 2 (count (seq types)))]

           _ (sm/assoc-in-val (list :type-names (dec type-val-num)) new-type-name)
           _ (an/analyze-expr type-val-num)
           _ (comp
              (traverse (.fields ast)
                        (fn [field]
                          (let [getter-name (symbol (str "." field))]
                            (comp (sm/get-in-val (list :protocols (str "Getter/" getter-name)))
                                  (emit-proto-fn "Getter/"
                                                 (list getter-name (list (list 1 {}))))))))
              (sm/state-maybe ""))
           proto-fn-info (comp (for [[def] (sm/get-in-val (list :defined-syms new-type-name))
                                     info (forward-decl new-type-name (subs def 7) (dec type-val-num))]
                                 info)
                               (forward-decl new-type-name (dec type-val-num)))


           :let [num-args (count (.fields ast))
                 invoke-sym (gensym "protoFnImpl_")
                 proto-fn-sym (.c-val proto-fn-info)]
           _ (sm/assoc-in-val (list :protocols "Function/invoke" :impls (dec type-val-num) :fn-sym)
                              (str proto-fn-sym))
           _ (write-strs (list "Value *" invoke-sym))
           _ (write-strs (interpose (cons "(List *, Value *" (map (.fields ast) (fn [_] "Value *"))) ", "))
           _ (write ");\n")
           _ (sm/assoc-in-val (list :static-fns (str proto-fn-sym) (inc num-args))
                              {:fn-sym invoke-sym
                               :return-type type-val-num})

           type-ast (an/analyze-expr (list 'reify
                                           'Type
                                           (list 'instance? (list 'vector '_ 'v)
                                                 (list '= type-val-num (list 'get-type 'v)))
                                           'Applicative
                                           (list 'apply* (list 'vector '_ 'args)
                                                 (list 'apply 'invoke '_ 'args))
                                           'Function
                                           (list 'invoke (cons 'vector (cons '_ (.fields ast)))
                                                 (list*
                                                  'reify
                                                  'Getter
                                                  (list 'type-args (list 'vector '_)
                                                        (list* 'list (.fields ast)))
                                                  (cdr (.impls ast))))))
           _ (static-values)
           result (define-fwd-decl new-type-name type-ast)

           file-name (sm/get-val :file-name)
           _ (sm/assoc-in-val (list :modules file-name :types new-type-name) type-val-num)
           _ (sm/assoc-in-val (list :defined-types new-type-name) type-val-num)

           _ (sm/update-in-val (list :types)
                               (fn [types]
                                 (reduce (replace-type (seq types) type-val-num new-type-name)
                                         {}
                                         (fn [m kv]
                                           (apply assoc m kv)))))]
       result))))

(defn core-base-fns []
  (write-strs (list "\n"
                    "extern FILE *outStream;\n"
                    "extern long long malloc_count;\n"
                    "extern long long free_count;\n"
                    "extern int recycledFunction;\n"
                    "extern int recycledReified;\n"
                    "extern Value* true;\n"
                    "extern Value* false;\n"
                    "extern Number trueVal;\n"
                    "extern Number falseVal;\n"
                    "extern int bitpos(int64_t hash, int shift);\n"
                    "extern int mask(int64_t hash, int shift);\n"
                    "extern char *extractStr(Value *v);\n"
                    "extern Value *my_malloc(int64_t);\n"
                    "extern SubString *malloc_substring();\n"
                    "extern FnArity *malloc_fnArity();\n"
                    "extern List *malloc_list();\n"
                    "extern Number *malloc_number();\n"
                    "extern Function *malloc_function(int arityCount);\n"
                    "extern ReifiedVal *malloc_reified(int implCount);\n"
                    "extern void incRef(Value *);\n"
                    "extern void decRef(Value *);\n"
                    "extern void dec_and_free(Value *);\n"
                    "extern int64_t isTrue(Value *boolVal);\n"
                    "extern Value *findProtoImpl(int64_t type, ProtoImpls *impls);\n"
                    "extern FnArity *findFnArity(Value *fnVal, int64_t argCount);\n"
                    "extern Value *stringValue(char *s);\n"
                    "extern Value *keywordValue(char *s);\n"
                    "extern Value *symbolValue(char *s);\n"
                    "extern Value *makeSubstr(int64_t len, Value *str, char *subsStart);\n"
                    "extern Value *numberValue(int64_t n);\n"
                    "extern List *listCons(Value *x, List *l);\n")))

(defn base-fns []
  (write-strs (list "\n"
                    "FILE *outStream;\n"
                    "Number trueVal = {NumberType, -1, 1};\n"
                    "Value* true = (Value *)&trueVal;\n"
                    "Number falseVal = {NumberType, -1, 0};\n"
                    "Value* false = (Value *)&falseVal;\n"
                    "long long malloc_count = 0;\n"
                    "long long free_count = 0;\n"
                    "\n"

                    "int mask(int64_t hash, int shift) {\n"
                    "  return (hash >> shift) & 0x1f;\n"
                    "}\n\n"

                    "int bitpos(int64_t hash, int shift) {\n"
                    "  return 1 << mask(hash, shift);\n"
                    "}\n\n"

                    "void incRef(Value *v) {\n"
                    "  if (v == (Value *)0) {\n"
                    "    fprintf(stderr, \"why are you incRefing 'null'\\n\");\n "
                    "    abort();\n"
                    "  } else if (v->refs < -1) {\n"
                    "    fprintf(stderr, \"incRefing: %p\\n\", v);\n"
                    "    abort();\n"
                    "  } else if (v->refs >= 0)\n"
                    "    v->refs++;\n"
                    "  return;\n"
                    "}\n\n"

                    "void decRef(Value *v) {\n"
                    "  if (v == (Value *)0) {\n"
                    "    fprintf(stderr, \"why are you decRefing 'null'\\n\");\n "
                    "    abort();\n"
                    "  } else if (v->refs < -1) {\n"
                    "    fprintf(stderr, \"decRefing: %p\\n\", v);\n"
                    "  } else if (v->refs == -1) {\n"
                    "    return;\n"
                    "  } else if (v->refs == 0) {\n"
                    "    fprintf(stderr, \"decRef already at 0: %p\\n\", v);\n"
                    "    return;\n"
                    "  } else {\n"
                    "    v->refs--;\n"
                    "    return;\n"
                    "  }\n"
                    "}\n"

                    "Value *my_malloc(int64_t sz) {\n"
                    "  malloc_count++;\n"
                    "  Value *val = malloc(sz);\n"
                    "  if (sz > sizeof(Value))\n    val->refs = 1;\n"
                    "  return(val);\n"
                    "}\n\n"

                    "typedef struct DirectLL {int64_t type; struct DirectLL *next;} DirectLL;\n\n"

                    "DirectLL *freeSubStrings = (DirectLL *)0;\n"
                    "SubString *malloc_substring() {\n"
                    ;;"  return((SubString *)my_malloc(sizeof(SubString)));\n"
                    "  if (freeSubStrings == (DirectLL *)0) {\n"
                    "    malloc_count--;\n"
                    "    return((SubString *)my_malloc(sizeof(SubString)));\n"
                    "  } else {\n"
                    "    DirectLL *subStr = freeSubStrings;\n"
                    "    freeSubStrings = subStr->next;\n"
                    "    ((SubString *)subStr)->refs = 1;\n"
                    "    ((SubString *)subStr)->hash = (Number *)0;\n"
                    "    return((SubString *)subStr);\n"
                    "  }\n"
                    "}\n\n"

                    "int recycledReified = 0;\n"
                    "DirectLL *freeReified[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\n"
                    "ReifiedVal *malloc_reified(int implCount) {\n"
                    ;; "  return((ReifiedVal *)my_malloc(sizeof(ReifiedVal) + sizeof(Function *) * implCount));\n"
                    "  if (implCount > 19 || freeReified[implCount] == (DirectLL *)0) {\n"
                    "    malloc_count--;\n"
                    "    return((ReifiedVal *)my_malloc(sizeof(ReifiedVal) + sizeof(Function *) * implCount));\n"
                    "  } else {\n"
                    "    recycledReified++;"
                    "    DirectLL *newReifiedVal = freeReified[implCount];\n"
                    "    freeReified[implCount] = newReifiedVal->next;\n"
                    "    ((ReifiedVal *)newReifiedVal)->refs = 1;\n"
                    "    return((ReifiedVal *)newReifiedVal);\n"
                    "  }\n"
                    "}\n\n"

                    "int recycledFunction = 0;\n"
                    "DirectLL *freeFunctions[10] = {0,0,0,0,0,0,0,0,0,0};\n"
                    "Function *malloc_function(int arityCount) {\n"
                    ;; "  return((Function *)my_malloc(sizeof(Function) + sizeof(FnArity *) * arityCount));\n"
                    "  if (arityCount > 9 || freeFunctions[arityCount] == (DirectLL *)0) {\n"
                    "    malloc_count--;\n"
                    "    return((Function *)my_malloc(sizeof(Function) + sizeof(FnArity *) * arityCount));\n"
                    "  } else {\n"
                    "    recycledFunction++;\n"
                    "    DirectLL *newFunction = freeFunctions[arityCount];\n"
                    "    freeFunctions[arityCount] = newFunction->next;\n"
                    "    ((Function *)newFunction)->refs = 1;\n"
                    "    return((Function *)newFunction);\n"
                    "  }\n"
                    "}\n\n"

                    "DirectLL *freeNumbers = (DirectLL *)0;\n"
                    "Number *malloc_number() {\n"
                    ;; "  return((Number *)my_malloc(sizeof(Number)));\n"
                    "  if (freeNumbers == (DirectLL *)0) {\n"
                    "    Number *numberStructs = (Number *)my_malloc(sizeof(Number) * 100);\n"
                    "    malloc_count--;"
                    "    for (int i = 99; i > 0; i--) {\n"
                    "      ((DirectLL *)&numberStructs[i])->next = freeNumbers;\n"
                    "      freeNumbers = (DirectLL *)&numberStructs[i];\n"
                    "    }\n"
                    "    return(numberStructs);\n"
                    "  } else {\n"
                    "    DirectLL *newNumber = freeNumbers;\n"
                    "    freeNumbers = newNumber->next;\n"
                    "    ((Number *)newNumber)->refs = 1;\n"
                    "    return((Number *)newNumber);\n"
                    "  }\n"
                    "}\n\n"

                    "DirectLL *freeLists = (DirectLL *)0;\n"
                    "List *malloc_list() {\n"
                    ;; "    return((List *)my_malloc(sizeof(List)));\n"
                    "  if (freeLists == (DirectLL *)0) {\n"
                    "    List *listStructs = (List *)my_malloc(sizeof(List) * 500);\n"
                    "    malloc_count--;\n"
                    "    for (int i = 499; i > 0; i--) {\n"
                    "      ((DirectLL *)&listStructs[i])->next = freeLists;\n"
                    "      freeLists = (DirectLL *)&listStructs[i];\n"
                    "    }\n"
                    "    return(listStructs);\n"
                    "  } else {\n"
                    "    DirectLL *newList = freeLists;\n"
                    "    freeLists = newList->next;\n"
                    "    ((List *)newList)->refs = 1;\n"
                    "    return((List *)newList);\n"
                    "  }\n"
                    "}\n\n"

                    "DirectLL *freeFnAritys = (DirectLL *)0;\n"
                    "FnArity *malloc_fnArity() {\n"
                    ;; "  return((FnArity *)my_malloc(sizeof(FnArity)));\n"
                    "  if (freeFnAritys == (DirectLL *)0) {\n"
                    "    malloc_count--;\n"
                    "    return((FnArity *)my_malloc(sizeof(FnArity)));\n"
                    "  } else {\n"
                    "    DirectLL *newFnArity = freeFnAritys;\n"
                    "    freeFnAritys = newFnArity->next;\n"
                    "    ((FnArity *)newFnArity)->refs = 1;\n"
                    "    return((FnArity *)newFnArity);\n"
                    "  }\n"
                    "}\n\n"

                    "DirectLL *freeBMINodes[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\n"
                    "BitmapIndexedNode *malloc_bmiNode(int itemCount) {\n"
                    "  int nodeSize = sizeof(BitmapIndexedNode) + sizeof(Value *) * (itemCount * 2);\n"
                    "  BitmapIndexedNode *bmiNode;\n"
                    "  if (freeBMINodes[itemCount] == (DirectLL *)0) {\n"
                    "    malloc_count--;\n"
                    "    bmiNode = (BitmapIndexedNode *)my_malloc(nodeSize);\n"
                    "  } else {\n"
                    "    bmiNode = (BitmapIndexedNode *)freeBMINodes[itemCount];\n"
                    "    freeBMINodes[itemCount] = ((DirectLL *)bmiNode)->next;\n"
                    "  }\n"
                    "  memset(bmiNode, 0, nodeSize);\n"
                    "  bmiNode->type = BitmapIndexedType;\n"
                    "  bmiNode->refs = 1;\n"
                    "  return(bmiNode);\n"
                    "}\n\n"

                    "HashCollisionNode *malloc_hashCollisionNode(int itemCount) {\n"
                    "  if (itemCount > 30000) {\n"
                    "     fprintf(stderr, \"Catastrophic failure: Too many hash collisions\\n\");"
                    "     abort();\n"
                    "  }\n"
                    "  int nodeSize = sizeof(HashCollisionNode) + sizeof(Value *) * (itemCount * 2);\n"
                    "  HashCollisionNode *collisionNode;\n"
                    "  collisionNode = (HashCollisionNode *)my_malloc(nodeSize);\n"
                    "  memset(collisionNode, 0, nodeSize);\n"
                    "  collisionNode->type = HashCollisionNodeType;\n"
                    "  collisionNode->count = itemCount * 2;\n"
                    "  collisionNode->refs = 1;\n"
                    "  return(collisionNode);\n"
                    "}\n\n"

                    "DirectLL *freeArrayNodes = (DirectLL *)0;\n"
                    "ArrayNode *malloc_arrayNode() {\n"
                    "  ArrayNode *arrayNode;\n"
                    "  if (freeArrayNodes == (DirectLL *)0) {\n"
                    "    malloc_count--;\n"
                    "    arrayNode = (ArrayNode *)my_malloc(sizeof(ArrayNode));\n"
                    "  } else {\n"
                    "    arrayNode = (ArrayNode *)freeArrayNodes;\n"
                    "    freeArrayNodes = ((DirectLL *)arrayNode)->next;\n"
                    "  }\n"
                    "  memset(arrayNode, 0, sizeof(ArrayNode));\n"
                    "  arrayNode->type = ArrayNodeType;\n"
                    "  arrayNode->refs = 1;\n"
                    "  return(arrayNode);"
                    "}\n\n"

                    "void dec_and_free(Value *v) {\n"
                    "  if (v == (Value *)0) {\n"
                    "    fprintf(stderr, \"why are you freeing 'null'\\n\");\n "
                    "    abort();\n"
                    "  } else if (v->refs == -10) {\n"
                    "    fprintf(stderr, \"freeing already freed struct\\n\");\n"
                    "    abort();\n"
                    "  } else if (v->refs == -1) {\n"
                    "    return;\n"
                    "  } else if (v->refs > 1) {\n"
                    "    v->refs--;\n"
                    "    return;\n"
                    "  } else if (v->type == 0) {\n"
                    "    fprintf(stderr, \"freeing invalid type\\n\");\n"
                    "    abort();\n"
                    "  } else if (v->type == StringType) {\n"
                    "    v->refs = -10;\n"
                    "    free_count++;\n"
                    "    free(v);\n"
                    "  } else if (v->type == NumberType) {\n"
                    "    v->refs = -10;\n"
                    "    ((DirectLL *)v)->next = freeNumbers;\n"
                    "    freeNumbers = (DirectLL *)v;\n"
                    ;; "    free_count++;\n"
                    ;; "    free(v);\n"
                    "  } else if (v->type == FunctionType) {\n"
                    "    Function *f = (Function *)v;\n"
                    "    for (int i = 0; i < f->arityCount; i++) {\n"
                    "      dec_and_free((Value *)f->arities[i]);\n"
                    "    }\n"
                    "    v->refs = -10;\n"
                    "    if (f->arityCount < 10) {\n"
                    "      DirectLL *freedList = freeFunctions[f->arityCount];\n"
                    "      freeFunctions[f->arityCount] = (DirectLL *)v;\n"
                    "      ((DirectLL *)v)->next = freedList;\n"
                    "    } else {\n"
                    "      free_count++;\n"
                    "      free(v);\n"
                    "    }"
                    "  } else if (v->type == ListType) {\n"
                    "    Value *head = ((List *)v)->head;\n"
                    "    List *tail = ((List *)v)->tail;\n"
                    "    v->refs = -10;\n"
                    "    if (head != (Value *)0) {\n"
                    "      dec_and_free(head);\n"
                    "    }\n"
                    "    if (tail != (List *)0) {\n"
                    "      dec_and_free((Value *)tail);\n"
                    "    }\n"
                    "    ((DirectLL *)v)->next = freeLists;\n"
                    "    freeLists = (DirectLL *)v;\n"
                    ;; "    free_count++;\n"
                    ;; "    free(v);\n"
                    "  } else if (v->type == KeywordType ||\n"
                    "             v->type == SubStringType ||\n"
                    "             v->type == SymbolType) {\n"
                    "    Value *src = ((SubString *)v)->source;\n"
                    "    Number *hash = ((SubString *)v)->hash;\n"
                    "    v->refs = -10;\n"
                    "    if (src != (Value *)0) {\n"
                    "      dec_and_free(src);\n"
                    "    }\n"
                    "    if (v->type == KeywordType && hash != (Number *)0) {\n"
                    "      dec_and_free((Value *)hash);\n"
                    "    }\n"
                    "    ((DirectLL *)v)->next = freeSubStrings;\n"
                    "    freeSubStrings = (DirectLL *)v;\n"
                    ;; "    free_count++;\n"
                    ;; "    free(v);\n"
                    "  } else if (v->type == FnArityType) {\n"
                    "    FnArity *arity = (FnArity *)v;\n"
                    "    dec_and_free((Value *)arity->closures);\n"
                    "    v->refs = -10;\n"
                    "    ((DirectLL *)v)->next = freeFnAritys;\n"
                    "    freeFnAritys = (DirectLL *)v;\n"
                    ;; "    free_count++;\n"
                    ;; "    free(v);\n"
                    "  } else if (v->type == OpaqueType) {\n"
                    "    v->refs = -10;\n"
                    "  } else if (v->type == BitmapIndexedType) {\n"
                    "    // fprintf(stderr, \"%p free bmi node\\n\", v);\n"
                    "    BitmapIndexedNode *node = (BitmapIndexedNode *)v;\n"
                    "    int cnt = __builtin_popcount(node->bitmap);\n"
                    "    for (int i = 0; i < (2 * cnt); i++) {\n"
                    "       if (node->array[i] != (Value *)0) {\n"
                    "          dec_and_free(node->array[i]);\n"
                    "       }\n"
                    "    }\n"
                    "    v->refs = -10;\n"
                    "    ((DirectLL *)v)->next = freeBMINodes[cnt];\n"
                    "    freeBMINodes[cnt] = (DirectLL *)v;\n"
                    ;; "    free_count++;\n"
                    ;; "    free(v);\n"
                    "  } else if (v->type == ArrayNodeType) {\n"
                    "    ArrayNode *node = (ArrayNode *)v;\n"
                    "    for (int i = 0; i < 32; i++) {\n"
                    "       if (node->array[i] != (Value *)0) {\n"
                    "          dec_and_free(node->array[i]);\n"
                    "       }\n"
                    "    }\n"
                    "    v->refs = -10;\n"
                    "    ((DirectLL *)v)->next = freeArrayNodes;\n"
                    "    freeArrayNodes = (DirectLL *)v;\n"
                    ;; "    free_count++;\n"
                    ;; "    free(v);\n"
                    "  } else if (v->type == HashCollisionNodeType) {\n"
                    "    HashCollisionNode *node = (HashCollisionNode *)v;\n"
                    "    for (int i = 0; i < node->count; i++) {\n"
                    "       if (node->array[i] != (Value *)0) {\n"
                    "          dec_and_free(node->array[i]);\n"
                    "       }\n"
                    "    }\n"
                    "    v->refs = -10;\n"
                    "    free_count++;\n"
                    "    free(v);\n"
                    "  } else {\n"
                    "    ReifiedVal *rv = (ReifiedVal *)v;\n"
                    "    for (int i = 0; i < rv->implCount; i++) {\n"
                    "      dec_and_free(rv->impls[i]);\n"
                    "    }\n"
                    "    v->refs = -10;\n"
                    "    if (rv->implCount < 20) {\n"
                    "      DirectLL *freedList = freeReified[rv->implCount];\n"
                    "      freeReified[rv->implCount] = (DirectLL *)v;\n"
                    "      ((DirectLL *)v)->next = freedList;\n"
                    "    } else {\n"
                    "      free_count++;\n"
                    "      free(v);\n"
                    "    }"
                    "  }\n"
                    "  // fprintf(stderr, \"malloc_count: %lld free_count: %lld\\r\", malloc_count, free_count);\n"
                    "};\n"

                    ;; this fn only gets called while printing a
                    ;; message before aborting.
                    "char *extractStr(Value *v) {\n"
                    "String *newStr = (String *)my_malloc(sizeof(String) + ((String *)v)->len + 5);\n"
                    "if (v->type == StringType)\n"
                    "snprintf(newStr->buffer, ((String *)v)->len + 1, \"%s\", ((String *)v)->buffer);\n"
                    "else if (v->type == SubStringType)\n"
                    "snprintf(newStr->buffer, ((String *)v)->len + 1, \"%s\", ((SubString *)v)->buffer);\n"
                    "else {\n"
                    "fprintf(stderr, \"\\ninvalid type for 'extractStr'\\n\");\n"
                    "abort();\n"
                    "}\n"
                    "return(newStr->buffer);\n}\n\n"

                    "int64_t isTrue(Value *boolVal) {\n"
                    "if (boolVal->type != NumberType) {\n"
                    "fprintf(outStream, \"Invalid boolean value\\n"
                    "\");\nabort();\n}\nelse\nreturn(((Number *)boolVal)->numVal);\n}\n"
                    "\n"

                    "Value *findProtoImpl(int64_t type, ProtoImpls *impls) {\n"
                    "int64_t implIndex = 0;\n"
                    "while(implIndex < impls->implCount) {\n"
                    "if (type != impls->impls[implIndex].type) {\n"
                    "implIndex++;\n"
                    "} else\n"
                    "return(impls->impls[implIndex].implFn);\n"
                    "}\n"
                    "return(impls->defaultImpl);\n"
                    "};\n\n"

                    "FnArity *findFnArity(Value *fnVal, int64_t argCount) {\n"
                    "Function *fn = (Function *)fnVal;\n"
                    "int arityIndex = 0;\n"
                    "FnArity *arity = (FnArity *)fn->arities[arityIndex];\n"
                    "FnArity *variadic = (FnArity *)0;\n"
                    "while(arityIndex < fn->arityCount) {\n"
                    "arity = (FnArity *)fn->arities[arityIndex];\n"
                    "if (arity->variadic) {\n"
                    "variadic = arity;\n"
                    "arityIndex++;\n"
                    "} else if (arity->count != argCount) {\n"
                    "arityIndex++;\n"
                    "} else\n"
                    "return(arity);\n"
                    "}\n"
                    "return(variadic);\n"
                    "};\n\n"
                    "\n"

                    "Value *stringValue(char *s) {\n"
                    "int64_t len = strlen(s);\n"
                    "String *strVal = (String *)my_malloc(sizeof(String) + len + 4);\n"
                    "strVal->type = StringType;\n"
                    "strVal->len = strlen(s);\n"
                    "strncpy(strVal->buffer, s, len);\n"
                    "return((Value *)strVal);\n"
                    "};\n"
                    "\n"

                    "Value *symbolValue(char *s) {\n"
                    "SubString *sym = malloc_substring();\n"
                    "sym->type = SymbolType;\n"
                    "sym->buffer = s;\n"
                    "sym->len = strlen(s);\n"
                    "sym->source = (Value *)0;\n"
                    "sym->hash = (Number *)0;\n"
                    "return((Value *)sym);\n"
                    "};\n"
                    "\n"

                    "Value *keywordValue(char *s) {\n"
                    "SubString *kw = malloc_substring();\n"
                    "kw->type = KeywordType;\n"
                    "kw->buffer = s;\n"
                    "kw->hash = (Number *)0;\n"
                    "kw->len = strlen(s);\n"
                    "kw->source = (Value *)0;\n"
                    "return((Value *)kw);\n"
                    "};\n"
                    "\n"

                    "Value *makeSubstr(int64_t len, Value *str, char *subsStart) {\n"
                    "SubString *subStr = malloc_substring();\n"
                    "subStr->type = SubStringType;\n"
                    "subStr->len = len;\n"
                    "subStr->source = str;\n"
                    "subStr->hash = (Number *)0;\n"
                    "incRef(str);\n"
                    "subStr->buffer = subsStart;\n"
                    "return((Value *)subStr);}\n"
                    "\n"

                    "Value *numberValue(int64_t n) {\n"
                    "Number *numVal = malloc_number();\n"
                    "numVal->type = NumberType;\n"
                    "numVal->numVal = n;\n"
                    "return((Value *)numVal);\n"
                    "};\n"
                    "\n"

                    "List *listCons(Value *x, List *l) {\n"
                    "  if (l->type != ListType) {\n"
                    "    fprintf(stderr, \"'cons' requires a list\\n\");\n"
                    "    abort();\n"
                    "  }\n"
                    "  List *newList = malloc_list();\n"
                    "  newList->type = ListType;\n"
                    "  newList->len = l->len + 1;\n"
                    "  newList->head = (Value *)x;\n"
                    "  newList->tail = l;\n"
                    "  return(newList);\n"
                    "};\n")))

(defn emit-impl [default-sym impls]
  (let [impls-strs (map impls (fn [[type-num type-info]]
                                (let [fn-sym (:fn-sym type-info)]
                                  (str "{" type-num ", " fn-sym "}"))))]
    (apply-to list
              (write-strs (list "{" (count impls-strs) ", " default-sym ", {"))
              (write-strs (interpose impls-strs ", "))
              (write "}};\n"))))

(defn finalize-protocols []
  (for [protocols (sm/get-val :protocols)
        result (comp
                (traverse (seq protocols)
                          (fn [proto]
                            (let [proto-impls (nth proto 1 {})
                                  impls-sym (get proto-impls :impls-sym "")
                                  impls-map (get proto-impls :impls {})
                                  impls (filter (seq impls-map)
                                                (fn [[type]]
                                                  (cond
                                                   (= type :default) false
                                                   (= type :no-type) false
                                                   true)))
                                  local-sym (gensym "localImpls_")]
                              (for [_ (write-strs (list "extern ProtoImpls *" impls-sym ";\n"))
                                    _ (write-strs (list "ProtoImpls " local-sym " = "))
                                    _ (match (get-in impls-map (list :default :fn-sym))
                                             |maybe default-sym| (emit-impl default-sym impls)
                                             (emit-impl "(Value *)0" impls))]
                                (list impls-sym local-sym)))))
                (sm/state-maybe ""))]
    result))

(defn emit-main []
  (for [_ (sm/set-val :local-sym-count 0)
        main-sym (sm/get-val :main-sym)
        proto-syms (finalize-protocols)
        _ (write-strs (list "\nint main(int argc, char *argv[]) {\n"))
        _ (traverse proto-syms
                    (fn [[impls-sym local-sym]]
                      (write-strs (list "  " impls-sym " = &" local-sym ";\n"))))
        _ (write-strs (list "     outStream = stdout;\n"
                            "     List *argList = malloc_list();\n"
                            "      argList->type = ListType;\n"
                            "      argList->len = 0;\n"
                            "      argList->head = (Value *)0;\n"
                            "      argList->tail = (List *)0;\n"
                            "      List *tail = argList;\n"
                            "      for(int i = 0; i < argc; i++) {\n"
                            "         List *newTail = malloc_list();\n"
                            "         newTail->type = ListType;\n"
                            "         newTail->len = 0;\n"
                            "         newTail->tail = (List *)0;\n"
                            "         newTail->head = (Value *)0;\n"
                            "         tail->head = stringValue(argv[i]);\n"
                            "         tail->tail = newTail;\n"
                            "         tail = newTail;\n"
                            "         argList->len++;\n}\n"))
        _ (write-strs (list "  int the_final_answer = " main-sym "((Value *)argList);\n"
                            "  decRef((Value *)argList);\n"
                            "  dec_and_free((Value *)argList);\n"
                            "  fprintf(stderr, \"malloc count: %lld  free count: %lld  diff: %lld\\n\""
                            ", malloc_count, free_count, malloc_count - free_count);\n"
                            "  return(the_final_answer);\n};\n"))]
    ""))

(defn protocols []
  (inline-text "return(protocols());"))

(defn load-protocols []
  (let [protos (protocols)
        protos (map protos
                    (fn [[proto-name impls-sym extern-def impls name]]
                      (let [impls (reduce impls
                                          {}
                                          (fn [m [type-num fn-sym]]
                                            (assoc m type-num {:fn-sym fn-sym})))]
                        (list proto-name {:impls-sym impls-sym
                                          :name name
                                          :extern-def extern-def
                                          :impls impls}))))
        proto-map (reduce (map protos
                               (fn [[qualified-name proto-info]]
                                 (list (:name proto-info) qualified-name)))
                          {}
                          (fn [m [k v]]
                            (assoc m k v)))]
    (apply-to list
              (sm/set-val :protocols (reduce protos
                                             {}
                                             (fn [m [k v]]
                                               (assoc m k v))))
              (sm/assoc-in-val (list :modules "core" :protos) proto-map)
              (sm/set-val :defined-protos proto-map)
              (traverse protos
                        (fn [[_ proto-info]]
                          (let [impls (get proto-info :impls {})]
                            (comp
                             (traverse (seq impls)
                                       (fn [[_ fn-info]]
                                         (write-strs (list "extern Function "
                                                           (subs (:fn-sym fn-info) 10) ";\n"))))
                             (sm/state-maybe ""))))))))

(defn serialize-protocols []
  (for [protos (sm/get-val :protocols)
        _ (write "Value *protocols() {\n")
        _ (write "List *protos = empty_list;\n")
        _ (write "List *protoInfo;\n")
        _ (write "List *impls;\n")
        _ (write "List *impl;\n")
        _ (write-strs (flat-map (seq protos)
                                (fn [proto-inf]
                                  (let [impls-info (nth proto-inf 1 empty-list)
                                        impl-fn-name (get impls-info :name "")
                                        impls-sym (get impls-info :impls-sym "")
                                        extern-def (get impls-info :extern-def "")
                                        impls (seq (get impls-info :impls empty-list))]
                                    (comp (list "protoInfo = empty_list;\n"
                                                "impls = empty_list;\n")
                                          (map (seq impls)
                                               (fn [impl]
                                                 (let [impl-type (nth impl 0 0)]
                                                   (str "impl = empty_list;\n"
                                                        "impl = listCons(stringValue(\""
                                                        (:fn-sym (nth impl 1 ""))
                                                        "\"), impl);\n"
                                                        "impl = listCons("
                                                        (cond
                                                         (= :default impl-type)
                                                         "keywordValue(\":default\")"

                                                         (str "numberValue(" impl-type ")"))
                                                        ", impl);\n"
                                                        "impls = listCons((Value *)impl, impls);\n"))))
                                          (list "protoInfo = listCons(symbolValue(\"" impl-fn-name
                                                             "\"), protoInfo);\n"
                                                "protoInfo = listCons((Value *)impls, protoInfo);\n"
                                                "protoInfo = listCons(stringValue(\"" extern-def "\"), protoInfo);\n"
                                                "protoInfo = listCons(stringValue(\"" impls-sym "\"), protoInfo);\n"
                                                "protoInfo = listCons(stringValue(\"" (first proto-inf)
                                                "\"), protoInfo);\n"
                                                "protos = listCons((Value *)protoInfo, protos);\n"))))))
        _ (write "return((Value *)protos);\n")
        _ (write "}\n\n")]
    ""))

(defn static-fns []
  (inline-text "return(static_fns());"))

(defn load-static-fns []
  (let [s-funs (static-fns)
        s-funs (map s-funs
                    (fn [[fn-name arities]]
                      (list fn-name (reduce arities
                                            {}
                                            (fn [arities arity]
                                              (let [arg-count (nth arity 0)
                                                    fn-sym (nth arity 1)
                                                    return-type (nth arity 2 :no-type)]
                                                (assoc arities arg-count {:return-type return-type
                                                                          :fn-sym fn-sym})))))))]
    (sm/set-val :core-static-fns (reduce s-funs
                                         {}
                                         (fn [s-funs s-fun]
                                           (apply assoc s-funs s-fun))))))

(defn serialize-static-fns []
  (for [s-fns (sm/get-val :static-fns)
        _ (write "Value *static_fns() {\n")
        _ (write "List *staticFns = empty_list;\n")
        _ (write "List *fnInfo;\n")
        _ (write "List *arityInfo;\n")
        _ (write-strs (flat-map (seq s-fns)
                                (fn [[name arities]]
                                  (comp
                                   (list "fnInfo = empty_list;\n")
                                   (flat-map (seq arities)
                                             (fn [[arg-count arity-info]]
                                               (let [arity-sym (get arity-info :fn-sym "")
                                                     return-type (get arity-info :return-type :no-type)]
                                                 (comp
                                                  (list "arityInfo = listCons("
                                                        (cond
                                                         (= :no-type return-type) "keywordValue(\":no-type\""
                                                         (str "numberValue(" return-type))
                                                        "), empty_list);\n")
                                                  (list "arityInfo = listCons(stringValue(\"" arity-sym
                                                        "\"), arityInfo);\n")
                                                  (cond
                                                   (= :variadic arg-count)
                                                   (list "arityInfo = listCons(keywordValue(\":variadic\")"
                                                         ", arityInfo);\n")

                                                   (list "arityInfo = listCons(numberValue(" arg-count
                                                         "), arityInfo);\n"))
                                                  (list "fnInfo = listCons((Value *)arityInfo, fnInfo);\n")))))
                                   (list "fnInfo = listCons((Value *)fnInfo, empty_list);\n"
                                         "fnInfo = listCons(stringValue(\"" name "\"), fnInfo);\n"
                                         "staticFns = listCons((Value *)fnInfo, staticFns);\n")))))
        _ (write "return((Value *)staticFns);\n")
        _ (write "}\n\n")]
    ""))

(defn defined-syms []
  (inline-text "return(defined_syms());"))

(defn load-defined-syms []
  (let [defined (reduce (defined-syms)
                        {}
                        (fn [m [k v]]
                          (let [[ext ref] v
                                type-num (nth v 2 :no-type)]
                            (assoc m k (list ext (c-code ref empty-list "" type-num))))))]
    (sm/set-val :core-defined-syms defined)))

(defn serialize-defined-syms []
  (for [def-syms (sm/get-val :defined-syms)
        _ (write "Value *defined_syms() {\n")
        _ (write "List *defSyms = empty_list;\n")
        _ (write "List *symInfo;\n")
        _ (write-strs (flat-map (seq def-syms)
                                (fn [def]
                                  (let [[sym [ext ref]] def
                                        c-ref (.c-val ref)
                                        type-num (.type-num ref)]
                                    (list
                                     "symInfo = listCons("
                                     (cond
                                      (= :no-type type-num) "keywordValue(\":no-type\""
                                      (str "numberValue(" type-num))
                                     "), empty_list);\n"
                                     "symInfo = listCons(stringValue(\"" c-ref "\"), symInfo);\n"
                                     "symInfo = listCons(stringValue(\"" ext "\"), symInfo);\n"
                                     "symInfo = listCons((Value *)symInfo, empty_list);\n"
                                     "symInfo = listCons(symbolValue(\"" sym "\"), symInfo);\n"
                                     "defSyms = listCons((Value *)symInfo, defSyms);\n")))))
        _ (write "return((Value *)defSyms);\n")
        _ (write "}\n\n")]
    ""))

(defn number-literals []
  (inline-text "return(number_literals());"))

(defn load-number-literals []
  (let [nums (reduce (number-literals)
                     {}
                     (fn [m kv]
                       (apply assoc m kv)))]
    (apply-to list
              (sm/set-val :num-count (inc (count nums)))
              (sm/set-val :core-numbers nums))))

(defn serialize-number-literals []
  (for [nums (sm/get-val :numbers)
        _ (write "Value *number_literals() {\n")
        _ (write "List *nums = empty_list;\n")
        _ (write "List *numInfo;\n")
        _ (write-strs (flat-map (seq nums)
                                (fn [[num ref]]
                                  (list "numInfo = listCons(stringValue(\"" ref "\"), empty_list);\n"
                                        "numInfo = listCons(numberValue(" num "), numInfo);\n"
                                        "nums = listCons((Value *)numInfo, nums);\n"))))
        _ (write "return((Value *)nums);\n")
        _ (write "}\n\n")]
    ""))

(defn string-literals []
  (inline-text "return(string_literals());\n"))

(defn load-string-literals []
  (let [strs (reduce (string-literals)
                     {}
                     (fn [m [k v]]
                       (assoc m k v)))]
    (apply-to list
              (sm/set-val :str-count (count strs))
              (sm/set-val :core-strings strs))))

(defn serialize-string-literals []
  (for [strs (sm/get-val :strings)
        _ (write "Value *string_literals() {\n")
        _ (write "List *strs = empty_list;\n")
        _ (write "List *strInfo;\n")
        _ (write-strs (flat-map (seq strs)
                                (fn [[str-val ref]]
                                  (list "strInfo = listCons(stringValue(\"" ref "\"), empty_list);\n"
                                        "strInfo = listCons(stringValue(\"" (escape-chars str-val)
                                        "\"), strInfo);\n"
                                        "strs = listCons((Value *)strInfo, strs);\n"))))
        _ (write "return((Value *)strs);\n")
        _ (write "}\n\n")]
    ""))

(defn keyword-literals []
  (inline-text "return(keyword_literals());\n"))

(defn load-keyword-literals []
  (let [kws (reduce (keyword-literals)
                     {}
                     (fn [m kv]
                       (apply assoc m kv)))]
    (apply-to list
              (sm/set-val :kw-count (count kws))
              (sm/set-val :core-keywords kws))))

(defn serialize-keyword-literals []
  (for [kws (sm/get-val :keywords)
        _ (write "Value *keyword_literals() {\n")
        _ (write "List *kws = empty_list;\n")
        _ (write "List *kwInfo;\n")
        _ (write-strs (flat-map (seq kws)
                                (fn [kw-lit]
                                  (let [kw (first kw-lit)
                                        ref (second kw-lit)]
                                    (list
                                     "kwInfo = listCons(stringValue(\"" ref "\"), empty_list);\n"
                                     "kwInfo = listCons(keywordValue(\"" kw "\"), kwInfo);\n"
                                     "kws = listCons((Value *)kwInfo, kws);\n")))))
        _ (write "return((Value *)kws);\n")
        _ (write "}\n\n")]
    ""))

(defn symbol-literals []
  (inline-text "return(symbol_literals());\n"))

(defn load-symbol-literals []
  (let [syms (reduce (symbol-literals)
                     {}
                     (fn [m kv]
                       (apply assoc m kv)))]
    (apply-to list
              (sm/set-val :sym-count (count syms))
              (sm/set-val :core-symbols syms))))

(defn serialize-symbol-literals []
  (for [syms (sm/get-val :symbols)
        _ (write "Value *symbol_literals() {\n")
        _ (write "List *syms = empty_list;\n")
        _ (cond
           (empty? (seq syms)) (sm/state-maybe "")
           (write "List *symInfo;\n"))
        _ (write-strs (flat-map (seq syms)
                                (fn [sym-lit]
                                  (let [sym (first sym-lit)
                                        ref (second sym-lit)]
                                    (list
                                     "symInfo = listCons(stringValue(\"" ref "\"), empty_list);\n"
                                     "symInfo = listCons(symbolValue(\"" sym "\"), symInfo);\n"
                                     "syms = listCons((Value *)symInfo, syms);\n")))))
        _ (write "return((Value *)syms);\n")
        _ (write "}\n\n")]
    ""))

(defn counts []
  (inline-text "return(counts());\n"))

(defn load-counts []
  (map (sm/state-maybe '_)
       (fn [_]
         (set-sym-count (nth (counts) 0 0)))))

(defn serialize-counts []
  (for [_ (write "\nValue *counts() {\n")
        _ (write "List *cnts = empty_list;\n")
        :let [gensym-count (get-sym-count)]
        _ (write-strs (list "cnts = listCons(numberValue(" gensym-count "), cnts);\n"))
        _ (write "return((Value *)cnts);\n")
        _ (write "}\n\n")]
    ""))

(defn types* []
  (inline-text "return(types());\n"))

(defn load-types []
  (let [types (reduce (types*)
                     {}
                     (fn [m kv]
                       (apply assoc m kv)))]
    (sm/set-val :types types)))

(defn serialize-types []
  (for [types (sm/get-val :types)
        _ (write "Value *types() {\n")
        _ (write "List *types = empty_list;\n")
        _ (write "List *typeInfo;\n")
        _ (write-strs (flat-map (seq types)
                                (fn [type]
                                  (let [type-sym (first type)
                                        type-num (second type)]
                                    (list
                                     "typeInfo = listCons(numberValue(" type-num "), empty_list);\n"
                                     "typeInfo = listCons(symbolValue(\"" type-sym "\"), typeInfo);\n"
                                     "types = listCons((Value *)typeInfo, types);\n")))))
        _ (write "return((Value *)types);\n")
        _ (write "}\n\n")]
    ""))

(defn compile-source [parser]
  (flat-map (sm/set-val :parser parser)
            (fn [_]
              (sm/recur (for [expr parser
                              ast (an/analyze-expr expr)
                              emitted (fr/evaluate ast emit-c)
                              _ (write-strs (.init emitted))]
                          "")))))

(defn built-in-protos [[name type-num]]
  (let [name (str name)
        type-name (list 'Getter
                        (list (list 'type-name
                                    (ast/fn-expr
                                     (ast/sym 'type-name_impl)
                                     (list
                                      (ast/fixed-arity
                                       (list '_)
                                       (list (fr/free
                                              (ast/const-string-ast name)))))))))]
    (for [_ (sm/set-val :expr name)
          _ (an/analyze-string)
          _ (emit-extension type-num type-name)]
      "")))

(defn compile-core [parser text]
  (for [types (sm/get-val :types)
        result (apply-to list
                         (sm/set-val :text text)
                         (sm/assoc-in-val (list :new-numbers)
                                          (reduce (seq types) {}
                                                  (fn [m [_ type-num]]
                                                    (assoc m type-num (str "_num_" type-num)))))
                         (apply-to list
                                   (base-types)
                                   (extern-functions)
                                   (fixed-fn-types)
                                   (write "List *empty_list = &(List){4,-1,0,0,0};\n")
                                   (base-fns)
                                   (emit-proto-fn "Function/"
                                                  (list 'invoke (map (range 8)
                                                                     (fn [num-args]
                                                                       (list (inc num-args) {})))))
                                   (emit-proto-fn "Getter/"
                                                  (list 'type-name (list (list 1 {}))))
                                   (emit-proto-fn "Getter/"
                                                  (list 'type-args (list (list 1 {}))))
                                   (for [expr (sm/get-val :expr)
                                         type-names (traverse (seq types) built-in-protos)
                                         _ (sm/set-val :expr expr)]
                                     ""))
                         (compile-source parser)
                         (for [get-sym (lookup-sym* 'get*)
                               get-fn-sym (lookup-static-fn (.c-val get-sym) 5)
                               _ (write-strs
                                  (list "Value *get(Value *node, Value *key, Value *val, Value *hash, Value *shift) {\n"
                                        "  return(" get-fn-sym "((List *)0, node, key, val, hash, shift));\n"
                                        "}\n"))]
                           "")
                         (for [assoc-sym (lookup-sym* 'assoc*)
                               assoc-fn-sym (lookup-static-fn (.c-val assoc-sym) 5)
                               _ (write-strs
                                  (list "Value *assoc(Value *node, Value *key, Value *val, Value *hash, Value *shift) {\n"
                                        "  return(" assoc-fn-sym "((List *)0, node, key, val, hash, shift));\n"
                                        "}\n"))]
                           "")
                         (for [equals-sym (lookup-sym* '=*)
                               equals-fn-sym (lookup-static-fn (.c-val equals-sym) 2)
                               _ (write-strs
                                  (list "Value *valsEqual(List *x, Value *v1, Value *v2) {\n"
                                        "  return(" equals-fn-sym "(x, v1, v2));\n"
                                        "}\n"))]
                           "")
                         (for [sha1-sym (lookup-sym* 'sha1)
                               sha1-fn-sym (lookup-static-fn (.c-val sha1-sym) 1)
                               _ (write-strs
                                  (list "Value *sha1(Value *v) {\n"
                                        "  return(" sha1-fn-sym "((List *)0, v));\n"
                                        "}\n"))]
                           "")
                         (for [hash-seq-sym (lookup-sym* 'hash-seq)
                               hash-seq-fn-sym (lookup-static-fn (.c-val hash-seq-sym) 2)
                               _ (write-strs
                                  (list "Value *hashSeq(Value *n, Value *s) {\n"
                                        "  return(" hash-seq-fn-sym "((List *)0, n, s));\n"
                                        "}\n"))]
                           "")
                         (for [count-sym (lookup-sym* 'count)
                               count-fn-sym (lookup-static-fn (.c-val count-sym) 1)
                               _ (write-strs
                                  (list "Value *count(Value *n) {\n"
                                        "  return(" count-fn-sym "((List *)0, n));\n"
                                        "}\n"))]
                           "")
                         (serialize-symbol-literals)
                         (serialize-number-literals)
                         (serialize-string-literals)
                         (serialize-keyword-literals)
                         (serialize-protocols)
                         (serialize-static-fns)
                         (serialize-defined-syms)
                         (serialize-types)
                         (serialize-counts))]
    result))

(defn analyze-toccata-core []
  (for [expr (an/is-expr (fn [x]
                        (cond
                         (not (seq? x)) false
                         (< (count x) 2) false
                         (= (first x) 'toccata-core))))]
    (fr/free (reify
               Emitter
               (emit-c [_]
                 (for [text (sm/get-val :text)
                       parser (sm/get-val :parser)
                       file-name (sm/get-val :file-name)
                       _ (sm/set-val :file-name "core")
                       :let [out-file (str (subs (second expr) 0 (- (count (second expr)) 3)) "c")
                             _ (output-to-file out-file)
                             ;; core (fio/file-stream (fio/fopen-read (second expr)))
                             core (slurp (second expr))
                             ]
                       _ (compile-core parser core)
                       :let [;; _ (fio/close-stream core)
                             _ (standard-output)]

                       syms (sm/get-val :symbols)
                       _ (sm/set-val :core-symbols syms)
                       _ (sm/set-val :symbols {})

                       kws (sm/get-val :keywords)
                       _ (sm/set-val :core-keywords kws)
                       _ (sm/set-val :keywords {})

                       strs (sm/get-val :strings)
                       _ (sm/set-val :core-strings strs)
                       _ (sm/set-val :strings {})

                       nums (sm/get-val :numbers)
                       _ (sm/set-val :core-numbers nums)
                       _ (sm/set-val :numbers {})

                       def-syms (sm/get-val :defined-syms)
                       _ (sm/set-val :core-defined-syms def-syms)
                       _ (sm/set-val :defined-syms {})

                       s-funs (sm/get-val :static-fns)
                       _ (sm/set-val :core-static-fns s-funs)
                       _ (sm/set-val :static-fns {})

                       _ (extern-base-types)

                       protos (sm/get-val :protocols)
                       _ (traverse (seq protos)
                                   (fn [proto]
                                     (let [impls (get (second proto) :impls {})]
                                       (comp
                                        (traverse (seq impls)
                                                  (fn [impl]
                                                    (write-strs (list "extern Function "
                                                                      (subs (:fn-sym (second impl)) 10)
                                                                      ";\n"))))
                                        (sm/state-maybe "")))))

                       _ (extern-functions)
                       _ (core-base-fns)
                       _ (fixed-fn-types)

                       type-name-sym (lookup-sym* 'type-name)
                       type-name-arity-sym (lookup-static-fn (.c-val type-name-sym) 1)
                       _ (write-strs (list "Value *"
                                           type-name-arity-sym
                                           "(List *closures, Value *arg0);\n"))

                       _ (sm/set-val :file-name file-name)
                       _ (sm/set-val :text text)]
                   (c-code "" empty-list "" :no-type)))))))

(defn compile-compiler [parser text]
  (apply-to list
            (sm/set-val :text text)
            (for [expr parser
                  _ (an/set-expr expr)
                  _ (sm/set-val :parser parser)
                  ast (analyze-toccata-core)
                  _ (fr/evaluate ast emit-c)
                  _ (compile-source parser)]
              "")
            (emit-main)))

(defn compile-main [parser text]
  (apply-to list
            (sm/set-val :text text)
            (extern-base-types)
            (extern-functions)
            (core-base-fns)
            (fixed-fn-types)
            (load-counts)
            (load-symbol-literals)
            (load-keyword-literals)
            (load-string-literals)
            (load-number-literals)
            (load-defined-syms)
            (load-protocols)
            (load-static-fns)
            (load-types)
            (for [type-name-sym (lookup-sym* 'type-name)
                  type-name-arity-sym (lookup-static-fn (.c-val type-name-sym) 1)
                  _ (write-strs (list "Value *" type-name-arity-sym "(List *closures, Value *arg0);\n"))]
              "")
            (compile-source parser)
            (emit-main)))

(defn compile-module [src-files]
  (let [p (fr/evaluate (grmr/read-form) parser/recursive-descent)
        parser (flat-map p (fn [v]
                             (cond
                              (empty? v) empty-list
                              (sm/state-maybe (first v)))))
        ;; text (fio/file-stream (fio/fopen-read (first src-files)))
        text (slurp (first src-files))
        compiling-fn (comp (compile-compiler parser text)
                           (compile-main parser text))
        types (types)
        number-type (get types 'Number :no-type)]
    (compiling-fn {:file-name (first src-files)
                   :line-num ""
                   :debug-on true
                   :line-num 0
                   :types types
                   :symbols {}
                   :keywords {}
                   :numbers {}
                   :strings {}
                   :new-strings {}
                   :new-numbers {}
                   :new-static-fns empty-list
                   :defined-protos {}
                   :local-syms {}
                   :local-sym-count 0
                   :context {}
                   :closed-over empty-list
                   :curr-arity-fn-sym ""
                   :curr-arg-count 0
                   :scope-locals {}
                   :new-externs empty-list
                   :static-fns {}
                   :defined-types {}
                   :defined-protos {}
                   :curr-fn-sym ""
                   :reify-fn-index 0
                   :protocols {}
                   :kw-count 0
                   :num-count 0
                   :str-count 0
                   :sym-count 0
                   :expr empty-list
                   :defined-syms (reduce (seq types) {}
                                         (fn [m type]
                                           (assoc m
                                             (first type)
                                             (list (str "Number _num_" (second type))
                                                   (c-code (str "(Value *)&_num_" (second type))
                                                           empty-list "" number-type)))))
                   :num-count (inc (count (seq types)))})
    ;; (fio/close-stream text)
    ))

(main [argList]
      (compile-module (rest argList)))

